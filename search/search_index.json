{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["trimmer","stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#_1","title":"Home","text":""},{"location":"#description","title":"Description","text":"<p>uORF4u is a bioinformatics tool for conserved upstream ORF annotation.   </p> <p>Programming language: Python3  OS: MacOS, Linux Python dependencies: biopython, configs, argparse, pandas, statistics, logomaker, matplotlib, reportlab. Python version: &gt;= 3.7 OS-level dependencies: mafft (v7.490 is included in the package) License: CC0 Version: 0.9.6.1 (June 2025)</p> <p>Web version is available at the Atkinson Lab Server Portal: server.atkinson-lab.com/uorf4u</p>"},{"location":"#data-analysis-pipeline","title":"Data analysis pipeline","text":""},{"location":"#installation","title":"Installation","text":"<ul> <li>The most stable release of uorf4u can be installed directly from pypi:</li> </ul> <pre><code>python3 -m pip install uorf4u\n</code></pre> <ul> <li>The development version is available at github :</li> </ul> <pre><code>git clone https://github.com/GCA-VH-lab/uorf4u.git\ncd uorf4u\npython3 -m pip install --upgrade pip\npython3 -m pip install wheel\npython3 setup.py sdist bdist_wheel\npython3 -m pip install -e .\n</code></pre> <p>! If you're a linux user, run <code>uorf4u --linux</code> post-install command once to update paths in the premade config files that set by default for MacOS users.</p>"},{"location":"#reference","title":"Reference","text":"<p>If you find uorf4u useful, please cite: Artyom. A. Egorov, Gemma C. Atkinson, uORF4u: a tool for annotation of conserved upstream open reading frames, Bioinformatics, Volume 39, Issue 5, May 2023, btad323; doi: 10.1093/bioinformatics/btad323</p>"},{"location":"#conservation-analysis-algorithm","title":"Conservation analysis algorithm","text":""},{"location":"#contact","title":"Contact","text":"<p>Please contact us by e-mail artemdotegorovATmeddotludotse or use Issues to report any technical problems. You can also use Discussions section for sharing your ideas or feature requests! </p>"},{"location":"#authors","title":"Authors","text":"<p>uORF4u is developed by Artyom Egorov at the Atkinson Lab, Department of Experimental Medical Science, Lund University, Sweden \ud83c\uddf8\ud83c\uddea. We are open for suggestions to extend and improve uorf4u functionality. Please don't hesitate to share your ideas or feature requests.</p>"},{"location":"API/package_data_processing/","title":"uorf4u.data_processing","text":"<p>This module provides data processing including uORFs annotation and conserved subset searching.</p>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Homologues","title":"<code>Homologues</code>","text":"<p>A Homologues object holds list of proteins homologues and information about them.</p> <p>Attributes:</p> <ul> <li> <code>accession_numbers</code>             (<code>list</code>)         \u2013          <p>List of RefSeq accession numbers.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>records</code>             (<code>list</code>)         \u2013          <p>list of RefSeqProtein objects of the proteins.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>class Homologues:\n    \"\"\"A Homologues object holds list of proteins homologues and information about them.\n\n    Attributes:\n        accession_numbers (list): List of RefSeq accession numbers.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        records (list): list of RefSeqProtein objects of the proteins.\n\n    \"\"\"\n\n    def __init__(self, accession_numbers: list, parameters: uorf4u.manager.Parameters):\n        \"\"\"Create a Homologues object.\n\n        Note:\n            With initialisation it also creates a 'records' attribute - a list of RefSeqProtein objects of proteins\n                based on accession numbers list.\n\n        Arguments:\n            accession_numbers (list): List of RefSeq accession numbers.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        try:\n            self.accession_numbers = accession_numbers\n            self.parameters = parameters\n            self.records = [RefSeqProtein(i, parameters) for i in accession_numbers]\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to create a Homologues class' object.\") from error\n\n    def get_upstream_sequences(self) -&gt; list:\n        \"\"\"Get upstream sequences of proteins' genes.\n\n        Note:\n            A protein may be found in multiple assemblies (for example in different strains).\n\n        Returns:\n            list: List of Bio.SeqRecord.SeqRecord objects of upstream sequences.\n\n        \"\"\"\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83d\udce1 Retrieving upstream sequences...\", file=sys.stdout)\n            for i in range(0, len(self.records), 200):\n                records_subset = self.records[i:i + 200]\n                accession_numbers = [record.accession_number for record in records_subset]\n                handle = Bio.Entrez.efetch(db=\"protein\", id=accession_numbers, rettype=\"ipg\", retmode=\"xml\")\n                handle_txt = handle.read().decode(\"utf-8\")\n                for record in records_subset:\n                    record.get_assemblies(handle_txt)\n                handle_fasta = Bio.Entrez.efetch(db=\"protein\", id=accession_numbers, rettype=\"fasta\", retmode=\"text\")\n                fasta_records = Bio.SeqIO.parse(handle_fasta, \"fasta\")\n                for f_record in fasta_records:\n                    record_index = accession_numbers.index(f_record.id)\n                    records_subset[record_index].record = f_record\n\n            proteins_wo_assemblies = []\n            if self.parameters.arguments[\"assemblies_list\"] == 'NA':\n                assemblies_table = [f\"accession_number\\tlocus_id\\tassembly\\torganism\\tstrain\\ttax_id\"]\n                list_of_protein_with_multiple_assemblies = []\n                numbers_of_assemblies = []\n                for record in self.records:\n                    numbers_of_assemblies.append(len(record.assemblies_coordinates))\n                    if len(record.assemblies_coordinates) == 0:\n                        proteins_wo_assemblies.append(record.accession_number)\n                    if len(record.assemblies_coordinates) &gt; 1:\n                        list_of_protein_with_multiple_assemblies.append(record.accession_number)\n                    for assembly in record.assemblies_coordinates:\n                        assemblies_table.append(\n                            f\"{record.accession_number}\\t\"\n                            f\"{assembly['locus_id']}:{assembly['start']}:{assembly['stop']}({assembly['strand']})\"\n                            f\"\\t{assembly['assembly']}\"\n                            f\"\\t{assembly['org']}\\t{assembly['strain']}\\t{assembly['taxid']}\")\n                if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                    os.mkdir(self.parameters.arguments[\"output_dir\"])\n                assemblies_table_path = os.path.join(self.parameters.arguments[\"output_dir\"], \"assemblies_list.tsv\")\n\n                assemblies_table_file = open(assemblies_table_path, \"w\")\n                assemblies_table_file.write(\"\\n\".join(assemblies_table))\n                assemblies_table_file.close()\n\n                proteins_wo_assemblies_txt = \"\\n\".join(proteins_wo_assemblies) + \"\\n\"\n                proteins_wo_assemblies_path = os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                           \"proteins_wo_assembly.txt\")\n                proteins_wo_assemblies_file = open(proteins_wo_assemblies_path, \"w\")\n                proteins_wo_assemblies_file.write(proteins_wo_assemblies_txt)\n                assemblies_selected_table_path = os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                              \"selected_assemblies_list.tsv\")\n                if numbers_of_assemblies.count(0) &gt; 0:\n                    print(f\"\u2757\ufe0fWarning message:\\n\\tFor {numbers_of_assemblies.count(0)} proteins \"\n                          f\"no assembly was found.\\n\"\n                          f\"\\tThese proteins' records can be suppressed by the ncbi\\n\\t\"\n                          f\"or they don't have loci that satisfies refseq_sequnces_regex config parameter.\\n\\t\"\n                          f\"List of these proteins was saved as: {os.path.basename(proteins_wo_assemblies_path)}\",\n                          file=sys.stderr)\n                if len(list_of_protein_with_multiple_assemblies) &gt; 0:\n                    print(f\"\u2757\ufe0fWarning message:\\n\\tFor {len(list_of_protein_with_multiple_assemblies)} proteins \"\n                          f\"multiple assemblies were found in identical protein database\\n\"\n                          f\"\\twith max number of assemblies per one protein as {max(numbers_of_assemblies)} \ud83d\ude31.\\n\\t\"\n                          f\"A table with information about the assemblies was saved as a tsv file: \"\n                          f\"{os.path.basename(assemblies_table_path)}.\\n\\tYou can edit it and remove lines with assemblies \"\n                          f\"you do not want to include in your analysis.\\n\"\n                          f\"\\tAfter filtering, you can use -al cmd parameter with your table as an argument.\\n\"\n                          f\"\\tIn addition, config file has 'max_number_of_assemblies' parameter \"\n                          f\"(set as {self.parameters.arguments['max_number_of_assemblies']}).\\n\\tBy default \u2755, it's used \"\n                          f\"by uorf4u to limit max number of assemblies included in the analysis;\\n\"\n                          f\"\\tand it works only if '-al' option is not provided. In case number of assemblies is more than \"\n                          f\"the cutoff,\\n\\trandom sampling \ud83c\udfb2 will be used to take only subset of them.\\n\\t\"\n                          f\"Selected assemblies information was savead as a tsv file: \"\n                          f\"{os.path.basename(assemblies_selected_table_path)}\"\n                          f\"\\n\\tSee documentation \ud83d\udcd6 for details.\", file=sys.stderr)\n            else:\n                assemblies_table = pandas.read_table(self.parameters.arguments[\"assemblies_list\"], sep=\"\\t\")\n                locus_ids = assemblies_table[\"locus_id\"].to_list()\n                locus_ids = [id.split(\":\")[0] for id in locus_ids]\n\n            upstream_sequences = []\n            an_with_no_annotated_useq = []\n            for record in self.records:\n                assemblies = record.assemblies_coordinates\n                if isinstance(self.parameters.arguments[\"max_number_of_assemblies\"], int) and \\\n                        self.parameters.arguments[\"assemblies_list\"] == \"NA\":\n                    if len(assemblies) &gt;= self.parameters.arguments[\"max_number_of_assemblies\"]:\n                        assemblies = random.sample(assemblies, self.parameters.arguments[\"max_number_of_assemblies\"])\n                if self.parameters.arguments[\"assemblies_list\"] != \"NA\":\n                    assemblies_filtered = [i for i in assemblies if i[\"locus_id\"] in locus_ids]\n                    assemblies = assemblies_filtered\n                record.assemblies_coordinates = assemblies\n\n            assemblies_table = [f\"accession_number\\tlocus_id\\tassembly\\torganism\\tstrain\\ttax_id\"]\n            for record in self.records:\n                for assembly in record.assemblies_coordinates:\n                    assemblies_table.append(\n                        f\"{record.accession_number}\\t\"\n                        f\"{assembly['locus_id']}:{assembly['start']}:{assembly['stop']}({assembly['strand']})\"\n                        f\"\\t{assembly['assembly']}\"\n                        f\"\\t{assembly['org']}\\t{assembly['strain']}\\t{assembly['taxid']}\")\n            assemblies_selected_table_path = os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                          \"selected_assemblies_list.tsv\")\n            assemblies_table_file = open(assemblies_selected_table_path, \"w\")\n            assemblies_table_file.write(\"\\n\".join(assemblies_table))\n            assemblies_table_file.close()\n\n            lists_of_assemblies = [record.assemblies_coordinates for record in self.records]\n            all_assemblies = [assembly for sublist in lists_of_assemblies for assembly in sublist]\n            for i in range(0, len(all_assemblies), 150):\n                assemblies_subset = all_assemblies[i:i + 150]\n                sequences_ids = [assembly[\"locus_id\"] for assembly in assemblies_subset]\n                handle = Bio.Entrez.efetch(db=\"nucleotide\", rettype=\"fasta\", retmode=\"txt\", id=sequences_ids)\n                records = Bio.SeqIO.parse(handle, \"fasta\")\n                for record, assembly in zip(records, assemblies_subset):\n                    assembly[\"record\"] = record\n\n            for record in self.records:\n                record_upstream_sequences = []\n                for assembly in record.assemblies_coordinates:\n                    locus_record = assembly[\"record\"]\n                    try:\n                        useq_downstream_region_length = min(self.parameters.arguments[\"downstream_region_length\"],\n                                                            len(record.record.seq) * 3)\n                    except:\n                        useq_downstream_region_length = self.parameters.arguments[\"downstream_region_length\"]\n                    useq_upstream_region_length = self.parameters.arguments[\"upstream_region_length\"]\n                    if assembly[\"strand\"] == \"+\":\n                        if self.parameters.arguments[\"upstream_region_length\"] == \"all\":\n                            useq_start = 0\n                        else:\n                            useq_start = max(0, assembly[\"start\"] - self.parameters.arguments[\"upstream_region_length\"])\n                        if useq_start == 0:\n                            useq_upstream_region_length = assembly[\"start\"]\n                        useq_stop = min(assembly[\"start\"] + self.parameters.arguments[\"downstream_region_length\"],\n                                        len(locus_record.seq))\n                        if useq_stop == len(locus_record.seq):\n                            useq_downstream_region_length = len(locus_record.seq) - assembly[\"start\"]\n                    elif assembly[\"strand\"] == \"-\":\n                        useq_start = max(0, assembly[\"stop\"] - self.parameters.arguments[\"downstream_region_length\"])\n                        if useq_start == 0:\n                            useq_downstream_region_length = assembly[\"stop\"]\n                        if self.parameters.arguments[\"upstream_region_length\"] == \"all\":\n                            useq_stop = len(locus_record.seq)\n                        else:\n                            useq_stop = min(len(locus_record.seq),\n                                            assembly[\"stop\"] + self.parameters.arguments[\"upstream_region_length\"])\n                        if useq_stop == len(locus_record.seq):\n                            useq_upstream_region_length = len(locus_record.seq) - assembly[\"stop\"]\n                    useq_length = abs(useq_stop - useq_start)\n                    if self.parameters.arguments[\"upstream_region_length\"] != \"all\":\n                        if self.parameters.arguments[\"minimal_upstream_region_length\"] &gt;= self.parameters.arguments[\n                            \"upstream_region_length\"]:\n                            self.parameters.arguments[\"minimal_upstream_region_length\"] = self.parameters.arguments[\n                                \"upstream_region_length\"]\n                    if useq_upstream_region_length &gt;= self.parameters.arguments[\"minimal_upstream_region_length\"] or \\\n                            self.parameters.arguments[\"upstream_region_length\"] == \"all\":\n                        useq = locus_record.seq[useq_start:useq_stop]\n                        if assembly[\"strand\"] == \"-\":\n                            useq = useq.reverse_complement()\n                        if assembly[\"strain\"] == \"NA\":\n                            useq_name = assembly[\"org\"]\n                        elif assembly[\"strain\"] in assembly[\"org\"]:\n                            useq_name = f\"{assembly['org'].replace(assembly['strain'], '')}{assembly['strain']}\"\n                        else:\n                            useq_name = f\"{assembly['org']} {assembly['strain']}\"\n                        useq_id = f\"{assembly['locus_id']},{useq_start}-{useq_stop}({assembly['strand']}),\" \\\n                                  f\"{record.accession_number}\"\n                        # useq_id = f\"{useq_name}_{assembly['locus_id']}_{record.accession_number}\"\n                        useq_label = f\"{useq_name},{assembly['locus_id']},{record.accession_number}\"\n                        useq_annotations = dict(RefSeq=True, locus_record=locus_record,\n                                                locus_id=assembly['locus_id'], length=useq_length,\n                                                start=useq_start, stop=useq_stop, strand=assembly[\"strand\"],\n                                                accession_number=record.accession_number,\n                                                organism=assembly['org'], label=useq_label,\n                                                upstream_region_length=useq_upstream_region_length,\n                                                downstream_region_length=useq_downstream_region_length)\n                        useq_record = Bio.SeqRecord.SeqRecord(useq, id=useq_id, description=useq_name,\n                                                              annotations=useq_annotations)\n                        record_upstream_sequences.append(useq_record)\n                upstream_sequences += record_upstream_sequences\n                if len(record_upstream_sequences) == 0:\n                    an_with_no_annotated_useq.append(record.accession_number)\n            if an_with_no_annotated_useq:\n                print(f\"\u2757Warning message:\\n\\tNo upstream sequences for {len(an_with_no_annotated_useq)} protein(s)\"\n                      f\" were annotated.\\n\\tCorresponding loci in the nucleotide ncbi database can be too short \ud83d\udccf.\\n\"\n                      f\"\\tSee 'minimal_upstream_region_length' config parameter description in the documentation.\",\n                      file=sys.stderr)\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\u2705 {len(upstream_sequences)} upstream sequences were obtained.\", file=sys.stdout)\n            return upstream_sequences\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to retrieve upstream sequences.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Homologues.__init__","title":"<code>__init__(accession_numbers, parameters)</code>","text":"<p>Create a Homologues object.</p> Note <p>With initialisation it also creates a 'records' attribute - a list of RefSeqProtein objects of proteins     based on accession numbers list.</p> <p>Parameters:</p> <ul> <li> <code>accession_numbers</code>             (<code>list</code>)         \u2013          <p>List of RefSeq accession numbers.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def __init__(self, accession_numbers: list, parameters: uorf4u.manager.Parameters):\n    \"\"\"Create a Homologues object.\n\n    Note:\n        With initialisation it also creates a 'records' attribute - a list of RefSeqProtein objects of proteins\n            based on accession numbers list.\n\n    Arguments:\n        accession_numbers (list): List of RefSeq accession numbers.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    try:\n        self.accession_numbers = accession_numbers\n        self.parameters = parameters\n        self.records = [RefSeqProtein(i, parameters) for i in accession_numbers]\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to create a Homologues class' object.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Homologues.get_upstream_sequences","title":"<code>get_upstream_sequences()</code>","text":"<p>Get upstream sequences of proteins' genes.</p> Note <p>A protein may be found in multiple assemblies (for example in different strains).</p> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>List of Bio.SeqRecord.SeqRecord objects of upstream sequences.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def get_upstream_sequences(self) -&gt; list:\n    \"\"\"Get upstream sequences of proteins' genes.\n\n    Note:\n        A protein may be found in multiple assemblies (for example in different strains).\n\n    Returns:\n        list: List of Bio.SeqRecord.SeqRecord objects of upstream sequences.\n\n    \"\"\"\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83d\udce1 Retrieving upstream sequences...\", file=sys.stdout)\n        for i in range(0, len(self.records), 200):\n            records_subset = self.records[i:i + 200]\n            accession_numbers = [record.accession_number for record in records_subset]\n            handle = Bio.Entrez.efetch(db=\"protein\", id=accession_numbers, rettype=\"ipg\", retmode=\"xml\")\n            handle_txt = handle.read().decode(\"utf-8\")\n            for record in records_subset:\n                record.get_assemblies(handle_txt)\n            handle_fasta = Bio.Entrez.efetch(db=\"protein\", id=accession_numbers, rettype=\"fasta\", retmode=\"text\")\n            fasta_records = Bio.SeqIO.parse(handle_fasta, \"fasta\")\n            for f_record in fasta_records:\n                record_index = accession_numbers.index(f_record.id)\n                records_subset[record_index].record = f_record\n\n        proteins_wo_assemblies = []\n        if self.parameters.arguments[\"assemblies_list\"] == 'NA':\n            assemblies_table = [f\"accession_number\\tlocus_id\\tassembly\\torganism\\tstrain\\ttax_id\"]\n            list_of_protein_with_multiple_assemblies = []\n            numbers_of_assemblies = []\n            for record in self.records:\n                numbers_of_assemblies.append(len(record.assemblies_coordinates))\n                if len(record.assemblies_coordinates) == 0:\n                    proteins_wo_assemblies.append(record.accession_number)\n                if len(record.assemblies_coordinates) &gt; 1:\n                    list_of_protein_with_multiple_assemblies.append(record.accession_number)\n                for assembly in record.assemblies_coordinates:\n                    assemblies_table.append(\n                        f\"{record.accession_number}\\t\"\n                        f\"{assembly['locus_id']}:{assembly['start']}:{assembly['stop']}({assembly['strand']})\"\n                        f\"\\t{assembly['assembly']}\"\n                        f\"\\t{assembly['org']}\\t{assembly['strain']}\\t{assembly['taxid']}\")\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            assemblies_table_path = os.path.join(self.parameters.arguments[\"output_dir\"], \"assemblies_list.tsv\")\n\n            assemblies_table_file = open(assemblies_table_path, \"w\")\n            assemblies_table_file.write(\"\\n\".join(assemblies_table))\n            assemblies_table_file.close()\n\n            proteins_wo_assemblies_txt = \"\\n\".join(proteins_wo_assemblies) + \"\\n\"\n            proteins_wo_assemblies_path = os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                       \"proteins_wo_assembly.txt\")\n            proteins_wo_assemblies_file = open(proteins_wo_assemblies_path, \"w\")\n            proteins_wo_assemblies_file.write(proteins_wo_assemblies_txt)\n            assemblies_selected_table_path = os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                          \"selected_assemblies_list.tsv\")\n            if numbers_of_assemblies.count(0) &gt; 0:\n                print(f\"\u2757\ufe0fWarning message:\\n\\tFor {numbers_of_assemblies.count(0)} proteins \"\n                      f\"no assembly was found.\\n\"\n                      f\"\\tThese proteins' records can be suppressed by the ncbi\\n\\t\"\n                      f\"or they don't have loci that satisfies refseq_sequnces_regex config parameter.\\n\\t\"\n                      f\"List of these proteins was saved as: {os.path.basename(proteins_wo_assemblies_path)}\",\n                      file=sys.stderr)\n            if len(list_of_protein_with_multiple_assemblies) &gt; 0:\n                print(f\"\u2757\ufe0fWarning message:\\n\\tFor {len(list_of_protein_with_multiple_assemblies)} proteins \"\n                      f\"multiple assemblies were found in identical protein database\\n\"\n                      f\"\\twith max number of assemblies per one protein as {max(numbers_of_assemblies)} \ud83d\ude31.\\n\\t\"\n                      f\"A table with information about the assemblies was saved as a tsv file: \"\n                      f\"{os.path.basename(assemblies_table_path)}.\\n\\tYou can edit it and remove lines with assemblies \"\n                      f\"you do not want to include in your analysis.\\n\"\n                      f\"\\tAfter filtering, you can use -al cmd parameter with your table as an argument.\\n\"\n                      f\"\\tIn addition, config file has 'max_number_of_assemblies' parameter \"\n                      f\"(set as {self.parameters.arguments['max_number_of_assemblies']}).\\n\\tBy default \u2755, it's used \"\n                      f\"by uorf4u to limit max number of assemblies included in the analysis;\\n\"\n                      f\"\\tand it works only if '-al' option is not provided. In case number of assemblies is more than \"\n                      f\"the cutoff,\\n\\trandom sampling \ud83c\udfb2 will be used to take only subset of them.\\n\\t\"\n                      f\"Selected assemblies information was savead as a tsv file: \"\n                      f\"{os.path.basename(assemblies_selected_table_path)}\"\n                      f\"\\n\\tSee documentation \ud83d\udcd6 for details.\", file=sys.stderr)\n        else:\n            assemblies_table = pandas.read_table(self.parameters.arguments[\"assemblies_list\"], sep=\"\\t\")\n            locus_ids = assemblies_table[\"locus_id\"].to_list()\n            locus_ids = [id.split(\":\")[0] for id in locus_ids]\n\n        upstream_sequences = []\n        an_with_no_annotated_useq = []\n        for record in self.records:\n            assemblies = record.assemblies_coordinates\n            if isinstance(self.parameters.arguments[\"max_number_of_assemblies\"], int) and \\\n                    self.parameters.arguments[\"assemblies_list\"] == \"NA\":\n                if len(assemblies) &gt;= self.parameters.arguments[\"max_number_of_assemblies\"]:\n                    assemblies = random.sample(assemblies, self.parameters.arguments[\"max_number_of_assemblies\"])\n            if self.parameters.arguments[\"assemblies_list\"] != \"NA\":\n                assemblies_filtered = [i for i in assemblies if i[\"locus_id\"] in locus_ids]\n                assemblies = assemblies_filtered\n            record.assemblies_coordinates = assemblies\n\n        assemblies_table = [f\"accession_number\\tlocus_id\\tassembly\\torganism\\tstrain\\ttax_id\"]\n        for record in self.records:\n            for assembly in record.assemblies_coordinates:\n                assemblies_table.append(\n                    f\"{record.accession_number}\\t\"\n                    f\"{assembly['locus_id']}:{assembly['start']}:{assembly['stop']}({assembly['strand']})\"\n                    f\"\\t{assembly['assembly']}\"\n                    f\"\\t{assembly['org']}\\t{assembly['strain']}\\t{assembly['taxid']}\")\n        assemblies_selected_table_path = os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                      \"selected_assemblies_list.tsv\")\n        assemblies_table_file = open(assemblies_selected_table_path, \"w\")\n        assemblies_table_file.write(\"\\n\".join(assemblies_table))\n        assemblies_table_file.close()\n\n        lists_of_assemblies = [record.assemblies_coordinates for record in self.records]\n        all_assemblies = [assembly for sublist in lists_of_assemblies for assembly in sublist]\n        for i in range(0, len(all_assemblies), 150):\n            assemblies_subset = all_assemblies[i:i + 150]\n            sequences_ids = [assembly[\"locus_id\"] for assembly in assemblies_subset]\n            handle = Bio.Entrez.efetch(db=\"nucleotide\", rettype=\"fasta\", retmode=\"txt\", id=sequences_ids)\n            records = Bio.SeqIO.parse(handle, \"fasta\")\n            for record, assembly in zip(records, assemblies_subset):\n                assembly[\"record\"] = record\n\n        for record in self.records:\n            record_upstream_sequences = []\n            for assembly in record.assemblies_coordinates:\n                locus_record = assembly[\"record\"]\n                try:\n                    useq_downstream_region_length = min(self.parameters.arguments[\"downstream_region_length\"],\n                                                        len(record.record.seq) * 3)\n                except:\n                    useq_downstream_region_length = self.parameters.arguments[\"downstream_region_length\"]\n                useq_upstream_region_length = self.parameters.arguments[\"upstream_region_length\"]\n                if assembly[\"strand\"] == \"+\":\n                    if self.parameters.arguments[\"upstream_region_length\"] == \"all\":\n                        useq_start = 0\n                    else:\n                        useq_start = max(0, assembly[\"start\"] - self.parameters.arguments[\"upstream_region_length\"])\n                    if useq_start == 0:\n                        useq_upstream_region_length = assembly[\"start\"]\n                    useq_stop = min(assembly[\"start\"] + self.parameters.arguments[\"downstream_region_length\"],\n                                    len(locus_record.seq))\n                    if useq_stop == len(locus_record.seq):\n                        useq_downstream_region_length = len(locus_record.seq) - assembly[\"start\"]\n                elif assembly[\"strand\"] == \"-\":\n                    useq_start = max(0, assembly[\"stop\"] - self.parameters.arguments[\"downstream_region_length\"])\n                    if useq_start == 0:\n                        useq_downstream_region_length = assembly[\"stop\"]\n                    if self.parameters.arguments[\"upstream_region_length\"] == \"all\":\n                        useq_stop = len(locus_record.seq)\n                    else:\n                        useq_stop = min(len(locus_record.seq),\n                                        assembly[\"stop\"] + self.parameters.arguments[\"upstream_region_length\"])\n                    if useq_stop == len(locus_record.seq):\n                        useq_upstream_region_length = len(locus_record.seq) - assembly[\"stop\"]\n                useq_length = abs(useq_stop - useq_start)\n                if self.parameters.arguments[\"upstream_region_length\"] != \"all\":\n                    if self.parameters.arguments[\"minimal_upstream_region_length\"] &gt;= self.parameters.arguments[\n                        \"upstream_region_length\"]:\n                        self.parameters.arguments[\"minimal_upstream_region_length\"] = self.parameters.arguments[\n                            \"upstream_region_length\"]\n                if useq_upstream_region_length &gt;= self.parameters.arguments[\"minimal_upstream_region_length\"] or \\\n                        self.parameters.arguments[\"upstream_region_length\"] == \"all\":\n                    useq = locus_record.seq[useq_start:useq_stop]\n                    if assembly[\"strand\"] == \"-\":\n                        useq = useq.reverse_complement()\n                    if assembly[\"strain\"] == \"NA\":\n                        useq_name = assembly[\"org\"]\n                    elif assembly[\"strain\"] in assembly[\"org\"]:\n                        useq_name = f\"{assembly['org'].replace(assembly['strain'], '')}{assembly['strain']}\"\n                    else:\n                        useq_name = f\"{assembly['org']} {assembly['strain']}\"\n                    useq_id = f\"{assembly['locus_id']},{useq_start}-{useq_stop}({assembly['strand']}),\" \\\n                              f\"{record.accession_number}\"\n                    # useq_id = f\"{useq_name}_{assembly['locus_id']}_{record.accession_number}\"\n                    useq_label = f\"{useq_name},{assembly['locus_id']},{record.accession_number}\"\n                    useq_annotations = dict(RefSeq=True, locus_record=locus_record,\n                                            locus_id=assembly['locus_id'], length=useq_length,\n                                            start=useq_start, stop=useq_stop, strand=assembly[\"strand\"],\n                                            accession_number=record.accession_number,\n                                            organism=assembly['org'], label=useq_label,\n                                            upstream_region_length=useq_upstream_region_length,\n                                            downstream_region_length=useq_downstream_region_length)\n                    useq_record = Bio.SeqRecord.SeqRecord(useq, id=useq_id, description=useq_name,\n                                                          annotations=useq_annotations)\n                    record_upstream_sequences.append(useq_record)\n            upstream_sequences += record_upstream_sequences\n            if len(record_upstream_sequences) == 0:\n                an_with_no_annotated_useq.append(record.accession_number)\n        if an_with_no_annotated_useq:\n            print(f\"\u2757Warning message:\\n\\tNo upstream sequences for {len(an_with_no_annotated_useq)} protein(s)\"\n                  f\" were annotated.\\n\\tCorresponding loci in the nucleotide ncbi database can be too short \ud83d\udccf.\\n\"\n                  f\"\\tSee 'minimal_upstream_region_length' config parameter description in the documentation.\",\n                  file=sys.stderr)\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\u2705 {len(upstream_sequences)} upstream sequences were obtained.\", file=sys.stdout)\n        return upstream_sequences\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to retrieve upstream sequences.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Locus","title":"<code>Locus</code>","text":"<p>A Locus object holds sequence and annotation of the corresponding ncbi Reference Sequence.</p> <p>Attributes:</p> <ul> <li> <code>locus_id</code>             (<code>str</code>)         \u2013          <p>a NCBI locus id from the Nucleotide database.</p> </li> <li> <code>locus_record</code>             (<code>SeqRecord</code>)         \u2013          <p>a biopython record object of the sequence.</p> </li> <li> <code>CDSs</code>             (<code>list</code>)         \u2013          <p>list of dicts with information about annotated CDS in the locus' sequence.</p> </li> <li> <code>start_b</code>             (<code>int</code>)         \u2013          <p>start of region within annotation should be retrieved.</p> </li> <li> <code>stop_b</code>             (<code>int</code>)         \u2013          <p>stop of region within annotation should be retrieved.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>class Locus:\n    \"\"\"\n    A Locus object holds sequence and annotation of the corresponding ncbi Reference Sequence.\n\n    Attributes:\n        locus_id (str): a NCBI locus id from the Nucleotide database.\n        locus_record (Bio.SeqRecord.SeqRecord): a biopython record object of the sequence.\n        CDSs (list): list of dicts with information about annotated CDS in the locus' sequence.\n        start_b (int): start of region within annotation should be retrieved.\n        stop_b (int): stop of region within annotation should be retrieved.\n\n    \"\"\"\n\n    def __init__(self, locus_id: str, start_b: int = 0, stop_b: int = None, target_strand: str = \"NA\",\n                 locus_record=None, xml_output=None):\n        \"\"\"Create a Locus object.\n\n        Note:\n            0-based format is used for sequence indexing.\n\n        Arguments:\n            locus_id (str): locus id from the ncbi nucleotide database.\n            start_b (int): start of region within annotation should be retrieved (optional).\n            stop_b (int): stop of region within annotation should be retrieved (optional).\n            target_strand (str): strand of the target object (optional).\n\n        \"\"\"\n        try:\n            self.locus_id = locus_id\n            if not locus_record:\n                handle = Bio.Entrez.efetch(db=\"nucleotide\", rettype=\"fasta\", retmode=\"txt\", id=locus_id)\n                self.locus_record = Bio.SeqIO.read(handle, \"fasta\")\n            else:\n                self.locus_record = locus_record\n            if stop_b is None:\n                stop_b = len(self.locus_record.seq)\n            if not xml_output:\n                handle = Bio.Entrez.efetch(db=\"nucleotide\", rettype=\"gbwithparts\", retmode=\"xml\", id=locus_id)\n                xml_output = (handle.read()).decode(\"utf-8\")\n            root = xml.etree.ElementTree.fromstring(xml_output)\n            self.CDSs = []\n            for gbseq in root.iter(\"GBSeq\"):\n                if gbseq.find(\"GBSeq_accession-version\").text == self.locus_id:\n                    for gbfeature in gbseq.iter(\"GBFeature\"):\n                        if gbfeature.find(\"GBFeature_key\").text == \"CDS\":\n                            try:\n                                starts, stops = [], []\n                                for interval in gbfeature.iter(\"GBInterval\"):\n                                    try:\n                                        start, stop = int(interval.find(\"GBInterval_from\").text), int(\n                                            interval.find(\"GBInterval_to\").text)\n                                        if start &gt; stop:\n                                            start, stop, strand = stop - 1, start, \"-\"\n                                        else:\n                                            start, stop, strand = start - 1, stop, \"+\"\n                                        starts.append(start)\n                                        stops.append(stop)\n                                    except:\n                                        pass\n                                if starts:\n                                    coordinates = list(sorted(zip(starts, stops), key=lambda pair: pair[0]))\n                                    main_start, main_stop = coordinates[0][0], coordinates[-1][-1]\n                                    if strand == \"+\":\n                                        main_stop = main_stop - 3\n                                    elif strand == \"-\":\n                                        main_start = main_start + 3\n                                    relative_start, relative_stop = main_start - start_b, main_stop - start_b\n                                    if strand == target_strand:\n                                        relative_strand = \"+\"\n                                    else:\n                                        relative_strand = \"-\"\n                                        useq_length = stop_b - start_b\n                                    if target_strand == \"-\":\n                                        relative_start, relative_stop = useq_length - relative_stop, useq_length - relative_start\n\n                                    if (start_b &lt;= main_start &lt; stop_b) or (start_b &lt;= main_stop &lt; stop_b):\n                                        cds_seq = self.locus_record.seq[main_start:main_stop]\n                                        if strand == '-':\n                                            cds_seq = cds_seq.reverse_complement()\n                                        protein_id, product_name = 'NA', 'NA'\n                                        for gbqualifier in gbfeature.iter(\"GBQualifier\"):\n                                            if gbqualifier.find(\"GBQualifier_name\").text == \"protein_id\":\n                                                protein_id = gbqualifier.find(\"GBQualifier_value\").text\n                                            if gbqualifier.find(\"GBQualifier_name\").text == \"product\":\n                                                product_name = gbqualifier.find(\"GBQualifier_value\").text\n                                        if protein_id != 'NA':\n                                            if product_name != 'NA':\n                                                product_name = f\"{protein_id} ({product_name})\"\n                                            else:\n                                                product_name = f\"{protein_id}\"\n                                            self.CDSs.append(dict(protein_id=protein_id, product_name=product_name,\n                                                                  coordinates=coordinates, nt_seq=cds_seq,\n                                                                  main_start=main_start, main_stop=main_stop,\n                                                                  strand=strand,\n                                                                  relative_start=relative_start,\n                                                                  relative_stop=relative_stop,\n                                                                  relative_strand=relative_strand))\n                            except:\n                                pass\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to create a Locus class' object.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Locus.__init__","title":"<code>__init__(locus_id, start_b=0, stop_b=None, target_strand='NA', locus_record=None, xml_output=None)</code>","text":"<p>Create a Locus object.</p> Note <p>0-based format is used for sequence indexing.</p> <p>Parameters:</p> <ul> <li> <code>locus_id</code>             (<code>str</code>)         \u2013          <p>locus id from the ncbi nucleotide database.</p> </li> <li> <code>start_b</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>start of region within annotation should be retrieved (optional).</p> </li> <li> <code>stop_b</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>stop of region within annotation should be retrieved (optional).</p> </li> <li> <code>target_strand</code>             (<code>str</code>, default:                 <code>'NA'</code> )         \u2013          <p>strand of the target object (optional).</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def __init__(self, locus_id: str, start_b: int = 0, stop_b: int = None, target_strand: str = \"NA\",\n             locus_record=None, xml_output=None):\n    \"\"\"Create a Locus object.\n\n    Note:\n        0-based format is used for sequence indexing.\n\n    Arguments:\n        locus_id (str): locus id from the ncbi nucleotide database.\n        start_b (int): start of region within annotation should be retrieved (optional).\n        stop_b (int): stop of region within annotation should be retrieved (optional).\n        target_strand (str): strand of the target object (optional).\n\n    \"\"\"\n    try:\n        self.locus_id = locus_id\n        if not locus_record:\n            handle = Bio.Entrez.efetch(db=\"nucleotide\", rettype=\"fasta\", retmode=\"txt\", id=locus_id)\n            self.locus_record = Bio.SeqIO.read(handle, \"fasta\")\n        else:\n            self.locus_record = locus_record\n        if stop_b is None:\n            stop_b = len(self.locus_record.seq)\n        if not xml_output:\n            handle = Bio.Entrez.efetch(db=\"nucleotide\", rettype=\"gbwithparts\", retmode=\"xml\", id=locus_id)\n            xml_output = (handle.read()).decode(\"utf-8\")\n        root = xml.etree.ElementTree.fromstring(xml_output)\n        self.CDSs = []\n        for gbseq in root.iter(\"GBSeq\"):\n            if gbseq.find(\"GBSeq_accession-version\").text == self.locus_id:\n                for gbfeature in gbseq.iter(\"GBFeature\"):\n                    if gbfeature.find(\"GBFeature_key\").text == \"CDS\":\n                        try:\n                            starts, stops = [], []\n                            for interval in gbfeature.iter(\"GBInterval\"):\n                                try:\n                                    start, stop = int(interval.find(\"GBInterval_from\").text), int(\n                                        interval.find(\"GBInterval_to\").text)\n                                    if start &gt; stop:\n                                        start, stop, strand = stop - 1, start, \"-\"\n                                    else:\n                                        start, stop, strand = start - 1, stop, \"+\"\n                                    starts.append(start)\n                                    stops.append(stop)\n                                except:\n                                    pass\n                            if starts:\n                                coordinates = list(sorted(zip(starts, stops), key=lambda pair: pair[0]))\n                                main_start, main_stop = coordinates[0][0], coordinates[-1][-1]\n                                if strand == \"+\":\n                                    main_stop = main_stop - 3\n                                elif strand == \"-\":\n                                    main_start = main_start + 3\n                                relative_start, relative_stop = main_start - start_b, main_stop - start_b\n                                if strand == target_strand:\n                                    relative_strand = \"+\"\n                                else:\n                                    relative_strand = \"-\"\n                                    useq_length = stop_b - start_b\n                                if target_strand == \"-\":\n                                    relative_start, relative_stop = useq_length - relative_stop, useq_length - relative_start\n\n                                if (start_b &lt;= main_start &lt; stop_b) or (start_b &lt;= main_stop &lt; stop_b):\n                                    cds_seq = self.locus_record.seq[main_start:main_stop]\n                                    if strand == '-':\n                                        cds_seq = cds_seq.reverse_complement()\n                                    protein_id, product_name = 'NA', 'NA'\n                                    for gbqualifier in gbfeature.iter(\"GBQualifier\"):\n                                        if gbqualifier.find(\"GBQualifier_name\").text == \"protein_id\":\n                                            protein_id = gbqualifier.find(\"GBQualifier_value\").text\n                                        if gbqualifier.find(\"GBQualifier_name\").text == \"product\":\n                                            product_name = gbqualifier.find(\"GBQualifier_value\").text\n                                    if protein_id != 'NA':\n                                        if product_name != 'NA':\n                                            product_name = f\"{protein_id} ({product_name})\"\n                                        else:\n                                            product_name = f\"{protein_id}\"\n                                        self.CDSs.append(dict(protein_id=protein_id, product_name=product_name,\n                                                              coordinates=coordinates, nt_seq=cds_seq,\n                                                              main_start=main_start, main_stop=main_stop,\n                                                              strand=strand,\n                                                              relative_start=relative_start,\n                                                              relative_stop=relative_stop,\n                                                              relative_strand=relative_strand))\n                        except:\n                            pass\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to create a Locus class' object.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.ORF","title":"<code>ORF</code>","text":"<p>An ORF object holds information about an annotated ORF.</p> Note <p>It's supposed that the ORFs class' objects will not be used directly by API users since     it's only needed for other classes' methods.</p> <p>Attributes:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>id</code>             (<code>str</code>)         \u2013          <p>identifier of the ORF. Format: locus_id_accession_number_distance_from_the_start_codon_to_the_main_orf</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of the ORF. Format: useq_name_distance_from_the_start_codon_to_the_main_orf</p> </li> <li> <code>sequence_id</code>             (<code>str</code>)         \u2013          <p>identifier of the ORF's sequence (locus id from the ncbi database).</p> </li> <li> <code>start</code>             (<code>int</code>)         \u2013          <p>start position of the ORF on the locus (0-based).</p> </li> <li> <code>stop</code>             (<code>int</code>)         \u2013          <p>stop position of the ORF on the locus (0-based).</p> </li> <li> <code>length</code>             (<code>int</code>)         \u2013          <p>ORF's nucleotide sequence length.</p> </li> <li> <code>nt_sequence</code>             (<code>Seq</code>)         \u2013          <p>a Seq object of nucleotide sequence of the ORF.</p> </li> <li> <code>aa_sequence</code>             (<code>Seq</code>)         \u2013          <p>a Seq object of amino acid sequence of the ORF.</p> </li> <li> <code>sd_window_seq</code>             (<code>Seq</code>)         \u2013          <p>a Seq object of upstream sequence to the start codon of the ORF.</p> </li> <li> <code>min_energy</code>             (<code>float</code>)         \u2013          <p>minimal value of thermodynamic interaction between aSD and putative SD sequences within the upstream sequences to the start codon.</p> </li> <li> <code>putative_sd_sequence</code>             (<code>Seq</code>)         \u2013          <p>a Seq object of the putative SD sequence with the minimal energy value.</p> </li> <li> <code>extended_orfs</code>             (<code>list</code>)         \u2013          <p>a list of ORFs with that are in frame with the ORF, but have upstream start codon.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>class ORF:\n    \"\"\"An ORF object holds information about an annotated ORF.\n\n    Note:\n        It's supposed that the ORFs class' objects will not be used directly by API users since\n            it's only needed for other classes' methods.\n\n    Attributes:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        id (str): identifier of the ORF. Format: locus_id_accession_number_distance_from_the_start_codon_to_the_main_orf\n        name (str): name of the ORF. Format: useq_name_distance_from_the_start_codon_to_the_main_orf\n        sequence_id (str): identifier of the ORF's sequence (locus id from the ncbi database).\n        start (int): start position of the ORF on the locus (0-based).\n        stop (int): stop position of the ORF on the locus (0-based).\n        length (int): ORF's nucleotide sequence length.\n        nt_sequence (Bio.Seq.Seq): a Seq object of nucleotide sequence of the ORF.\n        aa_sequence (Bio.Seq.Seq): a Seq object of amino acid sequence of the ORF.\n        sd_window_seq (Bio.Seq.Seq): a Seq object of upstream sequence to the start codon of the ORF.\n        min_energy (float): minimal value of thermodynamic interaction between aSD and putative SD sequences within the\n            upstream sequences to the start codon.\n        putative_sd_sequence (Bio.Seq.Seq): a Seq object of the putative SD sequence with the minimal energy value.\n        extended_orfs (list): a list of ORFs with that are in frame with the ORF, but have upstream start codon.\n\n    \"\"\"\n\n    def __init__(self, parameters: uorf4u.manager.Parameters, id: str, name: str, nt_sequence: Bio.Seq.Seq,\n                 contig_coordinates: str, sd_window_seq: Bio.Seq.Seq, start: int, stop: int, distance: int,\n                 useq_index: int, annotation: str = \"NA\"):\n        \"\"\"Create an ORF object.\n\n        Arguments:\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n            id (str): identifier of the ORF. Format: locus_id:distance_from_the_start_codon_to_the_proteins_orf:length.\n            nt_sequence (Bio.Seq.Seq): a Seq object of nucleotide sequence of the ORF.\n            sd_window_seq (Bio.Seq.Seq): a Seq object of upstream sequence to the start codon of the ORF.\n            contig_coordinates (str): coordinates on the corresponding contig/transcript\n            start (int): start position of the ORF on the locus (0-based).\n            stop (int): stop position of the ORF on the locus (0-based).\n            distance (int): distance to the main ORF.\n\n        \"\"\"\n\n        self.parameters = parameters\n        codon_table = Bio.Data.CodonTable.unambiguous_dna_by_name[  # ambiguous can be needed!\n            parameters.arguments[\"ncbi_genetic_code_name\"]]\n        codon_table_ambiguous = Bio.Data.CodonTable.ambiguous_dna_by_name[  # ambiguous can be needed!\n            parameters.arguments[\"ncbi_genetic_code_name\"]]\n        self.name = name\n        self.distance = distance\n        self.id = id\n        self.sequence_id = id.split(\":\")[0]\n        self.start = start\n        self.stop = stop\n        self.length = len(nt_sequence)\n        self.nt_sequence = nt_sequence\n        self.annotation = annotation\n        self.useq_index = useq_index\n        self.contig_coordinates = contig_coordinates\n        try:\n            self.aa_sequence = self.nt_sequence.translate(table=codon_table)\n        except:\n            self.aa_sequence = self.nt_sequence.translate(table=codon_table_ambiguous)\n        self.sd_window_seq = sd_window_seq\n        self.extended_orfs = []\n        self.min_energy = 0\n        self.putative_sd_sequence = \"NA\"\n        self.sd_window_seq_str = \"NA\"\n        self.sd_window_energies = []\n\n    def calculate_energies(self) -&gt; None:\n        \"\"\"Calculate energies of putative SD sequences of the upstream sequence.\n\n        Returns:\n            None\n\n        \"\"\"\n        # Loading reference energies json file\n        with open(self.parameters.arguments[\"ref_energies\"]) as ref_energy_file:\n            ref_energy = json.load(ref_energy_file)\n        sd_seq_length = min([len(i) for i in ref_energy.keys()])\n        # Energies calculations\n        if len(self.sd_window_seq) &gt;= min(ref_energy.values()):\n            energies = []\n            for position in range((len(self.sd_window_seq) - sd_seq_length) + 1):\n                try:\n                    energies.append(\n                        ref_energy[self.sd_window_seq[position:position + sd_seq_length]])\n                except:\n                    energies.append(0)\n            if energies:\n                self.min_energy = min(energies)\n                self.sd_window_energies = [str(i) for i in energies]\n                if self.min_energy &lt; self.parameters.arguments[\"sd_energy_cutoff\"]:\n                    sd_start_position = energies.index(self.min_energy)  # Be careful, it could be more than one!\n                    self.putative_sd_sequence = self.sd_window_seq[sd_start_position:sd_start_position + sd_seq_length]\n                    self.sd_window_seq_str = (f\"{self.sd_window_seq[0:sd_start_position].lower()}\"\n                                              f\"{self.putative_sd_sequence.upper()}\"\n                                              f\"{self.sd_window_seq[sd_start_position + sd_seq_length:].lower()}\")\n\n        return None\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.ORF.__init__","title":"<code>__init__(parameters, id, name, nt_sequence, contig_coordinates, sd_window_seq, start, stop, distance, useq_index, annotation='NA')</code>","text":"<p>Create an ORF object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>id</code>             (<code>str</code>)         \u2013          <p>identifier of the ORF. Format: locus_id:distance_from_the_start_codon_to_the_proteins_orf:length.</p> </li> <li> <code>nt_sequence</code>             (<code>Seq</code>)         \u2013          <p>a Seq object of nucleotide sequence of the ORF.</p> </li> <li> <code>sd_window_seq</code>             (<code>Seq</code>)         \u2013          <p>a Seq object of upstream sequence to the start codon of the ORF.</p> </li> <li> <code>contig_coordinates</code>             (<code>str</code>)         \u2013          <p>coordinates on the corresponding contig/transcript</p> </li> <li> <code>start</code>             (<code>int</code>)         \u2013          <p>start position of the ORF on the locus (0-based).</p> </li> <li> <code>stop</code>             (<code>int</code>)         \u2013          <p>stop position of the ORF on the locus (0-based).</p> </li> <li> <code>distance</code>             (<code>int</code>)         \u2013          <p>distance to the main ORF.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def __init__(self, parameters: uorf4u.manager.Parameters, id: str, name: str, nt_sequence: Bio.Seq.Seq,\n             contig_coordinates: str, sd_window_seq: Bio.Seq.Seq, start: int, stop: int, distance: int,\n             useq_index: int, annotation: str = \"NA\"):\n    \"\"\"Create an ORF object.\n\n    Arguments:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        id (str): identifier of the ORF. Format: locus_id:distance_from_the_start_codon_to_the_proteins_orf:length.\n        nt_sequence (Bio.Seq.Seq): a Seq object of nucleotide sequence of the ORF.\n        sd_window_seq (Bio.Seq.Seq): a Seq object of upstream sequence to the start codon of the ORF.\n        contig_coordinates (str): coordinates on the corresponding contig/transcript\n        start (int): start position of the ORF on the locus (0-based).\n        stop (int): stop position of the ORF on the locus (0-based).\n        distance (int): distance to the main ORF.\n\n    \"\"\"\n\n    self.parameters = parameters\n    codon_table = Bio.Data.CodonTable.unambiguous_dna_by_name[  # ambiguous can be needed!\n        parameters.arguments[\"ncbi_genetic_code_name\"]]\n    codon_table_ambiguous = Bio.Data.CodonTable.ambiguous_dna_by_name[  # ambiguous can be needed!\n        parameters.arguments[\"ncbi_genetic_code_name\"]]\n    self.name = name\n    self.distance = distance\n    self.id = id\n    self.sequence_id = id.split(\":\")[0]\n    self.start = start\n    self.stop = stop\n    self.length = len(nt_sequence)\n    self.nt_sequence = nt_sequence\n    self.annotation = annotation\n    self.useq_index = useq_index\n    self.contig_coordinates = contig_coordinates\n    try:\n        self.aa_sequence = self.nt_sequence.translate(table=codon_table)\n    except:\n        self.aa_sequence = self.nt_sequence.translate(table=codon_table_ambiguous)\n    self.sd_window_seq = sd_window_seq\n    self.extended_orfs = []\n    self.min_energy = 0\n    self.putative_sd_sequence = \"NA\"\n    self.sd_window_seq_str = \"NA\"\n    self.sd_window_energies = []\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.ORF.calculate_energies","title":"<code>calculate_energies()</code>","text":"<p>Calculate energies of putative SD sequences of the upstream sequence.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def calculate_energies(self) -&gt; None:\n    \"\"\"Calculate energies of putative SD sequences of the upstream sequence.\n\n    Returns:\n        None\n\n    \"\"\"\n    # Loading reference energies json file\n    with open(self.parameters.arguments[\"ref_energies\"]) as ref_energy_file:\n        ref_energy = json.load(ref_energy_file)\n    sd_seq_length = min([len(i) for i in ref_energy.keys()])\n    # Energies calculations\n    if len(self.sd_window_seq) &gt;= min(ref_energy.values()):\n        energies = []\n        for position in range((len(self.sd_window_seq) - sd_seq_length) + 1):\n            try:\n                energies.append(\n                    ref_energy[self.sd_window_seq[position:position + sd_seq_length]])\n            except:\n                energies.append(0)\n        if energies:\n            self.min_energy = min(energies)\n            self.sd_window_energies = [str(i) for i in energies]\n            if self.min_energy &lt; self.parameters.arguments[\"sd_energy_cutoff\"]:\n                sd_start_position = energies.index(self.min_energy)  # Be careful, it could be more than one!\n                self.putative_sd_sequence = self.sd_window_seq[sd_start_position:sd_start_position + sd_seq_length]\n                self.sd_window_seq_str = (f\"{self.sd_window_seq[0:sd_start_position].lower()}\"\n                                          f\"{self.putative_sd_sequence.upper()}\"\n                                          f\"{self.sd_window_seq[sd_start_position + sd_seq_length:].lower()}\")\n\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path","title":"<code>Path</code>","text":"<p>A Path object holds information about a list of conserved ORFs.</p> Note <p>It's supposed that the Path class' objects will not be used directly by API users since     it's only needed for other classes' methods.</p> <p>Attributes:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>path</code>             (<code>list</code>)         \u2013          <p>List of the ORF class objects.</p> </li> <li> <code>score</code>             (<code>float</code>)         \u2013          <p>Score of the Path (calculated as sum of pairwise alignments scores of ORFs).</p> </li> <li> <code>msa</code>             (<code>dict</code>)         \u2013          <p>Dict with Multiple sequence alignment (MSA, Bio.Align.MultipleSeqAlignment object) as values for different sequences (nt, aa, sd) as keys.</p> </li> <li> <code>msa_consensus</code>             (<code>dict</code>)         \u2013          <p>Dict with consensus sequence (Bio.Seq.Seq object) as values for different sequences (nt, aa, sd) as keys.</p> </li> <li> <code>length</code>         \u2013          <p>length of the nucleotide sequence alignment.</p> </li> <li> <code>id</code>             (<code>str</code>)         \u2013          <p>Path's id (format: length_score_num_of_orfs_average_distance_to_the_main_ORF</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>class Path:\n    \"\"\"A Path object holds information about a list of conserved ORFs.\n\n    Note:\n        It's supposed that the Path class' objects will not be used directly by API users since\n            it's only needed for other classes' methods.\n\n    Attributes:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        path (list): List of the ORF class objects.\n        score (float): Score of the Path (calculated as sum of pairwise alignments scores of ORFs).\n        msa (dict): Dict with Multiple sequence alignment (MSA, Bio.Align.MultipleSeqAlignment object) as values\n            for different sequences (nt, aa, sd) as keys.\n        msa_consensus (dict): Dict with consensus sequence (Bio.Seq.Seq object) as values\n            for different sequences (nt, aa, sd) as keys.\n        length: length of the nucleotide sequence alignment.\n        id (str): Path's id (format: length_score_num_of_orfs_average_distance_to_the_main_ORF\n\n    \"\"\"\n\n    def __init__(self, parameters: uorf4u.manager.Parameters):\n        \"\"\"Create a Path object.\n\n        Arguments:\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.parameters = parameters\n        self.path = []\n        self.score = 0\n        self.msa = dict()\n        self.msa_consensus = dict()\n        self.id = None\n        self.length = None\n\n    def update(self, orf: ORF, score=0):\n        \"\"\"Update a Path with a new ORF.\n\n        Arguments:\n            orf (ORF): an ORF class' object.\n            score (float): a sum of pairwise alignment scores of the ORF against all ORFs in the Path.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.path.append(orf)\n        self.score += score\n\n    def sort(self) -&gt; None:\n        \"\"\"Sort list of ORFs by their names.\n\n        Returns:\n            None\n\n        \"\"\"\n        sorted_path = [x for _, x in sorted(zip([i.name for i in self.path], self.path), key=lambda pair: pair[0])]\n        self.path = sorted_path\n\n        return None\n\n    def __len__(self):\n        \"\"\"__len__ magic method for a Path object.\n\n        Returns:\n            int: length of the path attribute - a number of ORFs in a Path.\n\n        \"\"\"\n        return len(self.path)\n\n    def calculate_similarity(self, other) -&gt; float:\n        \"\"\"Calculate fraction of identical ORFs between two Path object.\n\n        __Note:__ If two objects have different length, the fraction will be calculated as a number of identical ORFs\n                divided by length of the shortest Path.\n\n        Returns:\n            float: fraction of identical ORFs.\n\n        \"\"\"\n        num_of_identical_elements = len(set(self.path) &amp; set(other.path))\n        fraction_of_identical_orfs = num_of_identical_elements / min(len(self), len(other))\n        return fraction_of_identical_orfs\n\n    def muscle_msa(self) -&gt; None:\n        \"\"\"Run a multiple sequence alignment tool (muscle) for the ORFs nucleotide and amino acid sequences.\n\n        Note:\n            This method updates nt_msa and aa_msa attributes.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.msa = dict()\n        for seq_type in self.parameters.arguments[\"sequences_to_write\"]:\n            records = []\n            for orf in self.path:\n                # record_id = f\"{orf.id}\"\n                # record_description = f\"{(orf.name.split('_')[0])}\"\n                record_id = f\"{orf.name}\"\n                record_description = \"\"\n                if seq_type == \"nt\":\n                    record = Bio.SeqRecord.SeqRecord(orf.nt_sequence, record_id, \"\", record_description)\n                elif seq_type == \"aa\":\n                    record = Bio.SeqRecord.SeqRecord(orf.aa_sequence, record_id, \"\", record_description)\n                elif seq_type == \"sd\":\n                    record = Bio.SeqRecord.SeqRecord(orf.sd_window_seq, record_id, \"\", record_description)\n                records.append(record)\n            temp_input = tempfile.NamedTemporaryFile()\n            Bio.SeqIO.write(records, temp_input.name, \"fasta\")\n            temp_output = tempfile.NamedTemporaryFile()\n            muscle = self.parameters.arguments[\"muscle_binary\"]\n            subprocess.run([muscle, \"-align\", temp_input.name, \"-output\", temp_output.name],\n                           stderr=subprocess.DEVNULL)\n            temp_input.close()\n            msa = Bio.AlignIO.read(temp_output.name, \"fasta\")\n            # msa.sort(key=lambda r: r.description)\n            msa_info = Bio.Align.AlignInfo.SummaryInfo(msa)\n            msa_consensus = msa_info.gap_consensus(threshold=self.parameters.arguments[\"consensus_threshold\"])\n            temp_output.close()\n            if seq_type == \"nt\":\n                self.length = msa.get_alignment_length()\n            self.msa[seq_type], self.msa_consensus[seq_type] = msa, msa_consensus\n\n            avr_distance = str(round(statistics.mean([i.distance for i in self.path])))\n            self.id = f\"length-{self.msa['nt'].get_alignment_length()},score\u2013{round(self.score)},\" \\\n                      f\"num-of-orfs-{len(self.path)},avr_dist-{avr_distance}\"\n        return None\n\n    def maft_msa(self) -&gt; None:\n        \"\"\"Run a multiple sequence alignment tool (MAFT) for the ORFs nucleotide and amino acid sequences.\n\n        Note:\n            This method updates nt_msa and aa_msa attributes.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.msa = dict()\n        for seq_type in self.parameters.arguments[\"sequences_to_write\"]:\n            records = []\n            for orf in self.path:\n                # record_id = f\"{orf.id}\"\n                # record_description = f\"{(orf.name.split('_')[0])}\"\n                record_id = f\"{orf.id}\"\n                record_description = orf.name\n                if seq_type == \"nt\":\n                    record = Bio.SeqRecord.SeqRecord(orf.nt_sequence, record_id, \"\", record_description)\n                elif seq_type == \"aa\":\n                    record = Bio.SeqRecord.SeqRecord(orf.aa_sequence, record_id, \"\", record_description)\n                elif seq_type == \"sd\":\n                    record = Bio.SeqRecord.SeqRecord(orf.sd_window_seq, record_id, \"\", record_description)\n                records.append(record)\n            temp_input = tempfile.NamedTemporaryFile()\n            Bio.SeqIO.write(records, temp_input.name, \"fasta\")\n            temp_output = tempfile.NamedTemporaryFile()\n            temp_stderr = tempfile.NamedTemporaryFile()\n            maft = self.parameters.arguments[\"maft_binary\"]\n            try:\n                subprocess.run([maft, \"--auto\", \"--reorder\", temp_input.name], stdout=temp_output, stderr=temp_stderr)\n                msa = Bio.AlignIO.read(temp_output.name, \"fasta\")\n                temp_stderr.close()\n                temp_output.close()\n            except Exception as error:\n                temp_stderr.seek(0)\n                temp_output.seek(0)\n                print(f\"\ud83e\udd2c MAFFT error message:\\n{temp_stderr.read()}\", file=sys.stderr)\n                temp_stderr.close()\n                temp_output.close()\n                raise uorf4u.manager.uORF4uError(f\"mafft error. If you work on a linux machine,\"\n                                                 f\" run uorf4 --linux.\") from error\n            for record in msa:\n                record.description = \" \".join(record.description.split(\" \")[1:])\n            # msa.sort(key=lambda r: r.description) # add a parameter for order setting\n            msa_info = Bio.Align.AlignInfo.SummaryInfo(msa)\n            msa_consensus = msa_info.gap_consensus(threshold=self.parameters.arguments[\"consensus_threshold\"])\n            temp_output.close()\n            if seq_type == \"nt\":\n                self.length = msa.get_alignment_length()\n            self.msa[seq_type], self.msa_consensus[seq_type] = msa, msa_consensus\n            avr_distance = str(round(statistics.mean([i.distance for i in self.path])))\n            self.id = f\"length-{self.msa['nt'].get_alignment_length()},score\u2013{round(self.score)},\" \\\n                      f\"num_of_orfs-{len(self.path)},avr_dist-{avr_distance}\"\n        return None\n\n    def plot_msa(self) -&gt; None:\n        \"\"\"Plot MSA of conserved ORFs.\n\n        Returns:\n            None\n\n        \"\"\"\n\n        rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n        output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                               [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                             f\"{rename_dict[i]}_msa_visualisation\") for i in\n                                self.parameters.arguments[\"sequences_to_write\"]]))\n        for o_dir in output_dirs.values():\n            if not (os.path.exists(o_dir)):\n                os.mkdir(o_dir)\n\n        for s_type in self.parameters.arguments[\"sequences_to_write\"]:\n            current_msa = self.msa[s_type]\n            if s_type == \"nt\" or s_type == \"sd\":\n                seq_type = \"nt\"\n            else:\n                seq_type = \"aa\"\n            msa_plot_manager = uorf4u.drawing_msa.MSAPlotManager(current_msa, self.parameters, seq_type)\n            msa_plot_manager.define_x_axis_coordinate_system()\n            output_file = os.path.join(output_dirs[s_type], f\"{self.id}.pdf\")\n            msa_plot_manager.create_tracks()\n            msa_plot_manager.plot(output_file)\n\n    def plot_ggmsa(self) -&gt; None:\n        \"\"\"Plot MSA of conserved ORFs saved as fasta files.\n\n        Note:\n            R script based on ggmsa package [yulab-smu.top/ggmsa] used to produce MSA plots. R script (msa_plot.R)\n                can be found in output_dir. This method uses subprocess to run this R script in the following way:\n                `Rscript {output_dir}/msa_plot.R --msa_fasta path_to_fasta --output output_path --seq_type (nt/aa)\n                --width N(mm) --height M(mm)`.\n                Since during each run of uorf4u a local copy of this script is created\n                in your output_dir, you can change it without any consequences for next uorf4u runs.\n\n        Returns:\n            None\n\n        \"\"\"\n\n        rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n        output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                               [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                             f\"{rename_dict[i]}_msa_visualisation\") for i in\n                                self.parameters.arguments[\"sequences_to_write\"]]))\n        fasta_files_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                                    [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                  f\"{rename_dict[i]}_msa_fasta_files\") for i in\n                                     self.parameters.arguments[\"sequences_to_write\"]]))\n        for o_dir in output_dirs.values():\n            if not (os.path.exists(o_dir)):\n                os.mkdir(o_dir)\n        r_script_path = self.parameters.arguments[\"plot_msa_R_script\"]\n        r_script_local = os.path.join(self.parameters.arguments[\"output_dir\"], os.path.basename(r_script_path))\n        if not (os.path.exists(r_script_local)):\n            shutil.copy(r_script_path, r_script_local)\n        for s_type in self.parameters.arguments[\"sequences_to_write\"]:\n            current_msa = self.msa[s_type]\n            if s_type == \"nt\" or s_type == \"sd\":\n                seq_type = \"nt\"\n            else:\n                seq_type = \"aa\"\n\n            output_dir = os.path.abspath(os.path.join(output_dirs[s_type]))\n            input_file = os.path.abspath(os.path.join(fasta_files_dirs[s_type], f\"{self.id}.fa\"))\n            num_sequences = len(current_msa)\n            length_of_alignment = current_msa.get_alignment_length()\n            page_width = (50 + length_of_alignment) * 5\n            page_height = max(17, (num_sequences + 5) * 3)\n            subprocess.run([\"Rscript\", r_script_local, \"--msa_fasta\", input_file, \"--output\", output_dir,\n                            \"--seq_type\", seq_type, \"--width\", str(page_width), \"--height\", str(page_height)])\n\n    def plot_logo(self) -&gt; None:\n        \"\"\"Plot sequence Logo of conserved ORFs MSA saved as fasta files.\n\n        Note:\n            This method uses logomaker package to produce images.\n\n        Returns:\n            None\n\n        \"\"\"\n        rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n        output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                               [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                             f\"{rename_dict[i]}_seqlogo_visualisation\") for i in\n                                self.parameters.arguments['sequences_to_write']]))\n\n        for o_dir in output_dirs.values():\n            if not (os.path.exists(o_dir)):\n                os.mkdir(o_dir)\n        ambiguous_codon_table = Bio.Data.CodonTable.ambiguous_dna_by_name[\n            self.parameters.arguments[\"ncbi_genetic_code_name\"]]\n        unambiguous_codon_table = Bio.Data.CodonTable.unambiguous_dna_by_name[\n            self.parameters.arguments[\"ncbi_genetic_code_name\"]]\n        alphabet = dict(nt=set(ambiguous_codon_table.nucleotide_alphabet),\n                        aa=set(ambiguous_codon_table.protein_alphabet))\n        unambiguous_alphabet = dict(nt=set(unambiguous_codon_table.nucleotide_alphabet),\n                                    aa=set(unambiguous_codon_table.protein_alphabet))\n        for s_type in self.parameters.arguments[\"sequences_to_write\"]:\n            current_msa = self.msa[s_type]\n            if s_type == \"nt\" or s_type == \"sd\":\n                seq_type = \"nt\"\n            elif s_type == \"aa\":\n                seq_type = \"aa\"\n            output_file = os.path.abspath(\n                os.path.join(output_dirs[s_type], os.path.basename(self.id)))\n            msa_length = current_msa.get_alignment_length()\n            num_of_sequences = len(current_msa)\n            current_msa_info = Bio.Align.AlignInfo.SummaryInfo(current_msa)\n            pos_specific_dict = dict()\n            pos_specific_score_matrix = current_msa_info.pos_specific_score_matrix()\n            for i in alphabet[seq_type]:\n                pos_specific_dict[i] = [0 for j in range(msa_length)]\n            for i in range(msa_length):\n                for element in pos_specific_score_matrix[i].keys():\n                    pos_specific_dict[element.upper()][i] = (pos_specific_score_matrix[i][element] / num_of_sequences)\n            pos = [i for i in range(msa_length)]\n            pos_specific_dict = {k: v for k, v in pos_specific_dict.items() if\n                                 sum(v) &gt; 0 or k in unambiguous_alphabet[seq_type]}\n            matrix_fr = pandas.DataFrame(pos_specific_dict, index=pos)\n            colors = self.parameters.arguments[f\"colors_{seq_type}\"]\n            colors = {k: uorf4u.methods.color_name_to_hex(v, self.parameters.arguments) for k, v in colors.items()}\n            fig_size = (min(max(10, msa_length * 1.3), ((2 ** 16) - 1) / 100),\n                        min(2.5, 2.5 * 10 / (msa_length ** (1 / 5))))\n\n            if self.parameters.arguments[\"logo_type\"] == \"probability\" or \\\n                    self.parameters.arguments[\"logo_type\"] == \"both\":\n                output_file_fr = f\"{output_file}_prob.pdf\"\n                max_value_fr = 1\n                logo_fr = logomaker.Logo(matrix_fr, color_scheme=colors, figsize=fig_size,\n                                         alpha=self.parameters.arguments[\"logo_alpha\"], show_spines=False,\n                                         baseline_width=0)\n                logo_fr.style_spines(spines=[\"left\"], visible=True, linewidth=0.7)\n                logo_fr.ax.set_xticks([])\n                logo_fr.ax.set_yticks([0, max_value_fr])\n                plt.savefig(output_file_fr)\n                plt.close(\"all\")\n\n            if self.parameters.arguments[\"logo_type\"] == \"information\" or \\\n                    self.parameters.arguments[\"logo_type\"] == \"both\":\n                colors[\"-\"] = colors[\"_\"]\n                matrix_fr[\"-\"] = round((1 - matrix_fr.sum(axis=1)), 5)\n                if matrix_fr[\"-\"].sum() == 0:\n                    del matrix_fr['-']\n                matrix_info = logomaker.transform_matrix(matrix_fr, from_type=\"probability\", to_type=\"information\")\n                max_value_info = math.log2(len(pos_specific_dict.keys()))\n                output_file_info = f\"{output_file}_info.pdf\"\n                logo_info = logomaker.Logo(matrix_info, color_scheme=colors, figsize=fig_size,\n                                           alpha=self.parameters.arguments[\"logo_alpha\"], show_spines=False,\n                                           baseline_width=0)\n                logo_info.style_spines(spines=[\"left\"], visible=True, linewidth=0.7)\n                logo_info.ax.set_xticks([])\n                logo_info.ax.set_yticks([0, max_value_info])\n                plt.savefig(output_file_info)\n                plt.close(\"all\")\n        return None\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a Path object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def __init__(self, parameters: uorf4u.manager.Parameters):\n    \"\"\"Create a Path object.\n\n    Arguments:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.parameters = parameters\n    self.path = []\n    self.score = 0\n    self.msa = dict()\n    self.msa_consensus = dict()\n    self.id = None\n    self.length = None\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.__len__","title":"<code>__len__()</code>","text":"<p>len magic method for a Path object.</p> <p>Returns:</p> <ul> <li> <code>int</code>        \u2013          <p>length of the path attribute - a number of ORFs in a Path.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def __len__(self):\n    \"\"\"__len__ magic method for a Path object.\n\n    Returns:\n        int: length of the path attribute - a number of ORFs in a Path.\n\n    \"\"\"\n    return len(self.path)\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.calculate_similarity","title":"<code>calculate_similarity(other)</code>","text":"<p>Calculate fraction of identical ORFs between two Path object.</p> <p>Note: If two objects have different length, the fraction will be calculated as a number of identical ORFs         divided by length of the shortest Path.</p> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>fraction of identical ORFs.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def calculate_similarity(self, other) -&gt; float:\n    \"\"\"Calculate fraction of identical ORFs between two Path object.\n\n    __Note:__ If two objects have different length, the fraction will be calculated as a number of identical ORFs\n            divided by length of the shortest Path.\n\n    Returns:\n        float: fraction of identical ORFs.\n\n    \"\"\"\n    num_of_identical_elements = len(set(self.path) &amp; set(other.path))\n    fraction_of_identical_orfs = num_of_identical_elements / min(len(self), len(other))\n    return fraction_of_identical_orfs\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.maft_msa","title":"<code>maft_msa()</code>","text":"<p>Run a multiple sequence alignment tool (MAFT) for the ORFs nucleotide and amino acid sequences.</p> Note <p>This method updates nt_msa and aa_msa attributes.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def maft_msa(self) -&gt; None:\n    \"\"\"Run a multiple sequence alignment tool (MAFT) for the ORFs nucleotide and amino acid sequences.\n\n    Note:\n        This method updates nt_msa and aa_msa attributes.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.msa = dict()\n    for seq_type in self.parameters.arguments[\"sequences_to_write\"]:\n        records = []\n        for orf in self.path:\n            # record_id = f\"{orf.id}\"\n            # record_description = f\"{(orf.name.split('_')[0])}\"\n            record_id = f\"{orf.id}\"\n            record_description = orf.name\n            if seq_type == \"nt\":\n                record = Bio.SeqRecord.SeqRecord(orf.nt_sequence, record_id, \"\", record_description)\n            elif seq_type == \"aa\":\n                record = Bio.SeqRecord.SeqRecord(orf.aa_sequence, record_id, \"\", record_description)\n            elif seq_type == \"sd\":\n                record = Bio.SeqRecord.SeqRecord(orf.sd_window_seq, record_id, \"\", record_description)\n            records.append(record)\n        temp_input = tempfile.NamedTemporaryFile()\n        Bio.SeqIO.write(records, temp_input.name, \"fasta\")\n        temp_output = tempfile.NamedTemporaryFile()\n        temp_stderr = tempfile.NamedTemporaryFile()\n        maft = self.parameters.arguments[\"maft_binary\"]\n        try:\n            subprocess.run([maft, \"--auto\", \"--reorder\", temp_input.name], stdout=temp_output, stderr=temp_stderr)\n            msa = Bio.AlignIO.read(temp_output.name, \"fasta\")\n            temp_stderr.close()\n            temp_output.close()\n        except Exception as error:\n            temp_stderr.seek(0)\n            temp_output.seek(0)\n            print(f\"\ud83e\udd2c MAFFT error message:\\n{temp_stderr.read()}\", file=sys.stderr)\n            temp_stderr.close()\n            temp_output.close()\n            raise uorf4u.manager.uORF4uError(f\"mafft error. If you work on a linux machine,\"\n                                             f\" run uorf4 --linux.\") from error\n        for record in msa:\n            record.description = \" \".join(record.description.split(\" \")[1:])\n        # msa.sort(key=lambda r: r.description) # add a parameter for order setting\n        msa_info = Bio.Align.AlignInfo.SummaryInfo(msa)\n        msa_consensus = msa_info.gap_consensus(threshold=self.parameters.arguments[\"consensus_threshold\"])\n        temp_output.close()\n        if seq_type == \"nt\":\n            self.length = msa.get_alignment_length()\n        self.msa[seq_type], self.msa_consensus[seq_type] = msa, msa_consensus\n        avr_distance = str(round(statistics.mean([i.distance for i in self.path])))\n        self.id = f\"length-{self.msa['nt'].get_alignment_length()},score\u2013{round(self.score)},\" \\\n                  f\"num_of_orfs-{len(self.path)},avr_dist-{avr_distance}\"\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.muscle_msa","title":"<code>muscle_msa()</code>","text":"<p>Run a multiple sequence alignment tool (muscle) for the ORFs nucleotide and amino acid sequences.</p> Note <p>This method updates nt_msa and aa_msa attributes.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def muscle_msa(self) -&gt; None:\n    \"\"\"Run a multiple sequence alignment tool (muscle) for the ORFs nucleotide and amino acid sequences.\n\n    Note:\n        This method updates nt_msa and aa_msa attributes.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.msa = dict()\n    for seq_type in self.parameters.arguments[\"sequences_to_write\"]:\n        records = []\n        for orf in self.path:\n            # record_id = f\"{orf.id}\"\n            # record_description = f\"{(orf.name.split('_')[0])}\"\n            record_id = f\"{orf.name}\"\n            record_description = \"\"\n            if seq_type == \"nt\":\n                record = Bio.SeqRecord.SeqRecord(orf.nt_sequence, record_id, \"\", record_description)\n            elif seq_type == \"aa\":\n                record = Bio.SeqRecord.SeqRecord(orf.aa_sequence, record_id, \"\", record_description)\n            elif seq_type == \"sd\":\n                record = Bio.SeqRecord.SeqRecord(orf.sd_window_seq, record_id, \"\", record_description)\n            records.append(record)\n        temp_input = tempfile.NamedTemporaryFile()\n        Bio.SeqIO.write(records, temp_input.name, \"fasta\")\n        temp_output = tempfile.NamedTemporaryFile()\n        muscle = self.parameters.arguments[\"muscle_binary\"]\n        subprocess.run([muscle, \"-align\", temp_input.name, \"-output\", temp_output.name],\n                       stderr=subprocess.DEVNULL)\n        temp_input.close()\n        msa = Bio.AlignIO.read(temp_output.name, \"fasta\")\n        # msa.sort(key=lambda r: r.description)\n        msa_info = Bio.Align.AlignInfo.SummaryInfo(msa)\n        msa_consensus = msa_info.gap_consensus(threshold=self.parameters.arguments[\"consensus_threshold\"])\n        temp_output.close()\n        if seq_type == \"nt\":\n            self.length = msa.get_alignment_length()\n        self.msa[seq_type], self.msa_consensus[seq_type] = msa, msa_consensus\n\n        avr_distance = str(round(statistics.mean([i.distance for i in self.path])))\n        self.id = f\"length-{self.msa['nt'].get_alignment_length()},score\u2013{round(self.score)},\" \\\n                  f\"num-of-orfs-{len(self.path)},avr_dist-{avr_distance}\"\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.plot_ggmsa","title":"<code>plot_ggmsa()</code>","text":"<p>Plot MSA of conserved ORFs saved as fasta files.</p> Note <p>R script based on ggmsa package [yulab-smu.top/ggmsa] used to produce MSA plots. R script (msa_plot.R)     can be found in output_dir. This method uses subprocess to run this R script in the following way:     <code>Rscript {output_dir}/msa_plot.R --msa_fasta path_to_fasta --output output_path --seq_type (nt/aa)     --width N(mm) --height M(mm)</code>.     Since during each run of uorf4u a local copy of this script is created     in your output_dir, you can change it without any consequences for next uorf4u runs.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def plot_ggmsa(self) -&gt; None:\n    \"\"\"Plot MSA of conserved ORFs saved as fasta files.\n\n    Note:\n        R script based on ggmsa package [yulab-smu.top/ggmsa] used to produce MSA plots. R script (msa_plot.R)\n            can be found in output_dir. This method uses subprocess to run this R script in the following way:\n            `Rscript {output_dir}/msa_plot.R --msa_fasta path_to_fasta --output output_path --seq_type (nt/aa)\n            --width N(mm) --height M(mm)`.\n            Since during each run of uorf4u a local copy of this script is created\n            in your output_dir, you can change it without any consequences for next uorf4u runs.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n    output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                           [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                         f\"{rename_dict[i]}_msa_visualisation\") for i in\n                            self.parameters.arguments[\"sequences_to_write\"]]))\n    fasta_files_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                                [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                              f\"{rename_dict[i]}_msa_fasta_files\") for i in\n                                 self.parameters.arguments[\"sequences_to_write\"]]))\n    for o_dir in output_dirs.values():\n        if not (os.path.exists(o_dir)):\n            os.mkdir(o_dir)\n    r_script_path = self.parameters.arguments[\"plot_msa_R_script\"]\n    r_script_local = os.path.join(self.parameters.arguments[\"output_dir\"], os.path.basename(r_script_path))\n    if not (os.path.exists(r_script_local)):\n        shutil.copy(r_script_path, r_script_local)\n    for s_type in self.parameters.arguments[\"sequences_to_write\"]:\n        current_msa = self.msa[s_type]\n        if s_type == \"nt\" or s_type == \"sd\":\n            seq_type = \"nt\"\n        else:\n            seq_type = \"aa\"\n\n        output_dir = os.path.abspath(os.path.join(output_dirs[s_type]))\n        input_file = os.path.abspath(os.path.join(fasta_files_dirs[s_type], f\"{self.id}.fa\"))\n        num_sequences = len(current_msa)\n        length_of_alignment = current_msa.get_alignment_length()\n        page_width = (50 + length_of_alignment) * 5\n        page_height = max(17, (num_sequences + 5) * 3)\n        subprocess.run([\"Rscript\", r_script_local, \"--msa_fasta\", input_file, \"--output\", output_dir,\n                        \"--seq_type\", seq_type, \"--width\", str(page_width), \"--height\", str(page_height)])\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.plot_logo","title":"<code>plot_logo()</code>","text":"<p>Plot sequence Logo of conserved ORFs MSA saved as fasta files.</p> Note <p>This method uses logomaker package to produce images.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def plot_logo(self) -&gt; None:\n    \"\"\"Plot sequence Logo of conserved ORFs MSA saved as fasta files.\n\n    Note:\n        This method uses logomaker package to produce images.\n\n    Returns:\n        None\n\n    \"\"\"\n    rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n    output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                           [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                         f\"{rename_dict[i]}_seqlogo_visualisation\") for i in\n                            self.parameters.arguments['sequences_to_write']]))\n\n    for o_dir in output_dirs.values():\n        if not (os.path.exists(o_dir)):\n            os.mkdir(o_dir)\n    ambiguous_codon_table = Bio.Data.CodonTable.ambiguous_dna_by_name[\n        self.parameters.arguments[\"ncbi_genetic_code_name\"]]\n    unambiguous_codon_table = Bio.Data.CodonTable.unambiguous_dna_by_name[\n        self.parameters.arguments[\"ncbi_genetic_code_name\"]]\n    alphabet = dict(nt=set(ambiguous_codon_table.nucleotide_alphabet),\n                    aa=set(ambiguous_codon_table.protein_alphabet))\n    unambiguous_alphabet = dict(nt=set(unambiguous_codon_table.nucleotide_alphabet),\n                                aa=set(unambiguous_codon_table.protein_alphabet))\n    for s_type in self.parameters.arguments[\"sequences_to_write\"]:\n        current_msa = self.msa[s_type]\n        if s_type == \"nt\" or s_type == \"sd\":\n            seq_type = \"nt\"\n        elif s_type == \"aa\":\n            seq_type = \"aa\"\n        output_file = os.path.abspath(\n            os.path.join(output_dirs[s_type], os.path.basename(self.id)))\n        msa_length = current_msa.get_alignment_length()\n        num_of_sequences = len(current_msa)\n        current_msa_info = Bio.Align.AlignInfo.SummaryInfo(current_msa)\n        pos_specific_dict = dict()\n        pos_specific_score_matrix = current_msa_info.pos_specific_score_matrix()\n        for i in alphabet[seq_type]:\n            pos_specific_dict[i] = [0 for j in range(msa_length)]\n        for i in range(msa_length):\n            for element in pos_specific_score_matrix[i].keys():\n                pos_specific_dict[element.upper()][i] = (pos_specific_score_matrix[i][element] / num_of_sequences)\n        pos = [i for i in range(msa_length)]\n        pos_specific_dict = {k: v for k, v in pos_specific_dict.items() if\n                             sum(v) &gt; 0 or k in unambiguous_alphabet[seq_type]}\n        matrix_fr = pandas.DataFrame(pos_specific_dict, index=pos)\n        colors = self.parameters.arguments[f\"colors_{seq_type}\"]\n        colors = {k: uorf4u.methods.color_name_to_hex(v, self.parameters.arguments) for k, v in colors.items()}\n        fig_size = (min(max(10, msa_length * 1.3), ((2 ** 16) - 1) / 100),\n                    min(2.5, 2.5 * 10 / (msa_length ** (1 / 5))))\n\n        if self.parameters.arguments[\"logo_type\"] == \"probability\" or \\\n                self.parameters.arguments[\"logo_type\"] == \"both\":\n            output_file_fr = f\"{output_file}_prob.pdf\"\n            max_value_fr = 1\n            logo_fr = logomaker.Logo(matrix_fr, color_scheme=colors, figsize=fig_size,\n                                     alpha=self.parameters.arguments[\"logo_alpha\"], show_spines=False,\n                                     baseline_width=0)\n            logo_fr.style_spines(spines=[\"left\"], visible=True, linewidth=0.7)\n            logo_fr.ax.set_xticks([])\n            logo_fr.ax.set_yticks([0, max_value_fr])\n            plt.savefig(output_file_fr)\n            plt.close(\"all\")\n\n        if self.parameters.arguments[\"logo_type\"] == \"information\" or \\\n                self.parameters.arguments[\"logo_type\"] == \"both\":\n            colors[\"-\"] = colors[\"_\"]\n            matrix_fr[\"-\"] = round((1 - matrix_fr.sum(axis=1)), 5)\n            if matrix_fr[\"-\"].sum() == 0:\n                del matrix_fr['-']\n            matrix_info = logomaker.transform_matrix(matrix_fr, from_type=\"probability\", to_type=\"information\")\n            max_value_info = math.log2(len(pos_specific_dict.keys()))\n            output_file_info = f\"{output_file}_info.pdf\"\n            logo_info = logomaker.Logo(matrix_info, color_scheme=colors, figsize=fig_size,\n                                       alpha=self.parameters.arguments[\"logo_alpha\"], show_spines=False,\n                                       baseline_width=0)\n            logo_info.style_spines(spines=[\"left\"], visible=True, linewidth=0.7)\n            logo_info.ax.set_xticks([])\n            logo_info.ax.set_yticks([0, max_value_info])\n            plt.savefig(output_file_info)\n            plt.close(\"all\")\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.plot_msa","title":"<code>plot_msa()</code>","text":"<p>Plot MSA of conserved ORFs.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def plot_msa(self) -&gt; None:\n    \"\"\"Plot MSA of conserved ORFs.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n    output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                           [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                         f\"{rename_dict[i]}_msa_visualisation\") for i in\n                            self.parameters.arguments[\"sequences_to_write\"]]))\n    for o_dir in output_dirs.values():\n        if not (os.path.exists(o_dir)):\n            os.mkdir(o_dir)\n\n    for s_type in self.parameters.arguments[\"sequences_to_write\"]:\n        current_msa = self.msa[s_type]\n        if s_type == \"nt\" or s_type == \"sd\":\n            seq_type = \"nt\"\n        else:\n            seq_type = \"aa\"\n        msa_plot_manager = uorf4u.drawing_msa.MSAPlotManager(current_msa, self.parameters, seq_type)\n        msa_plot_manager.define_x_axis_coordinate_system()\n        output_file = os.path.join(output_dirs[s_type], f\"{self.id}.pdf\")\n        msa_plot_manager.create_tracks()\n        msa_plot_manager.plot(output_file)\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.sort","title":"<code>sort()</code>","text":"<p>Sort list of ORFs by their names.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def sort(self) -&gt; None:\n    \"\"\"Sort list of ORFs by their names.\n\n    Returns:\n        None\n\n    \"\"\"\n    sorted_path = [x for _, x in sorted(zip([i.name for i in self.path], self.path), key=lambda pair: pair[0])]\n    self.path = sorted_path\n\n    return None\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.Path.update","title":"<code>update(orf, score=0)</code>","text":"<p>Update a Path with a new ORF.</p> <p>Parameters:</p> <ul> <li> <code>orf</code>             (<code>ORF</code>)         \u2013          <p>an ORF class' object.</p> </li> <li> <code>score</code>             (<code>float</code>, default:                 <code>0</code> )         \u2013          <p>a sum of pairwise alignment scores of the ORF against all ORFs in the Path.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def update(self, orf: ORF, score=0):\n    \"\"\"Update a Path with a new ORF.\n\n    Arguments:\n        orf (ORF): an ORF class' object.\n        score (float): a sum of pairwise alignment scores of the ORF against all ORFs in the Path.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.path.append(orf)\n    self.score += score\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.RefSeqProtein","title":"<code>RefSeqProtein</code>","text":"<p>A RefSeqProtein object holds a RefSeq protein and information about it.</p> <p>Attributes:</p> <ul> <li> <code>accession_number</code>             (<code>str</code>)         \u2013          <p>RefSeq accession number.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>record</code>             (<code>SeqRecord</code>)         \u2013          <p>SeqRecord of the ncbi protein db. Can be obtained by the get_record() method.</p> </li> <li> <code>taxid</code>             (<code>str</code>)         \u2013          <p>Taxid of the protein. Can be obtained with get_assemblies() method.</p> </li> <li> <code>kingdom_taxid</code>             (<code>str</code>)         \u2013          <p>Kingdom taxid of a protein. Can be obtained with get_assemblies() method.</p> </li> <li> <code>organism</code>             (<code>str</code>)         \u2013          <p>Organism name of a protein. Can be obtained with get_assemblies() method.</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Protein's product name from the ncbi (if available).</p> </li> <li> <code>assemblies_coordinates</code>             (<code>list</code>)         \u2013          <p>List of dictionaries with information about assemblies' coordinates of the protein obtained from ipg ncbi database.</p> </li> <li> <code>loci</code>             (<code>dict</code>)         \u2013          <p>Dict with keys as locus_ids and values as Locus class' objects.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>class RefSeqProtein:\n    \"\"\"A RefSeqProtein object holds a RefSeq protein and information about it.\n\n    Attributes:\n        accession_number (str): RefSeq accession number.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        record (Bio.SeqRecord.SeqRecord): SeqRecord of the ncbi protein db. Can be obtained by the get_record() method.\n        taxid (str): Taxid of the protein. Can be obtained with get_assemblies() method.\n        kingdom_taxid (str): Kingdom taxid of a protein. Can be obtained with get_assemblies() method.\n        organism (str): Organism name of a protein. Can be obtained with get_assemblies() method.\n        name (str): Protein's product name from the ncbi (if available).\n        assemblies_coordinates (list): List of dictionaries with information about assemblies' coordinates of\n            the protein obtained from ipg ncbi database.\n        loci (dict): Dict with keys as locus_ids and values as Locus class' objects.\n\n    \"\"\"\n\n    def __init__(self, accession_number: str, parameters: uorf4u.manager.Parameters):\n        \"\"\"Create a RefSeqProtein object.\n\n        Arguments:\n            accession_number (str): RefSeq accession number.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.accession_number = accession_number\n        self.name = \"NA\"\n        self.parameters = parameters\n        self.record = None\n        self.taxid = None\n        self.kingdom_taxid = None\n        self.organism = None\n        self.assemblies_coordinates = None\n        self.loci = None\n        self.isrefseq = True\n\n    def add_record(self, record: Bio.SeqRecord.SeqRecord) -&gt; None:\n        \"\"\"For create a record attribute with your own sequence.\n\n        Arguments:\n            record (Bio.SeqRecord.SeqRecord): a SeqRecord of the protein db.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            self.record = record\n            self.isrefseq = False\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\n                \"Unable to get a SeqRecord of the protein from the ncbi protein database.\") from error\n\n    def get_record(self) -&gt; Bio.SeqRecord.SeqRecord:\n        \"\"\"Get a SeqRecord object of a protein from the ncbi protein database.\n\n        Note:\n            This method returns a record and updates the record attribute.\n\n        Returns:\n            Bio.SeqRecord.SeqRecordRecord: Record of the protein.\n\n        \"\"\"\n        try:\n            handle = Bio.Entrez.efetch(db=\"protein\", id=self.accession_number, rettype=\"fasta\", retmode=\"text\")\n            self.record = Bio.SeqIO.read(handle, \"fasta\")\n            return self.record\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\n                \"Unable to get a SeqRecord of the protein from the ncbi protein database.\") from error\n\n    def get_assemblies(self, xml_output=None) -&gt; list:\n        \"\"\"Get assemblies (loci) coordinates of a protein.\n\n        Note:\n            This method returns a list of assemblies coordinates and updates the self.assemblies_coordinates attribute.\n\n        Returns:\n            list: List of dictionaries with information about assemblies' coordinates of a protein obtained\n                from the ipg ncbi database.\n\n        \"\"\"\n        try:\n            if not xml_output:\n                handle = Bio.Entrez.efetch(db=\"protein\", rettype=\"ipg\", retmode=\"xml\", id=self.accession_number)\n                xml_output = handle.read().decode('utf-8')\n            root = xml.etree.cElementTree.fromstring(xml_output)\n            list_of_kingdom_taxid = []\n            assemblies_coordinates = []\n            for report in root.iter(\"IPGReport\"):\n                product = report.find(\"Product\")\n                if \"product_acc\" in report.attrib.keys():\n                    report_accession_number = report.attrib[\"product_acc\"]\n                elif \"accver\" in product.attrib.keys():\n                    report_accession_number = product.attrib[\"accver\"]\n                else:\n                    report_accession_number = \"\"\n                if report_accession_number == self.accession_number:  # be careful\n                    for protein in report.iter(\"Protein\"):\n                        if protein.attrib[\"source\"] == \"RefSeq\":\n                            if \"name\" in protein.attrib.keys():\n                                self.name = protein.attrib[\"name\"]\n                            self.taxid = protein.attrib[\"taxid\"]\n                            self.kingdom_taxid = protein.attrib[\"kingdom_taxid\"]\n                            self.organism = protein.attrib[\"org\"]\n                            list_of_kingdom_taxid.append(self.kingdom_taxid)\n                            for cds in protein.iter(\"CDS\"):\n                                to_add = 1\n                                if self.parameters.arguments[\"filter_refseq_sequences_by_regex\"]:\n                                    if not re.search(rf\"{self.parameters.arguments['refseq_sequences_regex']}\",\n                                                     cds.attrib[\"accver\"]):\n                                        to_add = 0\n                                if to_add == 1:\n                                    if \"assembly\" not in cds.attrib.keys():\n                                        cds.attrib[\"assembly\"] = \"NA\"\n                                    if \"strain\" not in cds.attrib.keys():\n                                        cds.attrib[\"strain\"] = \"NA\"\n                                    try:\n                                        assemblies_coordinates.append(dict(locus_id=cds.attrib[\"accver\"],\n                                                                           start=(int(cds.attrib[\"start\"]) - 1),\n                                                                           stop=int(cds.attrib[\"stop\"]),\n                                                                           strand=cds.attrib['strand'],\n                                                                           length=int(cds.attrib[\"stop\"]) - (\n                                                                                   int(cds.attrib[\"start\"]) - 1),\n                                                                           assembly=cds.attrib[\"assembly\"],\n                                                                           strain=cds.attrib[\"strain\"],\n                                                                           org=cds.attrib[\"org\"],\n                                                                           taxid=cds.attrib[\"taxid\"]))\n                                    except:\n                                        print(f\"\u2755Attention: {cds.attrib['accver']} record is not completed and\"\n                                              f\" cannot be processed\", file=sys.stderr)\n            '''\n            if len(assemblies_coordinates) == 0:\n                print(f\"\u2757Warning message:\\n\\tNo assembly was found for the protein \"\n                      f\"'{self.accession_number}'.\\n\\tThis protein record can be suppressed by the ncbi\\n\\t\"\n                      f\"or it has no sequence record that satisfies refseq_sequnces_regex config parameter.\",\n                      file=sys.stderr)\n            '''\n            self.assemblies_coordinates = assemblies_coordinates\n            return assemblies_coordinates\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to get assemblies coordinates of a protein.\") from error\n\n    '''\n    def get_loci(self, start=-float(\"inf\"), end=float(\"inf\"), strand=\"NA\") -&gt; dict:\n        \"\"\"Get Locus class objects for each sequence from the ncbi nt database on which the protein is annotated.\n\n        Returns:\n            dict: Dict with keys as locus_ids and values as Locus class' objects.\n\n        \"\"\"\n        self.loci = dict()\n        for assembly in self.assemblies_coordinates:\n            locus_id = assembly[\"locus_id\"]\n            self.loci[locus_id] = Locus(locus_id, start_b=start, end_b=end, strand=strand)\n        return self.loci\n    '''\n\n    def local_blastp_searching_for_homologues(self, db) -&gt; list:\n        \"\"\"Search for a protein's homologues with blastp against the local database.\n\n        Note:\n            This function does not create a new object's attribute; It only returns a list of accession numbers.\n\n        Returns:\n            list: List of proteins' accession numbers obtained with blastp searching. This list also contains the query\n                protein's accession number.\n\n        \"\"\"\n        if not os.path.exists(self.parameters.arguments[\"blastp\"]):\n            raise uorf4u.manager.uORF4uError(\"You have to specify a path to your local blastp with --blastp_path \"\n                                             \"parameter before using local blastp database.\")\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83d\udc40 Searching for homologues of {self.accession_number} with blastp against your local\"\n                      f\" database...\", file=sys.stdout)\n\n            hits_an_list = [self.record.id]\n\n            temp_input = tempfile.NamedTemporaryFile()\n            Bio.SeqIO.write(self.record, temp_input.name, \"fasta\")\n            temp_output = tempfile.NamedTemporaryFile()\n            subprocess.run([self.parameters.arguments[\"blastp\"], \"-num_threads\", \"7\", \"-outfmt\", \"6\", \"-query\",\n                            temp_input.name, \"-db\", db,\n                            \"-evalue\", str(self.parameters.arguments[\"blastp_evalue_cutoff\"]),\n                            \"-max_target_seqs\", str(self.parameters.arguments[\"blastp_hit_list_size\"]),\n                            \"-out\", temp_output.name])\n            temp_input.close()\n            blastp_out = pandas.read_table(temp_output.name, sep=\"\\t\",\n                                           names=[\"qseqid\", \"sseqid\", \"pident\", \"length\", \"mismatch\", \"gapopen\",\n                                                  \"qstart\", \"qend\", \"sstart\", \"send\", \"evalue\", \"bitscore\"])\n            temp_output.close()\n            blastp_out = blastp_out[\n                blastp_out[\"pident\"] &gt;= self.parameters.arguments[\"blastp_pident_to_query_length_cutoff\"] * 100]\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            output_filename = os.path.join(self.parameters.arguments[\"output_dir\"], \"found_homologues.tsv\")\n            blastp_out.to_csv(output_filename, sep='\\t', index=False, na_rep='NA')\n\n            hits_an_list += blastp_out[\"sseqid\"].to_list()\n\n            return hits_an_list\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to perform searching for homologues with blastp.\") from error\n\n    def blastp_searching_for_homologues(self) -&gt; list:\n        \"\"\"Search for a protein's homologues with blastp against the 'refseq_protein' database.\n        Note:\n            This function does not create a new object's attribute; It only returns a list of accession numbers.\n        Returns:\n            list: List of proteins' accession numbers obtained with blastp searching. This list also contains the query\n                protein's accession number.\n        \"\"\"\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(\n                    f\"\ud83d\udc40 Searching for homologues of {self.accession_number} with blastp against the\"\n                    f\" {self.parameters.arguments['blastp_database']} database...\\n\"\n                    f\"\\tNote: you can choose between refseq_select (contains representative records)\\n\\t\"\n                    f\"and refseq_protein (full). To switch between them use -bdb parameter.\",\n                    file=sys.stdout)\n            if self.isrefseq:\n                request = self.accession_number\n            else:\n                request = self.record.seq\n            handle = Bio.Blast.NCBIWWW.qblast(\"blastp\", self.parameters.arguments['blastp_database'], request,\n                                              expect=self.parameters.arguments[\"blastp_evalue_cutoff\"],\n                                              hitlist_size=self.parameters.arguments[\"blastp_hit_list_size\"],\n                                              alignments=self.parameters.arguments[\"blastp_max_number_of_alignments\"])\n            xml_output = handle.read()\n            hits_an_list = [self.accession_number]\n            blastp_stat_dict = dict()\n            blastp_stat_dict[self.accession_number] = dict(pident_to_query_length=\"the query\",\n                                                           pident_to_sequence_length=\"the query\",\n                                                           pident_to_alignment_length=\"the query\", evalue=\"the query\")\n            root = xml.etree.ElementTree.fromstring(xml_output)\n            query_length = int(root.find(\"BlastOutput_query-len\").text)\n            for hit in root.iter(\"Hit\"):\n                an_pattern = re.compile(r\"[ANYXW]P_\\d+\\.\\d\")\n                hit_id_l = an_pattern.findall(hit.find(\"Hit_id\").text)\n                hit_id = hit_id_l[0]\n                if hit_id != self.accession_number:\n                    hit_description = hit.find(\"Hit_def\").text\n                    subject_length = int(hit.find(\"Hit_len\").text)\n                    hsp_identity_sum, hsp_positive_sum, hsp_align_length = 0, 0, 0\n                    evalue = []\n                    for hsp in hit.iter(\"Hsp\"):\n                        hsp_identity_sum += int(hsp.find(\"Hsp_identity\").text)\n                        hsp_positive_sum += int(hsp.find(\"Hsp_positive\").text)\n                        hsp_align_length += int(hsp.find(\"Hsp_align-len\").text)\n                        evalue.append(hsp.find(\"Hsp_evalue\").text)\n                    pident_to_query_length = hsp_identity_sum / query_length\n                    pident_to_seq_length = hsp_identity_sum / subject_length\n                    pident_to_alignment_length = hsp_identity_sum / hsp_align_length\n                    if pident_to_query_length &gt;= self.parameters.arguments[\"blastp_pident_to_query_length_cutoff\"]:\n                        blastp_stat_dict[hit_id] = dict(pident_to_query_length=str(round(pident_to_query_length, 4)),\n                                                        pident_to_sequence_length=str(round(pident_to_seq_length, 4)),\n                                                        pident_to_alignment_length=str(\n                                                            round(pident_to_alignment_length, 4)),\n                                                        evalue=\",\".join(evalue))\n                        if hit_id not in hits_an_list:\n                            hits_an_list.append(hit_id)\n            columns = \"\\t\".join([\"accession_number\", \"name\", \"pident_to_query_length\", \"pident_to_sequence_length\",\n                                 \"pident_to_alignment_length\", \"e-value\"])\n            table = [columns]\n            hits_records_list = [RefSeqProtein(i, self.parameters) for i in hits_an_list]\n            for i in range(0, len(hits_records_list), 200):\n                records_subset = hits_records_list[i:i + 200]\n                accession_numbers = [record.accession_number for record in records_subset]\n                handle_fasta = Bio.Entrez.efetch(db=\"protein\", id=accession_numbers, rettype=\"fasta\", retmode=\"text\")\n                fasta_records = Bio.SeqIO.parse(handle_fasta, \"fasta\")\n                for f_record in fasta_records:\n                    record_index = accession_numbers.index(f_record.id)\n                    records_subset[record_index].name = f_record.description.replace(f_record.id, \"\").strip()\n            for rec in hits_records_list:\n                table.append(\"\\t\".join([rec.accession_number, rec.name,\n                                        blastp_stat_dict[rec.accession_number][\"pident_to_query_length\"],\n                                        blastp_stat_dict[rec.accession_number][\"pident_to_sequence_length\"],\n                                        blastp_stat_dict[rec.accession_number][\"pident_to_alignment_length\"],\n                                        blastp_stat_dict[rec.accession_number][\"evalue\"]]))\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            output_filename = os.path.join(self.parameters.arguments[\"output_dir\"], \"found_homologues.tsv\")\n            f = open(output_filename, \"w\")\n            f.write(\"\\n\".join(table))\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\u2705 {len(hits_records_list) - 1} homologues were found.\\n\"\n                      f\"\ud83d\udc8c Summary table was saved to: {os.path.basename(output_filename)}\", file=sys.stdout)\n            return hits_an_list\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to perform searching for homologues with blastp.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.RefSeqProtein.__init__","title":"<code>__init__(accession_number, parameters)</code>","text":"<p>Create a RefSeqProtein object.</p> <p>Parameters:</p> <ul> <li> <code>accession_number</code>             (<code>str</code>)         \u2013          <p>RefSeq accession number.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def __init__(self, accession_number: str, parameters: uorf4u.manager.Parameters):\n    \"\"\"Create a RefSeqProtein object.\n\n    Arguments:\n        accession_number (str): RefSeq accession number.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.accession_number = accession_number\n    self.name = \"NA\"\n    self.parameters = parameters\n    self.record = None\n    self.taxid = None\n    self.kingdom_taxid = None\n    self.organism = None\n    self.assemblies_coordinates = None\n    self.loci = None\n    self.isrefseq = True\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.RefSeqProtein.add_record","title":"<code>add_record(record)</code>","text":"<p>For create a record attribute with your own sequence.</p> <p>Parameters:</p> <ul> <li> <code>record</code>             (<code>SeqRecord</code>)         \u2013          <p>a SeqRecord of the protein db.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def add_record(self, record: Bio.SeqRecord.SeqRecord) -&gt; None:\n    \"\"\"For create a record attribute with your own sequence.\n\n    Arguments:\n        record (Bio.SeqRecord.SeqRecord): a SeqRecord of the protein db.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        self.record = record\n        self.isrefseq = False\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\n            \"Unable to get a SeqRecord of the protein from the ncbi protein database.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.RefSeqProtein.blastp_searching_for_homologues","title":"<code>blastp_searching_for_homologues()</code>","text":"<p>Search for a protein's homologues with blastp against the 'refseq_protein' database. Note:     This function does not create a new object's attribute; It only returns a list of accession numbers. Returns:     list: List of proteins' accession numbers obtained with blastp searching. This list also contains the query         protein's accession number.</p> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def blastp_searching_for_homologues(self) -&gt; list:\n    \"\"\"Search for a protein's homologues with blastp against the 'refseq_protein' database.\n    Note:\n        This function does not create a new object's attribute; It only returns a list of accession numbers.\n    Returns:\n        list: List of proteins' accession numbers obtained with blastp searching. This list also contains the query\n            protein's accession number.\n    \"\"\"\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(\n                f\"\ud83d\udc40 Searching for homologues of {self.accession_number} with blastp against the\"\n                f\" {self.parameters.arguments['blastp_database']} database...\\n\"\n                f\"\\tNote: you can choose between refseq_select (contains representative records)\\n\\t\"\n                f\"and refseq_protein (full). To switch between them use -bdb parameter.\",\n                file=sys.stdout)\n        if self.isrefseq:\n            request = self.accession_number\n        else:\n            request = self.record.seq\n        handle = Bio.Blast.NCBIWWW.qblast(\"blastp\", self.parameters.arguments['blastp_database'], request,\n                                          expect=self.parameters.arguments[\"blastp_evalue_cutoff\"],\n                                          hitlist_size=self.parameters.arguments[\"blastp_hit_list_size\"],\n                                          alignments=self.parameters.arguments[\"blastp_max_number_of_alignments\"])\n        xml_output = handle.read()\n        hits_an_list = [self.accession_number]\n        blastp_stat_dict = dict()\n        blastp_stat_dict[self.accession_number] = dict(pident_to_query_length=\"the query\",\n                                                       pident_to_sequence_length=\"the query\",\n                                                       pident_to_alignment_length=\"the query\", evalue=\"the query\")\n        root = xml.etree.ElementTree.fromstring(xml_output)\n        query_length = int(root.find(\"BlastOutput_query-len\").text)\n        for hit in root.iter(\"Hit\"):\n            an_pattern = re.compile(r\"[ANYXW]P_\\d+\\.\\d\")\n            hit_id_l = an_pattern.findall(hit.find(\"Hit_id\").text)\n            hit_id = hit_id_l[0]\n            if hit_id != self.accession_number:\n                hit_description = hit.find(\"Hit_def\").text\n                subject_length = int(hit.find(\"Hit_len\").text)\n                hsp_identity_sum, hsp_positive_sum, hsp_align_length = 0, 0, 0\n                evalue = []\n                for hsp in hit.iter(\"Hsp\"):\n                    hsp_identity_sum += int(hsp.find(\"Hsp_identity\").text)\n                    hsp_positive_sum += int(hsp.find(\"Hsp_positive\").text)\n                    hsp_align_length += int(hsp.find(\"Hsp_align-len\").text)\n                    evalue.append(hsp.find(\"Hsp_evalue\").text)\n                pident_to_query_length = hsp_identity_sum / query_length\n                pident_to_seq_length = hsp_identity_sum / subject_length\n                pident_to_alignment_length = hsp_identity_sum / hsp_align_length\n                if pident_to_query_length &gt;= self.parameters.arguments[\"blastp_pident_to_query_length_cutoff\"]:\n                    blastp_stat_dict[hit_id] = dict(pident_to_query_length=str(round(pident_to_query_length, 4)),\n                                                    pident_to_sequence_length=str(round(pident_to_seq_length, 4)),\n                                                    pident_to_alignment_length=str(\n                                                        round(pident_to_alignment_length, 4)),\n                                                    evalue=\",\".join(evalue))\n                    if hit_id not in hits_an_list:\n                        hits_an_list.append(hit_id)\n        columns = \"\\t\".join([\"accession_number\", \"name\", \"pident_to_query_length\", \"pident_to_sequence_length\",\n                             \"pident_to_alignment_length\", \"e-value\"])\n        table = [columns]\n        hits_records_list = [RefSeqProtein(i, self.parameters) for i in hits_an_list]\n        for i in range(0, len(hits_records_list), 200):\n            records_subset = hits_records_list[i:i + 200]\n            accession_numbers = [record.accession_number for record in records_subset]\n            handle_fasta = Bio.Entrez.efetch(db=\"protein\", id=accession_numbers, rettype=\"fasta\", retmode=\"text\")\n            fasta_records = Bio.SeqIO.parse(handle_fasta, \"fasta\")\n            for f_record in fasta_records:\n                record_index = accession_numbers.index(f_record.id)\n                records_subset[record_index].name = f_record.description.replace(f_record.id, \"\").strip()\n        for rec in hits_records_list:\n            table.append(\"\\t\".join([rec.accession_number, rec.name,\n                                    blastp_stat_dict[rec.accession_number][\"pident_to_query_length\"],\n                                    blastp_stat_dict[rec.accession_number][\"pident_to_sequence_length\"],\n                                    blastp_stat_dict[rec.accession_number][\"pident_to_alignment_length\"],\n                                    blastp_stat_dict[rec.accession_number][\"evalue\"]]))\n        if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n            os.mkdir(self.parameters.arguments[\"output_dir\"])\n        output_filename = os.path.join(self.parameters.arguments[\"output_dir\"], \"found_homologues.tsv\")\n        f = open(output_filename, \"w\")\n        f.write(\"\\n\".join(table))\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\u2705 {len(hits_records_list) - 1} homologues were found.\\n\"\n                  f\"\ud83d\udc8c Summary table was saved to: {os.path.basename(output_filename)}\", file=sys.stdout)\n        return hits_an_list\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to perform searching for homologues with blastp.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.RefSeqProtein.get_assemblies","title":"<code>get_assemblies(xml_output=None)</code>","text":"<p>Get assemblies (loci) coordinates of a protein.</p> Note <p>This method returns a list of assemblies coordinates and updates the self.assemblies_coordinates attribute.</p> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>List of dictionaries with information about assemblies' coordinates of a protein obtained from the ipg ncbi database.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def get_assemblies(self, xml_output=None) -&gt; list:\n    \"\"\"Get assemblies (loci) coordinates of a protein.\n\n    Note:\n        This method returns a list of assemblies coordinates and updates the self.assemblies_coordinates attribute.\n\n    Returns:\n        list: List of dictionaries with information about assemblies' coordinates of a protein obtained\n            from the ipg ncbi database.\n\n    \"\"\"\n    try:\n        if not xml_output:\n            handle = Bio.Entrez.efetch(db=\"protein\", rettype=\"ipg\", retmode=\"xml\", id=self.accession_number)\n            xml_output = handle.read().decode('utf-8')\n        root = xml.etree.cElementTree.fromstring(xml_output)\n        list_of_kingdom_taxid = []\n        assemblies_coordinates = []\n        for report in root.iter(\"IPGReport\"):\n            product = report.find(\"Product\")\n            if \"product_acc\" in report.attrib.keys():\n                report_accession_number = report.attrib[\"product_acc\"]\n            elif \"accver\" in product.attrib.keys():\n                report_accession_number = product.attrib[\"accver\"]\n            else:\n                report_accession_number = \"\"\n            if report_accession_number == self.accession_number:  # be careful\n                for protein in report.iter(\"Protein\"):\n                    if protein.attrib[\"source\"] == \"RefSeq\":\n                        if \"name\" in protein.attrib.keys():\n                            self.name = protein.attrib[\"name\"]\n                        self.taxid = protein.attrib[\"taxid\"]\n                        self.kingdom_taxid = protein.attrib[\"kingdom_taxid\"]\n                        self.organism = protein.attrib[\"org\"]\n                        list_of_kingdom_taxid.append(self.kingdom_taxid)\n                        for cds in protein.iter(\"CDS\"):\n                            to_add = 1\n                            if self.parameters.arguments[\"filter_refseq_sequences_by_regex\"]:\n                                if not re.search(rf\"{self.parameters.arguments['refseq_sequences_regex']}\",\n                                                 cds.attrib[\"accver\"]):\n                                    to_add = 0\n                            if to_add == 1:\n                                if \"assembly\" not in cds.attrib.keys():\n                                    cds.attrib[\"assembly\"] = \"NA\"\n                                if \"strain\" not in cds.attrib.keys():\n                                    cds.attrib[\"strain\"] = \"NA\"\n                                try:\n                                    assemblies_coordinates.append(dict(locus_id=cds.attrib[\"accver\"],\n                                                                       start=(int(cds.attrib[\"start\"]) - 1),\n                                                                       stop=int(cds.attrib[\"stop\"]),\n                                                                       strand=cds.attrib['strand'],\n                                                                       length=int(cds.attrib[\"stop\"]) - (\n                                                                               int(cds.attrib[\"start\"]) - 1),\n                                                                       assembly=cds.attrib[\"assembly\"],\n                                                                       strain=cds.attrib[\"strain\"],\n                                                                       org=cds.attrib[\"org\"],\n                                                                       taxid=cds.attrib[\"taxid\"]))\n                                except:\n                                    print(f\"\u2755Attention: {cds.attrib['accver']} record is not completed and\"\n                                          f\" cannot be processed\", file=sys.stderr)\n        '''\n        if len(assemblies_coordinates) == 0:\n            print(f\"\u2757Warning message:\\n\\tNo assembly was found for the protein \"\n                  f\"'{self.accession_number}'.\\n\\tThis protein record can be suppressed by the ncbi\\n\\t\"\n                  f\"or it has no sequence record that satisfies refseq_sequnces_regex config parameter.\",\n                  file=sys.stderr)\n        '''\n        self.assemblies_coordinates = assemblies_coordinates\n        return assemblies_coordinates\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to get assemblies coordinates of a protein.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.RefSeqProtein.get_record","title":"<code>get_record()</code>","text":"<p>Get a SeqRecord object of a protein from the ncbi protein database.</p> Note <p>This method returns a record and updates the record attribute.</p> <p>Returns:</p> <ul> <li> <code>SeqRecord</code>         \u2013          <p>Bio.SeqRecord.SeqRecordRecord: Record of the protein.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def get_record(self) -&gt; Bio.SeqRecord.SeqRecord:\n    \"\"\"Get a SeqRecord object of a protein from the ncbi protein database.\n\n    Note:\n        This method returns a record and updates the record attribute.\n\n    Returns:\n        Bio.SeqRecord.SeqRecordRecord: Record of the protein.\n\n    \"\"\"\n    try:\n        handle = Bio.Entrez.efetch(db=\"protein\", id=self.accession_number, rettype=\"fasta\", retmode=\"text\")\n        self.record = Bio.SeqIO.read(handle, \"fasta\")\n        return self.record\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\n            \"Unable to get a SeqRecord of the protein from the ncbi protein database.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.RefSeqProtein.local_blastp_searching_for_homologues","title":"<code>local_blastp_searching_for_homologues(db)</code>","text":"<p>Search for a protein's homologues with blastp against the local database.</p> Note <p>This function does not create a new object's attribute; It only returns a list of accession numbers.</p> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>List of proteins' accession numbers obtained with blastp searching. This list also contains the query protein's accession number.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def local_blastp_searching_for_homologues(self, db) -&gt; list:\n    \"\"\"Search for a protein's homologues with blastp against the local database.\n\n    Note:\n        This function does not create a new object's attribute; It only returns a list of accession numbers.\n\n    Returns:\n        list: List of proteins' accession numbers obtained with blastp searching. This list also contains the query\n            protein's accession number.\n\n    \"\"\"\n    if not os.path.exists(self.parameters.arguments[\"blastp\"]):\n        raise uorf4u.manager.uORF4uError(\"You have to specify a path to your local blastp with --blastp_path \"\n                                         \"parameter before using local blastp database.\")\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83d\udc40 Searching for homologues of {self.accession_number} with blastp against your local\"\n                  f\" database...\", file=sys.stdout)\n\n        hits_an_list = [self.record.id]\n\n        temp_input = tempfile.NamedTemporaryFile()\n        Bio.SeqIO.write(self.record, temp_input.name, \"fasta\")\n        temp_output = tempfile.NamedTemporaryFile()\n        subprocess.run([self.parameters.arguments[\"blastp\"], \"-num_threads\", \"7\", \"-outfmt\", \"6\", \"-query\",\n                        temp_input.name, \"-db\", db,\n                        \"-evalue\", str(self.parameters.arguments[\"blastp_evalue_cutoff\"]),\n                        \"-max_target_seqs\", str(self.parameters.arguments[\"blastp_hit_list_size\"]),\n                        \"-out\", temp_output.name])\n        temp_input.close()\n        blastp_out = pandas.read_table(temp_output.name, sep=\"\\t\",\n                                       names=[\"qseqid\", \"sseqid\", \"pident\", \"length\", \"mismatch\", \"gapopen\",\n                                              \"qstart\", \"qend\", \"sstart\", \"send\", \"evalue\", \"bitscore\"])\n        temp_output.close()\n        blastp_out = blastp_out[\n            blastp_out[\"pident\"] &gt;= self.parameters.arguments[\"blastp_pident_to_query_length_cutoff\"] * 100]\n        if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n            os.mkdir(self.parameters.arguments[\"output_dir\"])\n        output_filename = os.path.join(self.parameters.arguments[\"output_dir\"], \"found_homologues.tsv\")\n        blastp_out.to_csv(output_filename, sep='\\t', index=False, na_rep='NA')\n\n        hits_an_list += blastp_out[\"sseqid\"].to_list()\n\n        return hits_an_list\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to perform searching for homologues with blastp.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences","title":"<code>UpstreamSequences</code>","text":"<p>An UpstreamSequences object holds list of upstream sequences records and information about them.</p> <p>Attributes:</p> <ul> <li> <code>records</code>             (<code>list</code>)         \u2013          <p>List of Bio.SeqRecord.SeqRecord objects with upstream sequences. (attribute 'annotations' (dict) is used for holding additional information, (e.g. downstream protein_id)).</p> </li> <li> <code>codon_table</code>             (<code>CodonTable</code>)         \u2013          <p>Codon table (genetic code).</p> </li> <li> <code>conserved_paths</code>             (<code>list</code>)         \u2013          <p>list  of Path's objects (Path class holds list of ORFs from different upstream sequences and information about them).</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>class UpstreamSequences:\n    \"\"\"An UpstreamSequences object holds list of upstream sequences records and information about them.\n\n    Attributes:\n        records (list): List of Bio.SeqRecord.SeqRecord objects with upstream sequences.\n            (attribute 'annotations' (dict) is used for holding additional information, (e.g. downstream protein_id)).\n        codon_table (Bio.Data.CodonTable.CodonTable): Codon table (genetic code).\n        conserved_paths (list): list  of Path's objects (Path class holds list of ORFs from different upstream\n            sequences and information about them).\n\n    \"\"\"\n\n    def __init__(self, records: list, parameters: uorf4u.manager.Parameters):\n        \"\"\"Create an UpstreamSequences object.\n\n        Arguments:\n            records (list): List of Bio.SeqRecord.SeqRecord objects with upstream sequences.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.records = records\n        self.parameters = parameters\n        self.codon_table = Bio.Data.CodonTable.unambiguous_dna_by_name[\n            parameters.arguments[\"ncbi_genetic_code_name\"]]\n        self.conserved_paths = None\n\n    def save_upstream_sequences(self) -&gt; None:\n        \"\"\"Save upstream sequences as a fasta file.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            output_file = os.path.join(self.parameters.arguments[\"output_dir\"], \"upstream_sequences.fa\")\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            Bio.SeqIO.write(self.records, output_file, \"fasta\")\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83d\udc8c Fasta file with upstream sequences was saved to {os.path.basename(output_file)}.\",\n                      file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to save a fasta file with upstream sequences.\") from error\n\n    def annotate_orfs(self) -&gt; None:\n        \"\"\"Annotate ORFs in upstream sequences.\n\n        Note:\n            This function updates 'records' attribute.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83d\udd0e Annotating ORFs in the upstream sequences...\", file=sys.stdout)\n            if self.parameters.arguments[\"alternative_start_codons\"]:\n                start_codons_list = self.codon_table.start_codons\n            else:\n                start_codons_list = [self.parameters.arguments[\"main_start_codon\"]]\n\n            if self.parameters.arguments[\"check_assembly_annotation\"] and \\\n                    self.records[0].annotations[\"RefSeq\"]:\n                if self.parameters.arguments[\"verbose\"]:\n                    print(f\"\ud83d\udce1 Retrieving assemblies' annotation...\", file=sys.stdout)\n                for i in range(0, len(self.records), 100):\n                    useq_subset = [record for record in self.records[i:i + 100] if record.annotations[\"RefSeq\"]]\n                    locus_ids = [locus.annotations[\"locus_id\"] for locus in useq_subset]\n                    handle = Bio.Entrez.efetch(db=\"nucleotide\", id=locus_ids, rettype=\"gb\", retmode=\"xml\")\n                    handle_txt = handle.read().decode('utf-8')\n                    for useq_record in useq_subset:\n                        useq_record.annotations[\"locus_annotation\"] = Locus(useq_record.annotations[\"locus_id\"],\n                                                                            start_b=useq_record.annotations[\"start\"],\n                                                                            stop_b=useq_record.annotations[\"stop\"],\n                                                                            target_strand=useq_record.annotations[\n                                                                                \"strand\"],\n                                                                            locus_record=useq_record.annotations[\n                                                                                \"locus_record\"],\n                                                                            xml_output=handle_txt)\n            for useq_index in range(len(self.records)):\n                useq_record = self.records[useq_index]\n                useq_record.annotations[\"ORFs\"] = []\n                for first_position in range((useq_record.annotations[\"length\"] - self.parameters.arguments[\n                    \"downstream_region_length\"]) + 1):\n                    first_codon = useq_record.seq[first_position:first_position + 3]\n                    if first_codon.upper() in start_codons_list:\n                        start_codon_position = first_position\n                        for second_position in range(start_codon_position + 3,\n                                                     (useq_record.annotations[\"length\"] - 3) + 1, 3):\n                            second_codon = useq_record.seq[second_position:second_position + 3]\n                            if second_codon.upper() in self.codon_table.stop_codons:\n                                stop_codon_position = second_position\n                                orf_length = stop_codon_position - start_codon_position\n                                distance = (useq_record.annotations[\"length\"] - self.parameters.arguments[\n                                    \"downstream_region_length\"]) - stop_codon_position\n                                distance_sc = (useq_record.annotations[\"length\"] - self.parameters.arguments[\n                                    \"downstream_region_length\"]) - start_codon_position\n\n                                if useq_record.annotations[\"RefSeq\"]:\n                                    orf_id = f\"{useq_record.annotations['locus_id']},\" \\\n                                             f\"{useq_record.annotations['accession_number']},\" \\\n                                             f\"{distance_sc}\"\n                                    orf_name = f\"{useq_record.annotations['label']},{distance_sc}\"\n                                    contig_id = useq_record.annotations['locus_id']\n                                else:\n                                    distance_sc = useq_record.annotations[\"length\"] - start_codon_position\n                                    orf_id = f\"{useq_record.id},{distance_sc}\"\n                                    if useq_record.description:\n                                        orf_name = f\"{useq_record.description}_{orf_id}\"\n                                    else:\n                                        orf_name = orf_id\n                                    contig_id = useq_record.description\n                                if useq_record.annotations[\"strand\"] == \"+\":\n                                    contig_start = start_codon_position + useq_record.annotations[\"start\"]\n                                    contig_stop = contig_start + orf_length\n                                elif useq_record.annotations[\"strand\"] == \"-\":\n                                    contig_stop = useq_record.annotations[\"stop\"] - start_codon_position\n                                    contig_start = contig_stop - orf_length\n                                contig_coordinates = f\"{contig_id}:{contig_start}:{contig_stop}\" \\\n                                                     f\"({useq_record.annotations['strand']})\"\n                                sd_window_start = max(\n                                    [0, (start_codon_position - self.parameters.arguments[\"sd_window_length\"])])\n                                current_orf = ORF(parameters=self.parameters, id=orf_id, name=orf_name,\n                                                  distance=distance, start=start_codon_position,\n                                                  contig_coordinates=contig_coordinates,\n                                                  stop=stop_codon_position, useq_index=useq_index,\n                                                  nt_sequence=useq_record.seq[start_codon_position:stop_codon_position],\n                                                  sd_window_seq=useq_record.seq[sd_window_start:start_codon_position])\n                                if current_orf.length &gt;= self.parameters.arguments[\n                                    \"min_orf_length\"] and distance_sc != 0:\n                                    useq_record.annotations[\"ORFs\"].append(current_orf)\n                                    if self.parameters.arguments[\"check_assembly_annotation\"] and \\\n                                            useq_record.annotations[\"RefSeq\"]:\n                                        for cds in useq_record.annotations[\"locus_annotation\"].CDSs:\n                                            if current_orf.stop == cds[\"relative_stop\"] and (\n                                                    (current_orf.start - cds[\"relative_start\"]) % 3 == 0):\n                                                the_same_stop = 1\n                                                current_orf.annotation = cds[\"product_name\"]\n                                                if current_orf.start != cds[\"relative_start\"]:\n                                                    if current_orf.start &lt; cds[\"relative_start\"]:\n                                                        current_orf.annotation += \" (extension)\"\n                                                    else:\n                                                        current_orf.annotation += \" (truncation)\"\n                                    for annotated_orfs in useq_record.annotations[\"ORFs\"]:\n                                        if current_orf.stop == annotated_orfs.stop and \\\n                                                current_orf.id != annotated_orfs.id:\n                                            current_orf.extended_orfs.append(annotated_orfs.id)\n                                break\n            number_of_orfs = sum(len(i.annotations[\"ORFs\"]) for i in self.records)\n            if self.parameters.arguments[\"fast_searching\"] == \"auto\":\n                if len(self.records) &lt; 5:\n                    self.parameters.arguments[\"fast_searching\"] = False\n                elif (len(self.records) &gt;= 100 or number_of_orfs &gt; 1000):\n                    self.parameters.arguments[\"fast_searching\"] = True\n                else:\n                    self.parameters.arguments[\"fast_searching\"] = False\n            if self.parameters.arguments[\"fast_searching\"]:\n                if number_of_orfs &gt; 1000:\n                    self.parameters.arguments[\"fast_searching_skip\"] = True\n                else:\n                    self.parameters.arguments[\"fast_searching_skip\"] = False\n            if number_of_orfs == 0:\n                print(f\"\u26d4Termination:\\n\\tNo ORF was annotated in upstream sequences.\"\n                      f\"\\n\\tThis run will be terminated.\", file=sys.stderr)\n                if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                    os.mkdir(self.parameters.arguments[\"output_dir\"])\n                with open(os.path.join(self.parameters.arguments[\"output_dir\"], \"report.txt\"), \"w\") as report_f:\n                    report_f.write(\"Termination:\\nNo ORF was annotated in upstream sequences.\")\n                sys.exit()\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\u2705 {number_of_orfs} ORFs were annotated.\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to annotate ORFs in upstream sequences.\") from error\n\n    def filter_orfs_by_sd_annotation(self) -&gt; None:\n        \"\"\"Filter annotated ORFs by presence the Shine-Dalgarno sequence.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            for useq_record in self.records:\n                orf_list = useq_record.annotations[\"ORFs\"]\n                filtered_orf_list = []\n                for orf in orf_list:\n                    orf.calculate_energies()\n                    if orf.min_energy &lt; self.parameters.arguments[\"sd_energy_cutoff\"]:\n                        filtered_orf_list.append(orf)\n                useq_record.annotations[\"ORFs\"] = filtered_orf_list\n\n            number_of_orfs = sum(len(i.annotations[\"ORFs\"]) for i in self.records)\n            if number_of_orfs == 0:\n                print(f\"\u26d4Termination:\\n\\tNo ORF left after filtering by SD annotation.\"\n                      f\"\\n\\tThis run will be terminated.\", file=sys.stderr)\n                if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                    os.mkdir(self.parameters.arguments[\"output_dir\"])\n                with open(os.path.join(self.parameters.arguments[\"output_dir\"], \"report.txt\"), \"w\") as report_f:\n                    report_f.write(\"Termination:\\nNo ORF left after filtering by SD annotation.\")\n                sys.exit()\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83e\uddf9 {number_of_orfs} ORFs remained in the analysis after filtering by presence \"\n                      f\"of the SD sequence.\\n\\tYou can deactivate filtering by -nsd parameter \"\n                      f\"or by changing the config file.\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to filter uORFs by SD sequence presence.\") from error\n\n    def save_annotated_orfs(self) -&gt; None:\n        \"\"\"Save information about annotated ORFs as a set of tsv files.\n\n        Note:\n            tsv files will be saved to the subdir called 'annotated_ORFs' located in 'output_dir'.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n\n            colnames_list = [\"id\", \"name\", \"length\", \"distance_to_the_mORF\", \"contig_coordinates\", \"nt_sequence\",\n                             \"aa_sequence\"]\n            if self.parameters.arguments[\"filter_by_sd\"]:\n                colnames_list += [\"sd_sequence_window\", \"SD-aSD energy\", \"SD-aSD energies list\"]\n            colnames_list += [\"extended_orfs\", \"annotation\"]\n            colnames = \"\\t\".join(colnames_list)\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            output_dir_path = os.path.join(self.parameters.arguments[\"output_dir\"], \"annotated_ORFs\")\n            if not os.path.exists(output_dir_path):\n                os.mkdir(output_dir_path)\n            for useq_record in self.records:\n                file_name = f\"{useq_record.description},{useq_record.id}\".replace(' ', '_').replace('/', '_')\n                lines = [colnames]\n                for orf in useq_record.annotations[\"ORFs\"]:\n                    if not orf.extended_orfs:\n                        extented_orfs_value = \"NA\"\n                    else:\n                        extented_orfs_value = ';'.join(orf.extended_orfs)\n                    line = [orf.id, orf.name, str(orf.length), str(orf.distance), orf.contig_coordinates,\n                            str(orf.nt_sequence), str(orf.aa_sequence)]\n                    if self.parameters.arguments[\"filter_by_sd\"]:\n                        line += [str(orf.sd_window_seq_str), str(orf.min_energy), \";\".join(orf.sd_window_energies)]\n                    line += [extented_orfs_value, orf.annotation]\n                    lines.append(\"\\t\".join(line))\n                with open(os.path.join(output_dir_path, f\"{file_name}.tsv\"), \"w\") as output:\n                    output.write(\"\\n\".join(lines))\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83d\udc8c tsv files with information about annotated ORFs were saved to \"\n                      f\"{os.path.basename(output_dir_path)} folder.\",\n                      file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to save annotated uORFs.\") from error\n\n    def conserved_orf_searching(self) -&gt; None:\n        \"\"\"Search for sets of conserved ORFs in upstream sequences.\n\n        Note:\n            This method updates the self.conserved_paths attribute.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83d\udd0e Searching for conserved ORFs in upstream sequences...\",\n                      file=sys.stdout)\n            if len(self.records) == 1:\n                raise uorf4u.manager.uORF4uError(\"At least two sequences required to perform conservation analysis\")\n            lengths = []\n            for record in self.records:\n                for orf in record.annotations[\"ORFs\"]:\n                    lengths.append(orf.length)\n            lengths = sorted(list(set(lengths)))\n            global_aligner = Bio.Align.PairwiseAligner()\n            global_aligner.mode = \"global\"\n            global_aligner.match_score = self.parameters.arguments[\"global_match_score\"]\n            global_aligner.mismatch_score = self.parameters.arguments[\"global_mismatch_score\"]\n            global_aligner.open_gap_score = self.parameters.arguments[\"global_open_gap_score\"]\n            global_aligner.extend_gap_score = self.parameters.arguments[\"global_extend_gap_score\"]\n            global_aligner.target_end_gap_score = self.parameters.arguments[\"global_target_end_gap_score\"]\n            global_aligner.query_end_gap_score = self.parameters.arguments[\"global_query_end_gap_score\"]\n            length_variance = self.parameters.arguments[\"orf_length_group_range\"]\n            number_of_useqs = len(self.records)\n            if self.parameters.arguments[\"fast_searching\"]:\n                filtered_orfs_dict = dict()\n                for length in lengths:\n                    if isinstance(self.parameters.arguments[\"orf_length_group_range\"], float):\n                        length_variance = length * self.parameters.arguments[\"orf_length_group_range\"]\n                    filtered_orfs = []\n                    useq_with_filtered_orfs = []\n                    for useq_index in range(number_of_useqs):\n                        useq_record = self.records[useq_index]\n                        for orf in useq_record.annotations[\"ORFs\"]:\n                            if abs(length - orf.length) &lt;= length_variance:\n                                filtered_orfs.append(orf)\n                                if useq_index not in useq_with_filtered_orfs:\n                                    useq_with_filtered_orfs.append(useq_index)\n                    if len(useq_with_filtered_orfs) / number_of_useqs &gt;= self.parameters.arguments[\n                        \"orfs_presence_cutoff\"]:\n                        to_add = 1\n                        keys_to_remove = []\n                        for added_length in filtered_orfs_dict.keys():\n                            num_of_identical_elements = len(set(filtered_orfs) &amp; set(filtered_orfs_dict[added_length]))\n                            fraction = num_of_identical_elements / min(len(filtered_orfs),\n                                                                       len(filtered_orfs_dict[added_length]))\n                            if fraction &gt; 0.95:  # to add as a config parameter\n                                if len(filtered_orfs) &gt;= len(filtered_orfs_dict[added_length]):\n                                    keys_to_remove.append(added_length)\n                                else:\n                                    to_add = 0\n                        for key_to_remove in keys_to_remove:\n                            filtered_orfs_dict.pop(key_to_remove)\n                        if to_add:\n                            filtered_orfs_dict[length] = filtered_orfs\n                lengths = list(filtered_orfs_dict.keys())\n\n            conserved_paths = []\n            for length in lengths:\n                if isinstance(self.parameters.arguments[\"orf_length_group_range\"], float):\n                    length_variance = length * self.parameters.arguments[\"orf_length_group_range\"]\n                useq_indexes_with_filtered_orfs = []\n                filtered_orfs = dict()\n                for useq_index in range(number_of_useqs):\n                    useq_record = self.records[useq_index]\n                    filtered_orfs[useq_index] = []\n                    for orf in useq_record.annotations[\"ORFs\"]:\n                        if abs(length - orf.length) &lt;= length_variance:\n                            filtered_orfs[useq_index].append(orf)\n                    orfs_ids = [i.id for i in filtered_orfs[useq_index]]\n                    for orf in filtered_orfs[useq_index]:\n                        if any(i in orf.extended_orfs for i in orfs_ids):\n                            filtered_orfs[useq_index].remove(orf)\n                    if len(filtered_orfs[useq_index]) &gt; 0:\n                        useq_indexes_with_filtered_orfs.append(useq_index)\n                if len(useq_indexes_with_filtered_orfs) / number_of_useqs &gt;= self.parameters.arguments[\n                    \"orfs_presence_cutoff\"]:\n                    if self.parameters.arguments[\"fast_searching\"]:\n                        genome_iterator = random.sample(list(filtered_orfs.keys()),\n                                                        max(1, min(round(self.parameters.arguments[\"fast_searching_\"\n                                                                                                   \"fraction_of_initial\"\n                                                                                                   \"_genomes\"] * len(\n                                                            useq_indexes_with_filtered_orfs)),\n                                                                   self.parameters.arguments[\n                                                                       \"max_num_of_initial_genome_iteration\"])))\n                    elif len(filtered_orfs.keys()) &gt; self.parameters.arguments[\"max_num_of_initial_genome_iteration\"]:\n                        genome_iterator = random.cr(list(filtered_orfs.keys()),\n                                                        self.parameters.arguments[\n                                                            \"max_num_of_initial_genome_iteration\"])\n                    else:\n                        genome_iterator = filtered_orfs.keys()\n                    for initial_useq in genome_iterator:\n                        for initial_orf in filtered_orfs[initial_useq]:\n                            already_conserved_orfs = []\n                            for already_conserved_path in conserved_paths:\n                                already_conserved_orfs += already_conserved_path.path\n                            if initial_orf not in already_conserved_orfs:\n                                conserved_path = Path(self.parameters)\n                                conserved_path.update(initial_orf)\n                                for useq in random.sample(list(filtered_orfs.keys()), len(filtered_orfs.keys())):\n                                    useq_candidates = filtered_orfs[useq]\n                                    if self.parameters.arguments[\"fast_searching\"]:\n                                        if self.parameters.arguments[\"fast_searching_skip\"]:\n                                            useq_candidates = [orf_useq for orf_useq in filtered_orfs[useq] if\n                                                               orf_useq not in already_conserved_orfs]\n                                    if useq != initial_useq and useq_candidates != []:\n                                        score_sums = []\n                                        for orf in useq_candidates:\n                                            score_sum = 0\n                                            for path_orf in conserved_path.path:\n                                                if self.parameters.arguments[\"alignment_type\"] == \"nt\":\n                                                    current_alignment = global_aligner.align(orf.nt_sequence,\n                                                                                             path_orf.nt_sequence)\n                                                elif self.parameters.arguments[\"alignment_type\"] == \"aa\":\n                                                    current_alignment = global_aligner.align(orf.aa_sequence,\n                                                                                             path_orf.aa_sequence)\n                                                score_sum += current_alignment.score\n                                            score_sums.append(score_sum)\n                                        max_score = max(score_sums)\n                                        if max_score &gt; self.parameters.arguments[\"alignment_score_cutoff\"]:\n                                            if score_sums.count(max_score) == 1:\n                                                selected_orf = useq_candidates[score_sums.index(max_score)]\n                                            else:\n                                                num_of_candidates = len(useq_candidates)\n                                                highest_score_orfs = [useq_candidates[k] for k in\n                                                                      range(num_of_candidates)\n                                                                      if score_sums[k] == max_score]\n                                                highest_score_orfs_length_dists = [orf_it.length - length for orf_it in\n                                                                                   highest_score_orfs]\n                                                min_length_dist = min(highest_score_orfs_length_dists)\n                                                if highest_score_orfs_length_dists.count(min_length_dist) == 1:\n                                                    selected_orf = highest_score_orfs[\n                                                        highest_score_orfs_length_dists.index(min_length_dist)]\n                                                else:\n                                                    num_of_candidates = len(highest_score_orfs)\n                                                    the_closest_by_length_orfs = [highest_score_orfs[k] for k in\n                                                                                  range(num_of_candidates) if\n                                                                                  highest_score_orfs_length_dists[\n                                                                                      k] == min_length_dist]\n                                                    the_closest_by_length_orfs_lengths = [orf_it.length for orf_it in\n                                                                                          the_closest_by_length_orfs]\n                                                    max_length = max(the_closest_by_length_orfs_lengths)\n                                                    selected_orf = the_closest_by_length_orfs[\n                                                        the_closest_by_length_orfs_lengths.index(max_length)]\n                                            conserved_path.update(selected_orf, max_score)\n                                if len(conserved_path) / number_of_useqs &gt;= self.parameters.arguments[\n                                    \"orfs_presence_cutoff\"] and len(conserved_path) &gt; 1:\n                                    to_save_this_path = 1\n                                    for old_path in conserved_paths:\n                                        fraction_of_identity = conserved_path.calculate_similarity(old_path)\n                                        if fraction_of_identity &gt;= self.parameters.arguments[\"paths_identity_cutoff\"]:\n                                            if conserved_path.score &gt; old_path.score:\n                                                conserved_paths.remove(old_path)\n                                            elif conserved_path.score &lt;= old_path.score:\n                                                to_save_this_path = 0\n                                    if to_save_this_path == 1:\n                                        # conserved_path.sort() # NOT SORTING!\n                                        conserved_paths.append(conserved_path)\n\n            self.conserved_paths = conserved_paths\n            number_of_paths = len(conserved_paths)\n            if number_of_paths == 0:\n                print(f\"\u26d4Termination:\\n\\tNo conserved ORFs set was found.\"\n                      f\"\\n\\tThis run will be terminated.\", file=sys.stderr)\n                if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                    os.mkdir(self.parameters.arguments[\"output_dir\"])\n                with open(os.path.join(self.parameters.arguments[\"output_dir\"], \"report.txt\"), \"w\") as report_f:\n                    report_f.write(\"Termination:\\nNo conserved ORFs set was found.\")\n                sys.exit()\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\u2705 {number_of_paths} sets of conserved ORFs were found.\",\n                      file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to perform searching for conserved uORFs.\") from error\n\n    def filter_out_similar_paths(self) -&gt; None:\n        \"\"\"Filter out duplicates in sets of annotated conserved ORFs.\n\n        Note:\n            Two paths are considered as duplicates if they share more than half of ORFs\n                (default value, see 'paths_identity_cutoff' config parameter). In case two paths are found as identical,\n                only one with a higher score will be saved.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            filtered_paths = []\n            for path in self.conserved_paths:\n                to_add = 1\n                for path_filtered in filtered_paths:\n                    if path.calculate_similarity(path_filtered) &gt; self.parameters.arguments[\"paths_identity_cutoff\"]:\n                        if path.score &lt; path_filtered.score:\n                            to_add = 0\n                        elif path.score == path_filtered.score and (len(path) &lt; len(path_filtered)):\n                            to_add = 0\n                        else:\n                            filtered_paths.remove(path_filtered)\n                if to_add == 1:\n                    filtered_paths.append(path)\n            self.conserved_paths = filtered_paths\n\n            if self.parameters.arguments[\"verbose\"]:\n                num_of_paths = len(self.conserved_paths)\n                print(f\"\ud83e\uddf9 {num_of_paths} set(s) of conserved ORFs remained in the analysis after filtering \"\n                      f\"out duplicates.\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to filter out duplicates in conserved uORFs sets.\") from error\n\n    def run_msa(self) -&gt; None:\n        \"\"\"Run msa tool (muscle) for each path object (set of conserved ORFs).\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83e\uddee Running MSA for conserved ORFs.\", file=sys.stdout)\n            for path in self.conserved_paths:\n                path.maft_msa()\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to get MSA of conserved uORFs.\") from error\n\n    def save_msa(self) -&gt; None:\n        \"\"\"Save MSA of conserved ORFs as fasta files.\n\n        Note:\n            Fasta files will be saved to the subdirs: ['nucleotide_msa' - for MSA of nucleotide sequences of ORFs,\n                'amino_acid_msa' - MSA of amino acid sequences of ORFs, and 'sd_msa' - MSA of SD sequence regions\n                of ORFS). All of them located in your 'output_dir'.\n\n        Returns:\n             None\n\n        \"\"\"\n        try:\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n            output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                                   [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                 f\"{rename_dict[i]}_msa_fasta_files\") for i in\n                                    self.parameters.arguments['sequences_to_write']]))\n            for key in output_dirs:\n                if not (os.path.exists(output_dirs[key])):\n                    os.mkdir(output_dirs[key])\n            for path in self.conserved_paths:\n                for seq_type in self.parameters.arguments[\"sequences_to_write\"]:\n                    msa = path.msa[seq_type]\n                    output = os.path.join(output_dirs[seq_type], f\"{path.id}.fa\")\n                    Bio.AlignIO.write(msa, output, \"fasta\")\n\n            if self.parameters.arguments[\"verbose\"]:\n                output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n                delimiter = \",\\n\\t\"\n                print(f\"\ud83d\udc8c MSA fasta files of conserved ORFs were saved to the folders:\\n\"\n                      f\"\\t{delimiter.join(output_dirs_v)} folders.\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to save MSA of conserved uORFs.\") from error\n\n    def save_orfs_sequences(self) -&gt; None:\n        \"\"\"Save sequences of conserved ORFs as fasta files.\n\n        Note:\n            Fasta files will be saved to the subdirs: ['nucleotide_orfs' - for MSA of nucleotide sequences of ORFs,\n                'amino_acid_msa' - MSA of amino acid sequences of ORFs, and 'sd_msa' - MSA of SD sequence regions\n                of ORFS). All of them located in your 'output_dir'.\n\n        Returns:\n             None\n\n        \"\"\"\n        try:\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\")\n            sequence_to_write = [i for i in self.parameters.arguments[\"sequences_to_write\"] if i != \"sd\"]\n            output_dirs = dict(zip(sequence_to_write, [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                                    f\"{rename_dict[i]}_orfs_fasta_files\") for i in\n                                                       sequence_to_write]))\n            for key in output_dirs:\n                if not (os.path.exists(output_dirs[key])):\n                    os.mkdir(output_dirs[key])\n            for seq_type in sequence_to_write:\n                for path in self.conserved_paths:\n                    records = []\n                    for orf in path.path:\n                        if seq_type == \"nt\":\n                            record = Bio.SeqRecord.SeqRecord(orf.nt_sequence, orf.id, \"\", orf.name)\n                        if seq_type == \"aa\":\n                            record = Bio.SeqRecord.SeqRecord(orf.aa_sequence, orf.id, \"\", orf.name)\n                        records.append(record)\n                    output = os.path.join(output_dirs[seq_type], f\"{path.id}.fa\")\n                    Bio.SeqIO.write(records, output, \"fasta\")\n            if self.parameters.arguments[\"verbose\"]:\n                delimiter = \",\\n\\t\"\n                output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n                print(f\"\ud83d\udc8c Sequences fasta files of conserved ORFs were saved to the folders: \\n\"\n                      f\"\\t{delimiter.join(output_dirs_v)}.\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to save sequences of conserved uORFs.\") from error\n\n    def save_results_summary_table(self) -&gt; None:\n        \"\"\"Save results summary table.\n\n        Note:\n            A tsv table will be saved to your output_dir.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            colnames = \"\\t\".join(\n                [\"id\", \"length\", \"average_distance_to_the_ORF\", \"aa_alignment_length\", \"nt_alignment_length\", \"score\",\n                 \"number_of_orfs\", \"number_of_orfs/number_of_sequences\", \"consensus(aa)\", \"consensus(nt)\",\n                 \"uORFs\", \"uORFs_annotations\"])\n            rows = [colnames]\n            for path in self.conserved_paths:\n                annotations = sorted(set([i.annotation for i in path.path]))\n                if len(annotations) &gt; 1 and \"NA\" in annotations:\n                    pass\n                    # annotations.remove(\"NA\") # To check then\n                row = \"\\t\".join(\n                    [path.id, str(path.length), str(statistics.mean([i.distance for i in path.path])),\n                     str(path.msa[\"aa\"].get_alignment_length()), str(path.msa[\"nt\"].get_alignment_length()),\n                     str(path.score), str(len(path)), str(round(len(path) / len(self.records), 3)),\n                     str(path.msa_consensus[\"aa\"]), str(path.msa_consensus[\"nt\"]), ', '.join([i.id for i in path.path]),\n                     ', '.join(annotations)])\n                rows.append(row)\n            output_file_path = os.path.join(self.parameters.arguments[\"output_dir\"], \"results_summary.tsv\")\n            f = open(output_file_path, \"w\")\n            f.write(\"\\n\".join(rows))\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83d\udc8c Results summary tsv table saved to: {os.path.basename(output_file_path)}.\", file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to save results summary table.\") from error\n\n    def plot_msa_figs(self) -&gt; None:\n        \"\"\"Plot MSA plots of  conserved ORFs\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83c\udfa8 Plotting MSA figures...\", file=sys.stdout)\n            for path in self.conserved_paths:\n                path.plot_msa()\n\n            if self.parameters.arguments[\"verbose\"]:\n                rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n                output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                                       [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                     f\"{rename_dict[i]}_msa_visualisation\") for i in\n                                        self.parameters.arguments['sequences_to_write']]))\n                output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n                delimiter = \",\\n\\t\"\n                print(f\"\ud83d\udc8c MSA figures were saved to the folders: \\n\\t{delimiter.join(output_dirs_v)}\",\n                      file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to plot sequence logo of conserved uORFs.\") from error\n\n    def plot_ggmsa_figs(self) -&gt; None:\n        \"\"\"Plot MSA plots of conserved ORFs saved as fasta files.\n\n        Note:\n            R script based on ggmsa package [yulab-smu.top/ggmsa] used to produce MSA plots. R script (msa_plot.R)\n                can be found in output_dir. This method uses subprocess to run this R script in the following way:\n                `Rscript {output_dir}/msa_plot.R --msa_fasta path_to_fasta --output output_path --seq_type (nt/aa)\n                --width N(mm) --height M(mm)`.\n                Since during each run of uorf4u a local copy of this script is created\n                in your output_dir, you can change it without any consequences for next uorf4u runs.\n                This method based on _plot_ggmsa_ method of Path class and simply call it for each Path object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83c\udfa8 Plotting MSA figures...\", file=sys.stdout)\n            for path in self.conserved_paths:\n                path.plot_ggmsa()\n\n            if self.parameters.arguments[\"verbose\"]:\n                rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n                output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                                       [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                     f\"{rename_dict[i]}_msa_visualisation\") for i in\n                                        self.parameters.arguments['sequences_to_write']]))\n                output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n                delimiter = \",\\n\\t\"\n                print(f\"\ud83d\udc8c MSA figures were saved to the folders:\\n\\t{delimiter.join(output_dirs_v)}.\",\n                      file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to visualise MSA of conserved uORFs.\") from error\n\n    def plot_logo_figs(self) -&gt; None:\n        \"\"\"Plot sequence Logo figures of conserved ORFs saved as fasta files.\n\n        Note:\n            This method uses logomaker package to produce images.\n\n            This method based on _plot_logo_ method of Path class and simply call it for each Path object.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83c\udfa8 Plotting sequence logo figures ...\",\n                      file=sys.stdout)\n\n            for path in self.conserved_paths:\n                path.plot_logo()\n\n            if self.parameters.arguments[\"verbose\"]:\n                rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n                output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                                       [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                     f\"{rename_dict[i]}_seqlogo_visualisation\") for i in\n                                        self.parameters.arguments['sequences_to_write']]))\n                output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n                delimiter = \",\\n\\t\"\n                print(f\"\ud83d\udc8c Sequence logo figures were saved to the folders: \\n\\t{delimiter.join(output_dirs_v)}\",\n                      file=sys.stdout)\n            return None\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to plot sequence logo of conserved uORFs.\") from error\n\n    def plot_annotation(self) -&gt; None:\n        \"\"\"Plot loci' annotations figures with conserved ORFs highlighting.\n\n        Returns:\n            None\n\n        \"\"\"\n        try:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83c\udfa8 Plotting loci annotations figures...\",\n                      file=sys.stdout)\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            output_dir = os.path.join(self.parameters.arguments[\"output_dir\"], \"annotation_visualisation\")\n            if not os.path.exists(output_dir):\n                os.mkdir(output_dir)\n            for path in self.conserved_paths:\n                output_file_name = f\"{os.path.join(output_dir, path.id)}.pdf\"\n                annotation_plot_manager = uorf4u.drawing_annotation.AnnotationPlotManager(path, self.records,\n                                                                                          self.parameters)\n                annotation_plot_manager.define_x_axis_coordinate_system()\n                annotation_plot_manager.create_tracks()\n                annotation_plot_manager.plot(output_file_name)\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83d\udc8c Annotation figures were saved to the folder: {os.path.basename(output_dir)}\",\n                      file=sys.stdout)\n        except Exception as error:\n            raise uorf4u.manager.uORF4uError(\"Unable to plot loci' annotations figures.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.__init__","title":"<code>__init__(records, parameters)</code>","text":"<p>Create an UpstreamSequences object.</p> <p>Parameters:</p> <ul> <li> <code>records</code>             (<code>list</code>)         \u2013          <p>List of Bio.SeqRecord.SeqRecord objects with upstream sequences.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def __init__(self, records: list, parameters: uorf4u.manager.Parameters):\n    \"\"\"Create an UpstreamSequences object.\n\n    Arguments:\n        records (list): List of Bio.SeqRecord.SeqRecord objects with upstream sequences.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.records = records\n    self.parameters = parameters\n    self.codon_table = Bio.Data.CodonTable.unambiguous_dna_by_name[\n        parameters.arguments[\"ncbi_genetic_code_name\"]]\n    self.conserved_paths = None\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.annotate_orfs","title":"<code>annotate_orfs()</code>","text":"<p>Annotate ORFs in upstream sequences.</p> Note <p>This function updates 'records' attribute.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def annotate_orfs(self) -&gt; None:\n    \"\"\"Annotate ORFs in upstream sequences.\n\n    Note:\n        This function updates 'records' attribute.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83d\udd0e Annotating ORFs in the upstream sequences...\", file=sys.stdout)\n        if self.parameters.arguments[\"alternative_start_codons\"]:\n            start_codons_list = self.codon_table.start_codons\n        else:\n            start_codons_list = [self.parameters.arguments[\"main_start_codon\"]]\n\n        if self.parameters.arguments[\"check_assembly_annotation\"] and \\\n                self.records[0].annotations[\"RefSeq\"]:\n            if self.parameters.arguments[\"verbose\"]:\n                print(f\"\ud83d\udce1 Retrieving assemblies' annotation...\", file=sys.stdout)\n            for i in range(0, len(self.records), 100):\n                useq_subset = [record for record in self.records[i:i + 100] if record.annotations[\"RefSeq\"]]\n                locus_ids = [locus.annotations[\"locus_id\"] for locus in useq_subset]\n                handle = Bio.Entrez.efetch(db=\"nucleotide\", id=locus_ids, rettype=\"gb\", retmode=\"xml\")\n                handle_txt = handle.read().decode('utf-8')\n                for useq_record in useq_subset:\n                    useq_record.annotations[\"locus_annotation\"] = Locus(useq_record.annotations[\"locus_id\"],\n                                                                        start_b=useq_record.annotations[\"start\"],\n                                                                        stop_b=useq_record.annotations[\"stop\"],\n                                                                        target_strand=useq_record.annotations[\n                                                                            \"strand\"],\n                                                                        locus_record=useq_record.annotations[\n                                                                            \"locus_record\"],\n                                                                        xml_output=handle_txt)\n        for useq_index in range(len(self.records)):\n            useq_record = self.records[useq_index]\n            useq_record.annotations[\"ORFs\"] = []\n            for first_position in range((useq_record.annotations[\"length\"] - self.parameters.arguments[\n                \"downstream_region_length\"]) + 1):\n                first_codon = useq_record.seq[first_position:first_position + 3]\n                if first_codon.upper() in start_codons_list:\n                    start_codon_position = first_position\n                    for second_position in range(start_codon_position + 3,\n                                                 (useq_record.annotations[\"length\"] - 3) + 1, 3):\n                        second_codon = useq_record.seq[second_position:second_position + 3]\n                        if second_codon.upper() in self.codon_table.stop_codons:\n                            stop_codon_position = second_position\n                            orf_length = stop_codon_position - start_codon_position\n                            distance = (useq_record.annotations[\"length\"] - self.parameters.arguments[\n                                \"downstream_region_length\"]) - stop_codon_position\n                            distance_sc = (useq_record.annotations[\"length\"] - self.parameters.arguments[\n                                \"downstream_region_length\"]) - start_codon_position\n\n                            if useq_record.annotations[\"RefSeq\"]:\n                                orf_id = f\"{useq_record.annotations['locus_id']},\" \\\n                                         f\"{useq_record.annotations['accession_number']},\" \\\n                                         f\"{distance_sc}\"\n                                orf_name = f\"{useq_record.annotations['label']},{distance_sc}\"\n                                contig_id = useq_record.annotations['locus_id']\n                            else:\n                                distance_sc = useq_record.annotations[\"length\"] - start_codon_position\n                                orf_id = f\"{useq_record.id},{distance_sc}\"\n                                if useq_record.description:\n                                    orf_name = f\"{useq_record.description}_{orf_id}\"\n                                else:\n                                    orf_name = orf_id\n                                contig_id = useq_record.description\n                            if useq_record.annotations[\"strand\"] == \"+\":\n                                contig_start = start_codon_position + useq_record.annotations[\"start\"]\n                                contig_stop = contig_start + orf_length\n                            elif useq_record.annotations[\"strand\"] == \"-\":\n                                contig_stop = useq_record.annotations[\"stop\"] - start_codon_position\n                                contig_start = contig_stop - orf_length\n                            contig_coordinates = f\"{contig_id}:{contig_start}:{contig_stop}\" \\\n                                                 f\"({useq_record.annotations['strand']})\"\n                            sd_window_start = max(\n                                [0, (start_codon_position - self.parameters.arguments[\"sd_window_length\"])])\n                            current_orf = ORF(parameters=self.parameters, id=orf_id, name=orf_name,\n                                              distance=distance, start=start_codon_position,\n                                              contig_coordinates=contig_coordinates,\n                                              stop=stop_codon_position, useq_index=useq_index,\n                                              nt_sequence=useq_record.seq[start_codon_position:stop_codon_position],\n                                              sd_window_seq=useq_record.seq[sd_window_start:start_codon_position])\n                            if current_orf.length &gt;= self.parameters.arguments[\n                                \"min_orf_length\"] and distance_sc != 0:\n                                useq_record.annotations[\"ORFs\"].append(current_orf)\n                                if self.parameters.arguments[\"check_assembly_annotation\"] and \\\n                                        useq_record.annotations[\"RefSeq\"]:\n                                    for cds in useq_record.annotations[\"locus_annotation\"].CDSs:\n                                        if current_orf.stop == cds[\"relative_stop\"] and (\n                                                (current_orf.start - cds[\"relative_start\"]) % 3 == 0):\n                                            the_same_stop = 1\n                                            current_orf.annotation = cds[\"product_name\"]\n                                            if current_orf.start != cds[\"relative_start\"]:\n                                                if current_orf.start &lt; cds[\"relative_start\"]:\n                                                    current_orf.annotation += \" (extension)\"\n                                                else:\n                                                    current_orf.annotation += \" (truncation)\"\n                                for annotated_orfs in useq_record.annotations[\"ORFs\"]:\n                                    if current_orf.stop == annotated_orfs.stop and \\\n                                            current_orf.id != annotated_orfs.id:\n                                        current_orf.extended_orfs.append(annotated_orfs.id)\n                            break\n        number_of_orfs = sum(len(i.annotations[\"ORFs\"]) for i in self.records)\n        if self.parameters.arguments[\"fast_searching\"] == \"auto\":\n            if len(self.records) &lt; 5:\n                self.parameters.arguments[\"fast_searching\"] = False\n            elif (len(self.records) &gt;= 100 or number_of_orfs &gt; 1000):\n                self.parameters.arguments[\"fast_searching\"] = True\n            else:\n                self.parameters.arguments[\"fast_searching\"] = False\n        if self.parameters.arguments[\"fast_searching\"]:\n            if number_of_orfs &gt; 1000:\n                self.parameters.arguments[\"fast_searching_skip\"] = True\n            else:\n                self.parameters.arguments[\"fast_searching_skip\"] = False\n        if number_of_orfs == 0:\n            print(f\"\u26d4Termination:\\n\\tNo ORF was annotated in upstream sequences.\"\n                  f\"\\n\\tThis run will be terminated.\", file=sys.stderr)\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            with open(os.path.join(self.parameters.arguments[\"output_dir\"], \"report.txt\"), \"w\") as report_f:\n                report_f.write(\"Termination:\\nNo ORF was annotated in upstream sequences.\")\n            sys.exit()\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\u2705 {number_of_orfs} ORFs were annotated.\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to annotate ORFs in upstream sequences.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.conserved_orf_searching","title":"<code>conserved_orf_searching()</code>","text":"<p>Search for sets of conserved ORFs in upstream sequences.</p> Note <p>This method updates the self.conserved_paths attribute.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def conserved_orf_searching(self) -&gt; None:\n    \"\"\"Search for sets of conserved ORFs in upstream sequences.\n\n    Note:\n        This method updates the self.conserved_paths attribute.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83d\udd0e Searching for conserved ORFs in upstream sequences...\",\n                  file=sys.stdout)\n        if len(self.records) == 1:\n            raise uorf4u.manager.uORF4uError(\"At least two sequences required to perform conservation analysis\")\n        lengths = []\n        for record in self.records:\n            for orf in record.annotations[\"ORFs\"]:\n                lengths.append(orf.length)\n        lengths = sorted(list(set(lengths)))\n        global_aligner = Bio.Align.PairwiseAligner()\n        global_aligner.mode = \"global\"\n        global_aligner.match_score = self.parameters.arguments[\"global_match_score\"]\n        global_aligner.mismatch_score = self.parameters.arguments[\"global_mismatch_score\"]\n        global_aligner.open_gap_score = self.parameters.arguments[\"global_open_gap_score\"]\n        global_aligner.extend_gap_score = self.parameters.arguments[\"global_extend_gap_score\"]\n        global_aligner.target_end_gap_score = self.parameters.arguments[\"global_target_end_gap_score\"]\n        global_aligner.query_end_gap_score = self.parameters.arguments[\"global_query_end_gap_score\"]\n        length_variance = self.parameters.arguments[\"orf_length_group_range\"]\n        number_of_useqs = len(self.records)\n        if self.parameters.arguments[\"fast_searching\"]:\n            filtered_orfs_dict = dict()\n            for length in lengths:\n                if isinstance(self.parameters.arguments[\"orf_length_group_range\"], float):\n                    length_variance = length * self.parameters.arguments[\"orf_length_group_range\"]\n                filtered_orfs = []\n                useq_with_filtered_orfs = []\n                for useq_index in range(number_of_useqs):\n                    useq_record = self.records[useq_index]\n                    for orf in useq_record.annotations[\"ORFs\"]:\n                        if abs(length - orf.length) &lt;= length_variance:\n                            filtered_orfs.append(orf)\n                            if useq_index not in useq_with_filtered_orfs:\n                                useq_with_filtered_orfs.append(useq_index)\n                if len(useq_with_filtered_orfs) / number_of_useqs &gt;= self.parameters.arguments[\n                    \"orfs_presence_cutoff\"]:\n                    to_add = 1\n                    keys_to_remove = []\n                    for added_length in filtered_orfs_dict.keys():\n                        num_of_identical_elements = len(set(filtered_orfs) &amp; set(filtered_orfs_dict[added_length]))\n                        fraction = num_of_identical_elements / min(len(filtered_orfs),\n                                                                   len(filtered_orfs_dict[added_length]))\n                        if fraction &gt; 0.95:  # to add as a config parameter\n                            if len(filtered_orfs) &gt;= len(filtered_orfs_dict[added_length]):\n                                keys_to_remove.append(added_length)\n                            else:\n                                to_add = 0\n                    for key_to_remove in keys_to_remove:\n                        filtered_orfs_dict.pop(key_to_remove)\n                    if to_add:\n                        filtered_orfs_dict[length] = filtered_orfs\n            lengths = list(filtered_orfs_dict.keys())\n\n        conserved_paths = []\n        for length in lengths:\n            if isinstance(self.parameters.arguments[\"orf_length_group_range\"], float):\n                length_variance = length * self.parameters.arguments[\"orf_length_group_range\"]\n            useq_indexes_with_filtered_orfs = []\n            filtered_orfs = dict()\n            for useq_index in range(number_of_useqs):\n                useq_record = self.records[useq_index]\n                filtered_orfs[useq_index] = []\n                for orf in useq_record.annotations[\"ORFs\"]:\n                    if abs(length - orf.length) &lt;= length_variance:\n                        filtered_orfs[useq_index].append(orf)\n                orfs_ids = [i.id for i in filtered_orfs[useq_index]]\n                for orf in filtered_orfs[useq_index]:\n                    if any(i in orf.extended_orfs for i in orfs_ids):\n                        filtered_orfs[useq_index].remove(orf)\n                if len(filtered_orfs[useq_index]) &gt; 0:\n                    useq_indexes_with_filtered_orfs.append(useq_index)\n            if len(useq_indexes_with_filtered_orfs) / number_of_useqs &gt;= self.parameters.arguments[\n                \"orfs_presence_cutoff\"]:\n                if self.parameters.arguments[\"fast_searching\"]:\n                    genome_iterator = random.sample(list(filtered_orfs.keys()),\n                                                    max(1, min(round(self.parameters.arguments[\"fast_searching_\"\n                                                                                               \"fraction_of_initial\"\n                                                                                               \"_genomes\"] * len(\n                                                        useq_indexes_with_filtered_orfs)),\n                                                               self.parameters.arguments[\n                                                                   \"max_num_of_initial_genome_iteration\"])))\n                elif len(filtered_orfs.keys()) &gt; self.parameters.arguments[\"max_num_of_initial_genome_iteration\"]:\n                    genome_iterator = random.cr(list(filtered_orfs.keys()),\n                                                    self.parameters.arguments[\n                                                        \"max_num_of_initial_genome_iteration\"])\n                else:\n                    genome_iterator = filtered_orfs.keys()\n                for initial_useq in genome_iterator:\n                    for initial_orf in filtered_orfs[initial_useq]:\n                        already_conserved_orfs = []\n                        for already_conserved_path in conserved_paths:\n                            already_conserved_orfs += already_conserved_path.path\n                        if initial_orf not in already_conserved_orfs:\n                            conserved_path = Path(self.parameters)\n                            conserved_path.update(initial_orf)\n                            for useq in random.sample(list(filtered_orfs.keys()), len(filtered_orfs.keys())):\n                                useq_candidates = filtered_orfs[useq]\n                                if self.parameters.arguments[\"fast_searching\"]:\n                                    if self.parameters.arguments[\"fast_searching_skip\"]:\n                                        useq_candidates = [orf_useq for orf_useq in filtered_orfs[useq] if\n                                                           orf_useq not in already_conserved_orfs]\n                                if useq != initial_useq and useq_candidates != []:\n                                    score_sums = []\n                                    for orf in useq_candidates:\n                                        score_sum = 0\n                                        for path_orf in conserved_path.path:\n                                            if self.parameters.arguments[\"alignment_type\"] == \"nt\":\n                                                current_alignment = global_aligner.align(orf.nt_sequence,\n                                                                                         path_orf.nt_sequence)\n                                            elif self.parameters.arguments[\"alignment_type\"] == \"aa\":\n                                                current_alignment = global_aligner.align(orf.aa_sequence,\n                                                                                         path_orf.aa_sequence)\n                                            score_sum += current_alignment.score\n                                        score_sums.append(score_sum)\n                                    max_score = max(score_sums)\n                                    if max_score &gt; self.parameters.arguments[\"alignment_score_cutoff\"]:\n                                        if score_sums.count(max_score) == 1:\n                                            selected_orf = useq_candidates[score_sums.index(max_score)]\n                                        else:\n                                            num_of_candidates = len(useq_candidates)\n                                            highest_score_orfs = [useq_candidates[k] for k in\n                                                                  range(num_of_candidates)\n                                                                  if score_sums[k] == max_score]\n                                            highest_score_orfs_length_dists = [orf_it.length - length for orf_it in\n                                                                               highest_score_orfs]\n                                            min_length_dist = min(highest_score_orfs_length_dists)\n                                            if highest_score_orfs_length_dists.count(min_length_dist) == 1:\n                                                selected_orf = highest_score_orfs[\n                                                    highest_score_orfs_length_dists.index(min_length_dist)]\n                                            else:\n                                                num_of_candidates = len(highest_score_orfs)\n                                                the_closest_by_length_orfs = [highest_score_orfs[k] for k in\n                                                                              range(num_of_candidates) if\n                                                                              highest_score_orfs_length_dists[\n                                                                                  k] == min_length_dist]\n                                                the_closest_by_length_orfs_lengths = [orf_it.length for orf_it in\n                                                                                      the_closest_by_length_orfs]\n                                                max_length = max(the_closest_by_length_orfs_lengths)\n                                                selected_orf = the_closest_by_length_orfs[\n                                                    the_closest_by_length_orfs_lengths.index(max_length)]\n                                        conserved_path.update(selected_orf, max_score)\n                            if len(conserved_path) / number_of_useqs &gt;= self.parameters.arguments[\n                                \"orfs_presence_cutoff\"] and len(conserved_path) &gt; 1:\n                                to_save_this_path = 1\n                                for old_path in conserved_paths:\n                                    fraction_of_identity = conserved_path.calculate_similarity(old_path)\n                                    if fraction_of_identity &gt;= self.parameters.arguments[\"paths_identity_cutoff\"]:\n                                        if conserved_path.score &gt; old_path.score:\n                                            conserved_paths.remove(old_path)\n                                        elif conserved_path.score &lt;= old_path.score:\n                                            to_save_this_path = 0\n                                if to_save_this_path == 1:\n                                    # conserved_path.sort() # NOT SORTING!\n                                    conserved_paths.append(conserved_path)\n\n        self.conserved_paths = conserved_paths\n        number_of_paths = len(conserved_paths)\n        if number_of_paths == 0:\n            print(f\"\u26d4Termination:\\n\\tNo conserved ORFs set was found.\"\n                  f\"\\n\\tThis run will be terminated.\", file=sys.stderr)\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            with open(os.path.join(self.parameters.arguments[\"output_dir\"], \"report.txt\"), \"w\") as report_f:\n                report_f.write(\"Termination:\\nNo conserved ORFs set was found.\")\n            sys.exit()\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\u2705 {number_of_paths} sets of conserved ORFs were found.\",\n                  file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to perform searching for conserved uORFs.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.filter_orfs_by_sd_annotation","title":"<code>filter_orfs_by_sd_annotation()</code>","text":"<p>Filter annotated ORFs by presence the Shine-Dalgarno sequence.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def filter_orfs_by_sd_annotation(self) -&gt; None:\n    \"\"\"Filter annotated ORFs by presence the Shine-Dalgarno sequence.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        for useq_record in self.records:\n            orf_list = useq_record.annotations[\"ORFs\"]\n            filtered_orf_list = []\n            for orf in orf_list:\n                orf.calculate_energies()\n                if orf.min_energy &lt; self.parameters.arguments[\"sd_energy_cutoff\"]:\n                    filtered_orf_list.append(orf)\n            useq_record.annotations[\"ORFs\"] = filtered_orf_list\n\n        number_of_orfs = sum(len(i.annotations[\"ORFs\"]) for i in self.records)\n        if number_of_orfs == 0:\n            print(f\"\u26d4Termination:\\n\\tNo ORF left after filtering by SD annotation.\"\n                  f\"\\n\\tThis run will be terminated.\", file=sys.stderr)\n            if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n                os.mkdir(self.parameters.arguments[\"output_dir\"])\n            with open(os.path.join(self.parameters.arguments[\"output_dir\"], \"report.txt\"), \"w\") as report_f:\n                report_f.write(\"Termination:\\nNo ORF left after filtering by SD annotation.\")\n            sys.exit()\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83e\uddf9 {number_of_orfs} ORFs remained in the analysis after filtering by presence \"\n                  f\"of the SD sequence.\\n\\tYou can deactivate filtering by -nsd parameter \"\n                  f\"or by changing the config file.\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to filter uORFs by SD sequence presence.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.filter_out_similar_paths","title":"<code>filter_out_similar_paths()</code>","text":"<p>Filter out duplicates in sets of annotated conserved ORFs.</p> Note <p>Two paths are considered as duplicates if they share more than half of ORFs     (default value, see 'paths_identity_cutoff' config parameter). In case two paths are found as identical,     only one with a higher score will be saved.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def filter_out_similar_paths(self) -&gt; None:\n    \"\"\"Filter out duplicates in sets of annotated conserved ORFs.\n\n    Note:\n        Two paths are considered as duplicates if they share more than half of ORFs\n            (default value, see 'paths_identity_cutoff' config parameter). In case two paths are found as identical,\n            only one with a higher score will be saved.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        filtered_paths = []\n        for path in self.conserved_paths:\n            to_add = 1\n            for path_filtered in filtered_paths:\n                if path.calculate_similarity(path_filtered) &gt; self.parameters.arguments[\"paths_identity_cutoff\"]:\n                    if path.score &lt; path_filtered.score:\n                        to_add = 0\n                    elif path.score == path_filtered.score and (len(path) &lt; len(path_filtered)):\n                        to_add = 0\n                    else:\n                        filtered_paths.remove(path_filtered)\n            if to_add == 1:\n                filtered_paths.append(path)\n        self.conserved_paths = filtered_paths\n\n        if self.parameters.arguments[\"verbose\"]:\n            num_of_paths = len(self.conserved_paths)\n            print(f\"\ud83e\uddf9 {num_of_paths} set(s) of conserved ORFs remained in the analysis after filtering \"\n                  f\"out duplicates.\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to filter out duplicates in conserved uORFs sets.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.plot_annotation","title":"<code>plot_annotation()</code>","text":"<p>Plot loci' annotations figures with conserved ORFs highlighting.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def plot_annotation(self) -&gt; None:\n    \"\"\"Plot loci' annotations figures with conserved ORFs highlighting.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83c\udfa8 Plotting loci annotations figures...\",\n                  file=sys.stdout)\n        if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n            os.mkdir(self.parameters.arguments[\"output_dir\"])\n        output_dir = os.path.join(self.parameters.arguments[\"output_dir\"], \"annotation_visualisation\")\n        if not os.path.exists(output_dir):\n            os.mkdir(output_dir)\n        for path in self.conserved_paths:\n            output_file_name = f\"{os.path.join(output_dir, path.id)}.pdf\"\n            annotation_plot_manager = uorf4u.drawing_annotation.AnnotationPlotManager(path, self.records,\n                                                                                      self.parameters)\n            annotation_plot_manager.define_x_axis_coordinate_system()\n            annotation_plot_manager.create_tracks()\n            annotation_plot_manager.plot(output_file_name)\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83d\udc8c Annotation figures were saved to the folder: {os.path.basename(output_dir)}\",\n                  file=sys.stdout)\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to plot loci' annotations figures.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.plot_ggmsa_figs","title":"<code>plot_ggmsa_figs()</code>","text":"<p>Plot MSA plots of conserved ORFs saved as fasta files.</p> Note <p>R script based on ggmsa package [yulab-smu.top/ggmsa] used to produce MSA plots. R script (msa_plot.R)     can be found in output_dir. This method uses subprocess to run this R script in the following way:     <code>Rscript {output_dir}/msa_plot.R --msa_fasta path_to_fasta --output output_path --seq_type (nt/aa)     --width N(mm) --height M(mm)</code>.     Since during each run of uorf4u a local copy of this script is created     in your output_dir, you can change it without any consequences for next uorf4u runs.     This method based on plot_ggmsa method of Path class and simply call it for each Path object.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def plot_ggmsa_figs(self) -&gt; None:\n    \"\"\"Plot MSA plots of conserved ORFs saved as fasta files.\n\n    Note:\n        R script based on ggmsa package [yulab-smu.top/ggmsa] used to produce MSA plots. R script (msa_plot.R)\n            can be found in output_dir. This method uses subprocess to run this R script in the following way:\n            `Rscript {output_dir}/msa_plot.R --msa_fasta path_to_fasta --output output_path --seq_type (nt/aa)\n            --width N(mm) --height M(mm)`.\n            Since during each run of uorf4u a local copy of this script is created\n            in your output_dir, you can change it without any consequences for next uorf4u runs.\n            This method based on _plot_ggmsa_ method of Path class and simply call it for each Path object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83c\udfa8 Plotting MSA figures...\", file=sys.stdout)\n        for path in self.conserved_paths:\n            path.plot_ggmsa()\n\n        if self.parameters.arguments[\"verbose\"]:\n            rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n            output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                                   [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                 f\"{rename_dict[i]}_msa_visualisation\") for i in\n                                    self.parameters.arguments['sequences_to_write']]))\n            output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n            delimiter = \",\\n\\t\"\n            print(f\"\ud83d\udc8c MSA figures were saved to the folders:\\n\\t{delimiter.join(output_dirs_v)}.\",\n                  file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to visualise MSA of conserved uORFs.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.plot_logo_figs","title":"<code>plot_logo_figs()</code>","text":"<p>Plot sequence Logo figures of conserved ORFs saved as fasta files.</p> Note <p>This method uses logomaker package to produce images.</p> <p>This method based on plot_logo method of Path class and simply call it for each Path object.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def plot_logo_figs(self) -&gt; None:\n    \"\"\"Plot sequence Logo figures of conserved ORFs saved as fasta files.\n\n    Note:\n        This method uses logomaker package to produce images.\n\n        This method based on _plot_logo_ method of Path class and simply call it for each Path object.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83c\udfa8 Plotting sequence logo figures ...\",\n                  file=sys.stdout)\n\n        for path in self.conserved_paths:\n            path.plot_logo()\n\n        if self.parameters.arguments[\"verbose\"]:\n            rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n            output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                                   [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                 f\"{rename_dict[i]}_seqlogo_visualisation\") for i in\n                                    self.parameters.arguments['sequences_to_write']]))\n            output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n            delimiter = \",\\n\\t\"\n            print(f\"\ud83d\udc8c Sequence logo figures were saved to the folders: \\n\\t{delimiter.join(output_dirs_v)}\",\n                  file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to plot sequence logo of conserved uORFs.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.plot_msa_figs","title":"<code>plot_msa_figs()</code>","text":"<p>Plot MSA plots of  conserved ORFs</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def plot_msa_figs(self) -&gt; None:\n    \"\"\"Plot MSA plots of  conserved ORFs\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83c\udfa8 Plotting MSA figures...\", file=sys.stdout)\n        for path in self.conserved_paths:\n            path.plot_msa()\n\n        if self.parameters.arguments[\"verbose\"]:\n            rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n            output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                                   [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                 f\"{rename_dict[i]}_msa_visualisation\") for i in\n                                    self.parameters.arguments['sequences_to_write']]))\n            output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n            delimiter = \",\\n\\t\"\n            print(f\"\ud83d\udc8c MSA figures were saved to the folders: \\n\\t{delimiter.join(output_dirs_v)}\",\n                  file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to plot sequence logo of conserved uORFs.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.run_msa","title":"<code>run_msa()</code>","text":"<p>Run msa tool (muscle) for each path object (set of conserved ORFs).</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def run_msa(self) -&gt; None:\n    \"\"\"Run msa tool (muscle) for each path object (set of conserved ORFs).\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83e\uddee Running MSA for conserved ORFs.\", file=sys.stdout)\n        for path in self.conserved_paths:\n            path.maft_msa()\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to get MSA of conserved uORFs.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.save_annotated_orfs","title":"<code>save_annotated_orfs()</code>","text":"<p>Save information about annotated ORFs as a set of tsv files.</p> Note <p>tsv files will be saved to the subdir called 'annotated_ORFs' located in 'output_dir'.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def save_annotated_orfs(self) -&gt; None:\n    \"\"\"Save information about annotated ORFs as a set of tsv files.\n\n    Note:\n        tsv files will be saved to the subdir called 'annotated_ORFs' located in 'output_dir'.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n\n        colnames_list = [\"id\", \"name\", \"length\", \"distance_to_the_mORF\", \"contig_coordinates\", \"nt_sequence\",\n                         \"aa_sequence\"]\n        if self.parameters.arguments[\"filter_by_sd\"]:\n            colnames_list += [\"sd_sequence_window\", \"SD-aSD energy\", \"SD-aSD energies list\"]\n        colnames_list += [\"extended_orfs\", \"annotation\"]\n        colnames = \"\\t\".join(colnames_list)\n        if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n            os.mkdir(self.parameters.arguments[\"output_dir\"])\n        output_dir_path = os.path.join(self.parameters.arguments[\"output_dir\"], \"annotated_ORFs\")\n        if not os.path.exists(output_dir_path):\n            os.mkdir(output_dir_path)\n        for useq_record in self.records:\n            file_name = f\"{useq_record.description},{useq_record.id}\".replace(' ', '_').replace('/', '_')\n            lines = [colnames]\n            for orf in useq_record.annotations[\"ORFs\"]:\n                if not orf.extended_orfs:\n                    extented_orfs_value = \"NA\"\n                else:\n                    extented_orfs_value = ';'.join(orf.extended_orfs)\n                line = [orf.id, orf.name, str(orf.length), str(orf.distance), orf.contig_coordinates,\n                        str(orf.nt_sequence), str(orf.aa_sequence)]\n                if self.parameters.arguments[\"filter_by_sd\"]:\n                    line += [str(orf.sd_window_seq_str), str(orf.min_energy), \";\".join(orf.sd_window_energies)]\n                line += [extented_orfs_value, orf.annotation]\n                lines.append(\"\\t\".join(line))\n            with open(os.path.join(output_dir_path, f\"{file_name}.tsv\"), \"w\") as output:\n                output.write(\"\\n\".join(lines))\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83d\udc8c tsv files with information about annotated ORFs were saved to \"\n                  f\"{os.path.basename(output_dir_path)} folder.\",\n                  file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to save annotated uORFs.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.save_msa","title":"<code>save_msa()</code>","text":"<p>Save MSA of conserved ORFs as fasta files.</p> Note <p>Fasta files will be saved to the subdirs: ['nucleotide_msa' - for MSA of nucleotide sequences of ORFs,     'amino_acid_msa' - MSA of amino acid sequences of ORFs, and 'sd_msa' - MSA of SD sequence regions     of ORFS). All of them located in your 'output_dir'.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def save_msa(self) -&gt; None:\n    \"\"\"Save MSA of conserved ORFs as fasta files.\n\n    Note:\n        Fasta files will be saved to the subdirs: ['nucleotide_msa' - for MSA of nucleotide sequences of ORFs,\n            'amino_acid_msa' - MSA of amino acid sequences of ORFs, and 'sd_msa' - MSA of SD sequence regions\n            of ORFS). All of them located in your 'output_dir'.\n\n    Returns:\n         None\n\n    \"\"\"\n    try:\n        if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n            os.mkdir(self.parameters.arguments[\"output_dir\"])\n        rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\", sd=\"sd\")\n        output_dirs = dict(zip(self.parameters.arguments[\"sequences_to_write\"],\n                               [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                             f\"{rename_dict[i]}_msa_fasta_files\") for i in\n                                self.parameters.arguments['sequences_to_write']]))\n        for key in output_dirs:\n            if not (os.path.exists(output_dirs[key])):\n                os.mkdir(output_dirs[key])\n        for path in self.conserved_paths:\n            for seq_type in self.parameters.arguments[\"sequences_to_write\"]:\n                msa = path.msa[seq_type]\n                output = os.path.join(output_dirs[seq_type], f\"{path.id}.fa\")\n                Bio.AlignIO.write(msa, output, \"fasta\")\n\n        if self.parameters.arguments[\"verbose\"]:\n            output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n            delimiter = \",\\n\\t\"\n            print(f\"\ud83d\udc8c MSA fasta files of conserved ORFs were saved to the folders:\\n\"\n                  f\"\\t{delimiter.join(output_dirs_v)} folders.\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to save MSA of conserved uORFs.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.save_orfs_sequences","title":"<code>save_orfs_sequences()</code>","text":"<p>Save sequences of conserved ORFs as fasta files.</p> Note <p>Fasta files will be saved to the subdirs: ['nucleotide_orfs' - for MSA of nucleotide sequences of ORFs,     'amino_acid_msa' - MSA of amino acid sequences of ORFs, and 'sd_msa' - MSA of SD sequence regions     of ORFS). All of them located in your 'output_dir'.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def save_orfs_sequences(self) -&gt; None:\n    \"\"\"Save sequences of conserved ORFs as fasta files.\n\n    Note:\n        Fasta files will be saved to the subdirs: ['nucleotide_orfs' - for MSA of nucleotide sequences of ORFs,\n            'amino_acid_msa' - MSA of amino acid sequences of ORFs, and 'sd_msa' - MSA of SD sequence regions\n            of ORFS). All of them located in your 'output_dir'.\n\n    Returns:\n         None\n\n    \"\"\"\n    try:\n        if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n            os.mkdir(self.parameters.arguments[\"output_dir\"])\n        rename_dict = dict(nt=\"nucleotide\", aa=\"amino_acid\")\n        sequence_to_write = [i for i in self.parameters.arguments[\"sequences_to_write\"] if i != \"sd\"]\n        output_dirs = dict(zip(sequence_to_write, [os.path.join(self.parameters.arguments[\"output_dir\"],\n                                                                f\"{rename_dict[i]}_orfs_fasta_files\") for i in\n                                                   sequence_to_write]))\n        for key in output_dirs:\n            if not (os.path.exists(output_dirs[key])):\n                os.mkdir(output_dirs[key])\n        for seq_type in sequence_to_write:\n            for path in self.conserved_paths:\n                records = []\n                for orf in path.path:\n                    if seq_type == \"nt\":\n                        record = Bio.SeqRecord.SeqRecord(orf.nt_sequence, orf.id, \"\", orf.name)\n                    if seq_type == \"aa\":\n                        record = Bio.SeqRecord.SeqRecord(orf.aa_sequence, orf.id, \"\", orf.name)\n                    records.append(record)\n                output = os.path.join(output_dirs[seq_type], f\"{path.id}.fa\")\n                Bio.SeqIO.write(records, output, \"fasta\")\n        if self.parameters.arguments[\"verbose\"]:\n            delimiter = \",\\n\\t\"\n            output_dirs_v = [os.path.basename(i) for i in output_dirs.values()]\n            print(f\"\ud83d\udc8c Sequences fasta files of conserved ORFs were saved to the folders: \\n\"\n                  f\"\\t{delimiter.join(output_dirs_v)}.\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to save sequences of conserved uORFs.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.save_results_summary_table","title":"<code>save_results_summary_table()</code>","text":"<p>Save results summary table.</p> Note <p>A tsv table will be saved to your output_dir.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def save_results_summary_table(self) -&gt; None:\n    \"\"\"Save results summary table.\n\n    Note:\n        A tsv table will be saved to your output_dir.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        colnames = \"\\t\".join(\n            [\"id\", \"length\", \"average_distance_to_the_ORF\", \"aa_alignment_length\", \"nt_alignment_length\", \"score\",\n             \"number_of_orfs\", \"number_of_orfs/number_of_sequences\", \"consensus(aa)\", \"consensus(nt)\",\n             \"uORFs\", \"uORFs_annotations\"])\n        rows = [colnames]\n        for path in self.conserved_paths:\n            annotations = sorted(set([i.annotation for i in path.path]))\n            if len(annotations) &gt; 1 and \"NA\" in annotations:\n                pass\n                # annotations.remove(\"NA\") # To check then\n            row = \"\\t\".join(\n                [path.id, str(path.length), str(statistics.mean([i.distance for i in path.path])),\n                 str(path.msa[\"aa\"].get_alignment_length()), str(path.msa[\"nt\"].get_alignment_length()),\n                 str(path.score), str(len(path)), str(round(len(path) / len(self.records), 3)),\n                 str(path.msa_consensus[\"aa\"]), str(path.msa_consensus[\"nt\"]), ', '.join([i.id for i in path.path]),\n                 ', '.join(annotations)])\n            rows.append(row)\n        output_file_path = os.path.join(self.parameters.arguments[\"output_dir\"], \"results_summary.tsv\")\n        f = open(output_file_path, \"w\")\n        f.write(\"\\n\".join(rows))\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83d\udc8c Results summary tsv table saved to: {os.path.basename(output_file_path)}.\", file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to save results summary table.\") from error\n</code></pre>"},{"location":"API/package_data_processing/#uorf4u.data_processing.UpstreamSequences.save_upstream_sequences","title":"<code>save_upstream_sequences()</code>","text":"<p>Save upstream sequences as a fasta file.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/data_processing.py</code> <pre><code>def save_upstream_sequences(self) -&gt; None:\n    \"\"\"Save upstream sequences as a fasta file.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        output_file = os.path.join(self.parameters.arguments[\"output_dir\"], \"upstream_sequences.fa\")\n        if not os.path.exists(self.parameters.arguments[\"output_dir\"]):\n            os.mkdir(self.parameters.arguments[\"output_dir\"])\n        Bio.SeqIO.write(self.records, output_file, \"fasta\")\n        if self.parameters.arguments[\"verbose\"]:\n            print(f\"\ud83d\udc8c Fasta file with upstream sequences was saved to {os.path.basename(output_file)}.\",\n                  file=sys.stdout)\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\"Unable to save a fasta file with upstream sequences.\") from error\n</code></pre>"},{"location":"API/package_drawing/","title":"uorf4u.drawing","text":"<p>This module provides visualisation of loci annotation.</p> <p>This module provides visualisation of loci annotation.</p>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.AnnotationPlotManager","title":"<code>AnnotationPlotManager</code>","text":"<p>AnnotationPlotManager object holds needed information for annotation visualisation and controls it.</p> Note <p>It's supposed that the AnnotationPlotManager' objects will not be used directly by API users since     visualisation can be controlled by 'plot_annotation' method.</p> <p>Attributes:</p> <ul> <li> <code>path</code>             (<code>Path</code>)         \u2013          <p>Path class' objects that holds list of conserved ORFs.</p> </li> <li> <code>upstream_sequences</code>             (<code>list</code>)         \u2013          <p>list of dicts with information about upstream sequences.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>coordinate_system</code>             (<code>dict</code>)         \u2013          <p>coordinate system of figure.</p> </li> <li> <code>additional_data</code>             (<code>dict</code>)         \u2013          <p>dict with data for visualisation tracks.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class AnnotationPlotManager:\n    \"\"\"\n    AnnotationPlotManager object holds needed information for annotation visualisation and controls it.\n\n    Note:\n        It's supposed that the AnnotationPlotManager' objects will not be used directly by API users since\n            visualisation can be controlled by 'plot_annotation' method.\n\n    Attributes:\n        path (uorf4u.data_processing.Path): Path class' objects that holds list of conserved ORFs.\n        upstream_sequences (list): list of dicts with information about upstream sequences.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        coordinate_system (dict): coordinate system of figure.\n        additional_data (dict): dict with data for visualisation tracks.\n\n    \"\"\"\n\n    def __init__(self, path, upstream_sequences: list, parameters: uorf4u.manager.Parameters):\n        \"\"\"Create a AnnotationPlotManager object.\n\n        Arguments:\n            path (uorf4u.data_processing.Path): Path class' objects that holds list of conserved ORFs.\n            upstream_sequences (list): list of dicts with information about upstream sequences.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.path = path\n        self.upstream_sequences = upstream_sequences\n        self.parameters = parameters\n        self.coordinate_system = dict()\n        self.additional_data = dict()\n\n    def define_x_axis_coordinate_system(self) -&gt; None:\n        \"\"\"Define coordinate system.\n\n        Returns:\n            None\n\n        \"\"\"\n\n        label_height = self.parameters.arguments[\"label_height_to_orf_height\"] * self.parameters.arguments[\n            \"orf_height\"] * cm\n        label_font_size = uorf4u.methods.string_height_to_font_size(label_height, \"regular\", self.parameters.arguments)\n        self.additional_data[\"label_font_size\"] = label_font_size\n        self.additional_data[\"ordered_upstream_sequences\"] = [self.upstream_sequences[i] for i in\n                                                              [orf.useq_index for orf in self.path.path]]\n        max_label_width = max([reportlab.pdfbase.pdfmetrics.stringWidth(i.annotations[\"label\"], \"regular\",\n                                                                        label_font_size)\n                               for i in self.additional_data[\"ordered_upstream_sequences\"]])\n        self.additional_data[\"number_of_sequences\"] = len(self.path)\n        self.additional_data[\"max_upstream_sequence_length\"] = max(\n            i.annotations[\"upstream_region_length\"] for i in self.additional_data[\"ordered_upstream_sequences\"])\n        self.additional_data[\"max_downstream_sequence_length\"] = max(\n            i.annotations[\"downstream_region_length\"] for i in self.additional_data[\"ordered_upstream_sequences\"])\n        window_size_nt = self.additional_data[\"max_upstream_sequence_length\"] + self.additional_data[\n            \"max_downstream_sequence_length\"]\n        if self.parameters.arguments[\"annotation_width\"] == \"auto\":\n            annotation_width = window_size_nt * self.parameters.arguments[\"mm_per_nt\"] * mm\n        else:\n            annotation_width = self.parameters.arguments[\"annotation_width\"] * cm\n        self.coordinate_system[\"transformation_coef\"] = annotation_width / window_size_nt\n        self.coordinate_system[\"x_labels_start\"] = self.parameters.arguments[\"margin\"] * cm\n        self.coordinate_system[\"x_labels_stop\"] = self.coordinate_system[\"x_labels_start\"] + max_label_width\n        self.coordinate_system[\"x_annotation_start\"] = self.coordinate_system[\"x_labels_stop\"] + \\\n                                                       self.parameters.arguments[\"label_gap\"] * cm\n        self.coordinate_system[\"x_annotation_stop\"] = self.coordinate_system[\"x_annotation_start\"] + annotation_width\n        self.coordinate_system[\"figure_width\"] = 2 * self.parameters.arguments[\"margin\"] * cm + annotation_width + \\\n                                                 max_label_width + self.parameters.arguments[\"label_gap\"] * cm\n        self.coordinate_system[\"figure_height\"] = self.parameters.arguments[\"margin\"] * cm\n\n        return None\n\n    def create_tracks(self) -&gt; None:\n        \"\"\"Create visualisation tracks.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.tracks = []\n        \"\"\"\n        title_loader = TitleLoader(self.parameters)\n        title_loader.prepare_data(self.coordinate_system, self.additional_data)\n        title_track = title_loader.create_track()\n        self.tracks.append(title_track)\n        self.coordinate_system[\"figure_height\"] += title_track.needed_y_space()\n        \"\"\"\n        for index in range(self.additional_data[\"number_of_sequences\"]):\n            upstream_sequence = self.additional_data[\"ordered_upstream_sequences\"][index]\n            conserved_orf = self.path.path[index]\n            sequence_loader = SequencesLoader(self.parameters)\n            sequence_loader.prepare_data(upstream_sequence, conserved_orf, self.coordinate_system, self.additional_data)\n            track = sequence_loader.create_track()\n            self.tracks.append(track)\n            self.coordinate_system[\"figure_height\"] += track.needed_y_space()\n            self.coordinate_system[\"figure_height\"] += self.parameters.arguments[\"gap\"] * cm\n            # if index &lt; self.additional_data[\"number_of_sequences\"] - 1:\n        axis_tics_loader = AxisLoader(self.parameters)\n        axis_tics_loader.prepare_data(self.coordinate_system, self.additional_data)\n        axis_tics_track = axis_tics_loader.create_track()\n        self.tracks.append(axis_tics_track)\n        self.coordinate_system[\"figure_height\"] += axis_tics_track.needed_y_space()\n        self.coordinate_system[\"figure_height\"] += self.parameters.arguments[\"margin\"] * cm\n\n    def plot(self, filename):\n        image = Image(filename, self.coordinate_system[\"figure_width\"], self.coordinate_system[\"figure_height\"])\n        current_y_top = self.coordinate_system[\"figure_height\"] - self.parameters.arguments[\"margin\"] * cm\n        for track in self.tracks:\n            track.visualisation_data[\"y_top\"] = current_y_top\n            track.draw(image.canvas)\n            current_y_top -= (track.needed_space + self.parameters.arguments[\"gap\"] * cm)\n        image.save()\n        return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.AnnotationPlotManager.__init__","title":"<code>__init__(path, upstream_sequences, parameters)</code>","text":"<p>Create a AnnotationPlotManager object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>Path</code>)         \u2013          <p>Path class' objects that holds list of conserved ORFs.</p> </li> <li> <code>upstream_sequences</code>             (<code>list</code>)         \u2013          <p>list of dicts with information about upstream sequences.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, path, upstream_sequences: list, parameters: uorf4u.manager.Parameters):\n    \"\"\"Create a AnnotationPlotManager object.\n\n    Arguments:\n        path (uorf4u.data_processing.Path): Path class' objects that holds list of conserved ORFs.\n        upstream_sequences (list): list of dicts with information about upstream sequences.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.path = path\n    self.upstream_sequences = upstream_sequences\n    self.parameters = parameters\n    self.coordinate_system = dict()\n    self.additional_data = dict()\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.AnnotationPlotManager.create_tracks","title":"<code>create_tracks()</code>","text":"<p>Create visualisation tracks.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def create_tracks(self) -&gt; None:\n    \"\"\"Create visualisation tracks.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.tracks = []\n    \"\"\"\n    title_loader = TitleLoader(self.parameters)\n    title_loader.prepare_data(self.coordinate_system, self.additional_data)\n    title_track = title_loader.create_track()\n    self.tracks.append(title_track)\n    self.coordinate_system[\"figure_height\"] += title_track.needed_y_space()\n    \"\"\"\n    for index in range(self.additional_data[\"number_of_sequences\"]):\n        upstream_sequence = self.additional_data[\"ordered_upstream_sequences\"][index]\n        conserved_orf = self.path.path[index]\n        sequence_loader = SequencesLoader(self.parameters)\n        sequence_loader.prepare_data(upstream_sequence, conserved_orf, self.coordinate_system, self.additional_data)\n        track = sequence_loader.create_track()\n        self.tracks.append(track)\n        self.coordinate_system[\"figure_height\"] += track.needed_y_space()\n        self.coordinate_system[\"figure_height\"] += self.parameters.arguments[\"gap\"] * cm\n        # if index &lt; self.additional_data[\"number_of_sequences\"] - 1:\n    axis_tics_loader = AxisLoader(self.parameters)\n    axis_tics_loader.prepare_data(self.coordinate_system, self.additional_data)\n    axis_tics_track = axis_tics_loader.create_track()\n    self.tracks.append(axis_tics_track)\n    self.coordinate_system[\"figure_height\"] += axis_tics_track.needed_y_space()\n    self.coordinate_system[\"figure_height\"] += self.parameters.arguments[\"margin\"] * cm\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.AnnotationPlotManager.define_x_axis_coordinate_system","title":"<code>define_x_axis_coordinate_system()</code>","text":"<p>Define coordinate system.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def define_x_axis_coordinate_system(self) -&gt; None:\n    \"\"\"Define coordinate system.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    label_height = self.parameters.arguments[\"label_height_to_orf_height\"] * self.parameters.arguments[\n        \"orf_height\"] * cm\n    label_font_size = uorf4u.methods.string_height_to_font_size(label_height, \"regular\", self.parameters.arguments)\n    self.additional_data[\"label_font_size\"] = label_font_size\n    self.additional_data[\"ordered_upstream_sequences\"] = [self.upstream_sequences[i] for i in\n                                                          [orf.useq_index for orf in self.path.path]]\n    max_label_width = max([reportlab.pdfbase.pdfmetrics.stringWidth(i.annotations[\"label\"], \"regular\",\n                                                                    label_font_size)\n                           for i in self.additional_data[\"ordered_upstream_sequences\"]])\n    self.additional_data[\"number_of_sequences\"] = len(self.path)\n    self.additional_data[\"max_upstream_sequence_length\"] = max(\n        i.annotations[\"upstream_region_length\"] for i in self.additional_data[\"ordered_upstream_sequences\"])\n    self.additional_data[\"max_downstream_sequence_length\"] = max(\n        i.annotations[\"downstream_region_length\"] for i in self.additional_data[\"ordered_upstream_sequences\"])\n    window_size_nt = self.additional_data[\"max_upstream_sequence_length\"] + self.additional_data[\n        \"max_downstream_sequence_length\"]\n    if self.parameters.arguments[\"annotation_width\"] == \"auto\":\n        annotation_width = window_size_nt * self.parameters.arguments[\"mm_per_nt\"] * mm\n    else:\n        annotation_width = self.parameters.arguments[\"annotation_width\"] * cm\n    self.coordinate_system[\"transformation_coef\"] = annotation_width / window_size_nt\n    self.coordinate_system[\"x_labels_start\"] = self.parameters.arguments[\"margin\"] * cm\n    self.coordinate_system[\"x_labels_stop\"] = self.coordinate_system[\"x_labels_start\"] + max_label_width\n    self.coordinate_system[\"x_annotation_start\"] = self.coordinate_system[\"x_labels_stop\"] + \\\n                                                   self.parameters.arguments[\"label_gap\"] * cm\n    self.coordinate_system[\"x_annotation_stop\"] = self.coordinate_system[\"x_annotation_start\"] + annotation_width\n    self.coordinate_system[\"figure_width\"] = 2 * self.parameters.arguments[\"margin\"] * cm + annotation_width + \\\n                                             max_label_width + self.parameters.arguments[\"label_gap\"] * cm\n    self.coordinate_system[\"figure_height\"] = self.parameters.arguments[\"margin\"] * cm\n\n    return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.AxisLoader","title":"<code>AxisLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>An AxisLoader object prepares data for an Axis track object.</p> <p>Attributes:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>prepared_data</code>             (<code>dict</code>)         \u2013          <p>dict with data needed for a visualisation track.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class AxisLoader(Loader):\n    \"\"\"An AxisLoader object prepares data for an Axis track object.\n\n\n    Attributes:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        prepared_data (dict): dict with data needed for a visualisation track.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create an AxisLoader object.\n\n        Arguments:\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_data(self, coordinate_system: dict, additional_data: dict):\n        \"\"\"Prepare data for an Axis visualisation track.\n\n        Attributes:\n            coordinate_system (dict): coordinate system of a figure page.\n            additional_data (dict): data needed for a track initialisation.\n\n        Returns:\n            dict: dictionary with prepared data for visualisation.\n\n        \"\"\"\n        prepared_data = dict()\n        prepared_data[\"coordinate_system\"] = coordinate_system\n        prepared_data[\"max_upstream_sequence_length\"] = additional_data[\"max_upstream_sequence_length\"]\n        prepared_data[\"max_downstream_sequence_length\"] = additional_data[\"max_downstream_sequence_length\"]\n        step = int(round(additional_data[\"max_upstream_sequence_length\"] / 2, -2))\n        tics = [-additional_data[\"max_upstream_sequence_length\"], 0, additional_data[\"max_downstream_sequence_length\"]]\n        x_tic_centred = int(round(-additional_data[\"max_upstream_sequence_length\"] / 2, -2))\n        tics.append(x_tic_centred)\n        x_tic_left, x_tic_right = x_tic_centred - step, x_tic_centred + step\n        while x_tic_right &lt; 0 and x_tic_left &gt; - additional_data[\"max_upstream_sequence_length\"]:\n            tics.append(x_tic_left)\n            tics.append(x_tic_right)\n            x_tic_left -= step\n            x_tic_right += step\n        tics.sort()\n        tics_coordinates = [self.transform_relative_position_to_x_coordinate(i, coordinate_system, additional_data[\n            \"max_upstream_sequence_length\"]) for i in tics]\n        prepared_data[\"tics\"] = {k: v for k, v in zip(tics, tics_coordinates)}\n        self.prepared_data = prepared_data\n        return prepared_data\n\n    def transform_relative_position_to_x_coordinate(self, relative_position: int, coordinate_system: dict,\n                                                    max_upstream_sequence_length: int) -&gt; float:\n        \"\"\"Transform nucleotide x coordinate to pdf's.\n\n        Arguments:\n            relative_position (int): nucleotide position\n            coordinate_system (dict): coordinate system of a figure.\n            max_upstream_sequence_length (int): max length of upstream sequences for visualisation.\n\n        Returns:\n            float: transformed x coordinate.\n        \"\"\"\n        return coordinate_system[\"x_annotation_start\"] + (relative_position + max_upstream_sequence_length) * \\\n               coordinate_system[\"transformation_coef\"]\n\n    def create_track(self) -&gt; TicsVis:\n        \"\"\"Initialise a Tics track object.\n\n        Returns:\n            TicsVis: visualisation track.\n\n        \"\"\"\n        return TicsVis(self.prepared_data, self.parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.AxisLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create an AxisLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create an AxisLoader object.\n\n    Arguments:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.AxisLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a Tics track object.</p> <p>Returns:</p> <ul> <li> <code>TicsVis</code> (            <code>TicsVis</code> )        \u2013          <p>visualisation track.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def create_track(self) -&gt; TicsVis:\n    \"\"\"Initialise a Tics track object.\n\n    Returns:\n        TicsVis: visualisation track.\n\n    \"\"\"\n    return TicsVis(self.prepared_data, self.parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.AxisLoader.prepare_data","title":"<code>prepare_data(coordinate_system, additional_data)</code>","text":"<p>Prepare data for an Axis visualisation track.</p> <p>Attributes:</p> <ul> <li> <code>coordinate_system</code>             (<code>dict</code>)         \u2013          <p>coordinate system of a figure page.</p> </li> <li> <code>additional_data</code>             (<code>dict</code>)         \u2013          <p>data needed for a track initialisation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>        \u2013          <p>dictionary with prepared data for visualisation.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def prepare_data(self, coordinate_system: dict, additional_data: dict):\n    \"\"\"Prepare data for an Axis visualisation track.\n\n    Attributes:\n        coordinate_system (dict): coordinate system of a figure page.\n        additional_data (dict): data needed for a track initialisation.\n\n    Returns:\n        dict: dictionary with prepared data for visualisation.\n\n    \"\"\"\n    prepared_data = dict()\n    prepared_data[\"coordinate_system\"] = coordinate_system\n    prepared_data[\"max_upstream_sequence_length\"] = additional_data[\"max_upstream_sequence_length\"]\n    prepared_data[\"max_downstream_sequence_length\"] = additional_data[\"max_downstream_sequence_length\"]\n    step = int(round(additional_data[\"max_upstream_sequence_length\"] / 2, -2))\n    tics = [-additional_data[\"max_upstream_sequence_length\"], 0, additional_data[\"max_downstream_sequence_length\"]]\n    x_tic_centred = int(round(-additional_data[\"max_upstream_sequence_length\"] / 2, -2))\n    tics.append(x_tic_centred)\n    x_tic_left, x_tic_right = x_tic_centred - step, x_tic_centred + step\n    while x_tic_right &lt; 0 and x_tic_left &gt; - additional_data[\"max_upstream_sequence_length\"]:\n        tics.append(x_tic_left)\n        tics.append(x_tic_right)\n        x_tic_left -= step\n        x_tic_right += step\n    tics.sort()\n    tics_coordinates = [self.transform_relative_position_to_x_coordinate(i, coordinate_system, additional_data[\n        \"max_upstream_sequence_length\"]) for i in tics]\n    prepared_data[\"tics\"] = {k: v for k, v in zip(tics, tics_coordinates)}\n    self.prepared_data = prepared_data\n    return prepared_data\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.AxisLoader.transform_relative_position_to_x_coordinate","title":"<code>transform_relative_position_to_x_coordinate(relative_position, coordinate_system, max_upstream_sequence_length)</code>","text":"<p>Transform nucleotide x coordinate to pdf's.</p> <p>Parameters:</p> <ul> <li> <code>relative_position</code>             (<code>int</code>)         \u2013          <p>nucleotide position</p> </li> <li> <code>coordinate_system</code>             (<code>dict</code>)         \u2013          <p>coordinate system of a figure.</p> </li> <li> <code>max_upstream_sequence_length</code>             (<code>int</code>)         \u2013          <p>max length of upstream sequences for visualisation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>transformed x coordinate.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def transform_relative_position_to_x_coordinate(self, relative_position: int, coordinate_system: dict,\n                                                max_upstream_sequence_length: int) -&gt; float:\n    \"\"\"Transform nucleotide x coordinate to pdf's.\n\n    Arguments:\n        relative_position (int): nucleotide position\n        coordinate_system (dict): coordinate system of a figure.\n        max_upstream_sequence_length (int): max length of upstream sequences for visualisation.\n\n    Returns:\n        float: transformed x coordinate.\n    \"\"\"\n    return coordinate_system[\"x_annotation_start\"] + (relative_position + max_upstream_sequence_length) * \\\n           coordinate_system[\"transformation_coef\"]\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Image","title":"<code>Image</code>","text":"<p>An Image object holds pdf.</p> <p>Attributes:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>pdf object of the reportlab library.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class Image:\n    \"\"\"An Image object holds pdf.\n\n    Attributes:\n        canvas (reportlab.pdfgen.canvas.Canvas): pdf object of the reportlab library.\n\n    \"\"\"\n\n    def __init__(self, filename: str, width: float, height: float):\n        \"\"\"Create an Image object.\n\n        Arguments:\n            filename (str): path and name of a pdf.\n            width (float): width of a pdf.\n            height (float): height of a pdf.\n\n        \"\"\"\n        self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n\n    def save(self) -&gt; None:\n        \"\"\"Save a pdf file.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.canvas.save()\n        return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Image.__init__","title":"<code>__init__(filename, width, height)</code>","text":"<p>Create an Image object.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>path and name of a pdf.</p> </li> <li> <code>width</code>             (<code>float</code>)         \u2013          <p>width of a pdf.</p> </li> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>height of a pdf.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, filename: str, width: float, height: float):\n    \"\"\"Create an Image object.\n\n    Arguments:\n        filename (str): path and name of a pdf.\n        width (float): width of a pdf.\n        height (float): height of a pdf.\n\n    \"\"\"\n    self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Image.save","title":"<code>save()</code>","text":"<p>Save a pdf file.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Save a pdf file.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.canvas.save()\n    return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Loader","title":"<code>Loader</code>","text":"<p>Parent class for tracks loaders.</p> <p>Attributes:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>prepared_data</code>             (<code>dict</code>)         \u2013          <p>dict with data needed for visualisation tracks.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class Loader:\n    \"\"\"Parent class for tracks loaders.\n\n    Attributes:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        prepared_data (dict): dict with data needed for visualisation tracks.\n\n    \"\"\"\n\n    def __init__(self, parameters: uorf4u.manager.Parameters):\n        \"\"\"Parent's constructor for creating a Loader class object.\n\n        Arguments:\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n        \"\"\"\n        self.parameters = parameters\n        self.prepared_data = None\n\n    def prepare_data(self) -&gt; None:\n        \"\"\"Empty parent's method for data preparation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def create_track(self) -&gt; None:\n        \"\"\"Empty parent's method for initialisation of a track.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Loader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Parent's constructor for creating a Loader class object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, parameters: uorf4u.manager.Parameters):\n    \"\"\"Parent's constructor for creating a Loader class object.\n\n    Arguments:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n    \"\"\"\n    self.parameters = parameters\n    self.prepared_data = None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Loader.create_track","title":"<code>create_track()</code>","text":"<p>Empty parent's method for initialisation of a track.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def create_track(self) -&gt; None:\n    \"\"\"Empty parent's method for initialisation of a track.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Loader.prepare_data","title":"<code>prepare_data()</code>","text":"<p>Empty parent's method for data preparation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def prepare_data(self) -&gt; None:\n    \"\"\"Empty parent's method for data preparation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequenceVis","title":"<code>SequenceVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>SequenceVis track draws sequences and annotation.</p> <p>Attributes:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>needed_space</code>             (<code>float</code>)         \u2013          <p>needed vertical space for a track.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class SequenceVis(Track):\n    \"\"\"SequenceVis track draws sequences and annotation.\n\n    Attributes:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        needed_space (float): needed vertical space for a track.\n\n    \"\"\"\n\n    def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n        \"\"\"Create a SequenceVis object.\n\n        Arguments:\n            visualisation_data (dict): a dictionary with data needed for visualisation.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(visualisation_data, parameters)\n        self.needed_space = None\n\n    def needed_y_space(self) -&gt; float:\n        \"\"\"Calculate needed vertical space for a SequenceVis track.\n\n        Returns:\n            float: needed vertical space.\n\n        \"\"\"\n        self.needed_space = self.parameters.arguments[\"orf_height\"] * cm\n        return self.needed_space\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a Sequence track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n        Returns:\n            None\n\n        \"\"\"\n        orf_height = self.parameters.arguments[\"orf_height\"] * cm\n        y_c = self.visualisation_data[\"y_top\"] - 0.5 * orf_height\n        x_offset = 0.5 * self.parameters.arguments[\"upstream_seq_line_width\"]\n        canvas.setStrokeColorRGB(*uorf4u.methods.get_color(\"upstream_seq_line_color\", self.parameters.arguments))\n        canvas.setLineCap(0)\n        canvas.setLineWidth(self.parameters.arguments[\"upstream_seq_line_width\"])\n        canvas.line(self.visualisation_data[\"upstream_sequence_line_start_x\"], y_c,\n                    self.visualisation_data[\"upstream_sequence_line_stop_x\"] - x_offset, y_c)\n        # Cleaning the space:\n        canvas.setFillColorRGB\n        canvas.setStrokeColorRGB(1, 1, 1, 1)\n\n        for orf_dict in self.visualisation_data[\"orfs_coordinates_dict\"].values():\n\n            canvas.setLineWidth(self.parameters.arguments[\"upstream_seq_line_width\"]*1.5)\n            canvas.line(orf_dict[\"x_start\"], y_c, orf_dict[\"x_stop\"], y_c)\n            #canvas.rect(orf_dict[\"x_start\"], y_c - orf_height / 2, orf_dict[\"x_stop\"] - orf_dict[\"x_start\"], orf_height,\n            #            stroke=0, fill=1)\n        if self.parameters.arguments[\"check_assembly_annotation\"] and \\\n                \"fasta\" not in self.parameters.cmd_arguments.keys():\n            for protein_id, cds_dict in self.visualisation_data[\"CDSs_coordinates_dict\"].items():\n                canvas.line(cds_dict[\"x_start\"], y_c, cds_dict[\"x_stop\"], y_c)\n        canvas.setLineWidth(self.parameters.arguments[\"upstream_seq_line_width\"])\n\n        # Labels\n        canvas.setFillColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n        canvas.setFont(\"regular\", self.visualisation_data[\"label_font_size\"])\n        y_l = y_c - 0.5 * (self.parameters.arguments[\"label_height_to_orf_height\"] * orf_height)\n        canvas.drawRightString(self.visualisation_data[\"coordinate_system\"][\"x_labels_stop\"], y_l,\n                               self.visualisation_data[\"useq_label\"])\n\n        # main_CDS\n        canvas.setLineWidth(self.parameters.arguments[\"orf_line_width\"])\n        canvas.setStrokeColorRGB(*uorf4u.methods.get_color(\"cds_seq_stroke_color\", self.parameters.arguments))\n        canvas.setFillColorRGB(*uorf4u.methods.get_color(\"cds_seq_fill_color\", self.parameters.arguments))\n        p = canvas.beginPath()\n        p.moveTo(self.visualisation_data[\"main_CDS_stop_x\"], y_c - orf_height / 2)\n        p.lineTo(self.visualisation_data[\"main_CDS_start_x\"], y_c - orf_height / 2)\n        p.lineTo(self.visualisation_data[\"main_CDS_start_x\"], y_c + orf_height / 2)\n        p.lineTo(self.visualisation_data[\"main_CDS_stop_x\"], y_c + orf_height / 2)\n        canvas.drawPath(p, stroke=1, fill=1)\n        # Other ORFs:\n        for orf in self.visualisation_data[\"annotated_orfs\"]:\n            orf_dict = self.visualisation_data[\"orfs_coordinates_dict\"][orf]\n            if orf != self.visualisation_data[\"conserved_orf\"]:\n                fill_color = None\n                stroke_color = uorf4u.methods.get_color(\"other_uorfs_stroke_color\", self.parameters.arguments)\n\n            else:\n                fill_color = uorf4u.methods.get_color(\"conserved_uorfs_fill_color\", self.parameters.arguments)\n                stroke_color = uorf4u.methods.get_color(\"conserved_uorfs_stroke_color\", self.parameters.arguments)\n            self.orf_object(canvas, orf_dict[\"x_start\"], orf_dict[\"x_stop\"], y_c, orf_dict[\"strand\"], orf_height,\n                            orf_dict[\"left_out\"], orf_dict[\"right_out\"], fill_color, stroke_color)\n\n        # Annotated in RefSeq CDSs\n        if self.parameters.arguments[\"check_assembly_annotation\"] and \\\n                \"fasta\" not in self.parameters.cmd_arguments.keys():\n            fill_color = None\n            stroke_color = uorf4u.methods.get_color(\"annotated_orf_stroke_color\", self.parameters.arguments)\n            for protein_id, cds_dict in self.visualisation_data[\"CDSs_coordinates_dict\"].items():\n                self.orf_object(canvas, cds_dict[\"x_start\"], cds_dict[\"x_stop\"], y_c, cds_dict[\"strand\"], orf_height,\n                                cds_dict[\"left_out\"], cds_dict[\"right_out\"], fill_color, stroke_color)\n        return None\n\n    def orf_object(self, canvas: reportlab.pdfgen.canvas.Canvas, x_start: float, x_stop: float, y_c: float, strand: str,\n                   height: float, left_out: bool, right_out: bool, fill_color: str, stroke_color: str) -&gt; None:\n        \"\"\"Method for drawing an ORF's polygon.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n            x_start (float): ORF's start coordinate (already transformed to pdf's)\n            x_stop (float): ORF's stop coordinate (already transformed to pdf's)\n            y_c: (float): centred y coordinate of a current track.\n            strand (str): strand of an ORF.\n            height (float): height of a polygon.\n            left_out (bool): whether an ORF is out of range on the left.\n            right_out (bool): whether an ORF is out of range on the right.\n            fill_color (str): fill color of a polygon.\n            stroke_color (str): stroke color of a polygon.\n\n        Returns:\n            None\n        \"\"\"\n        fill, stroke = 0, 0\n        if stroke_color:\n            canvas.setStrokeColorRGB(*stroke_color)\n            stroke = 1\n        if fill_color:\n            canvas.setFillColorRGB(*fill_color)\n            fill = 1\n        arrow_length = min(height, (x_stop - x_start))\n        p = canvas.beginPath()\n        if strand == \"+\" and not left_out and not right_out:\n            p.moveTo(x_start, y_c)\n            p.lineTo(x_start, y_c + height / 2)\n            p.lineTo(x_stop - arrow_length, y_c + height / 2)\n            p.lineTo(x_stop, y_c)\n            p.lineTo(x_stop - arrow_length, y_c - height / 2)\n            p.lineTo(x_start, y_c - height / 2)\n            p.lineTo(x_start, y_c)\n        elif strand == \"+\" and left_out and not right_out:\n            p.moveTo(x_start, y_c + height / 2)\n            p.lineTo(x_stop - arrow_length, y_c + height / 2)\n            p.lineTo(x_stop, y_c)\n            p.lineTo(x_stop - arrow_length, y_c - height / 2)\n            p.lineTo(x_start, y_c - height / 2)\n        elif strand == \"+\" and right_out and not left_out:\n            p.moveTo(x_stop, y_c + height / 2)\n            p.lineTo(x_start, y_c + height / 2)\n            p.lineTo(x_start, y_c - height / 2)\n            p.lineTo(x_stop, y_c - height / 2)\n        elif strand == \"-\" and not left_out and not right_out:\n            p.moveTo(x_stop, y_c)\n            p.lineTo(x_stop, y_c + height / 2)\n            p.lineTo(x_start + arrow_length, y_c + height / 2)\n            p.lineTo(x_start, y_c)\n            p.lineTo(x_start + arrow_length, y_c - height / 2)\n            p.lineTo(x_stop, y_c - height / 2)\n            p.lineTo(x_stop, y_c)\n        elif strand == \"-\" and right_out and not left_out:\n            p.moveTo(x_stop, y_c + height / 2)\n            p.lineTo(x_start + arrow_length, y_c + height / 2)\n            p.lineTo(x_start, y_c)\n            p.lineTo(x_start + arrow_length, y_c - height / 2)\n            p.lineTo(x_stop, y_c - height / 2)\n        elif strand == \"-\" and left_out and not right_out:\n            p.moveTo(x_start, y_c + height / 2)\n            p.lineTo(x_stop, y_c + height / 2)\n            p.lineTo(x_stop, y_c - height / 2)\n            p.lineTo(x_start, y_c - height / 2)\n        canvas.drawPath(p, stroke=stroke, fill=fill)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequenceVis.__init__","title":"<code>__init__(visualisation_data, parameters)</code>","text":"<p>Create a SequenceVis object.</p> <p>Parameters:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n    \"\"\"Create a SequenceVis object.\n\n    Arguments:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(visualisation_data, parameters)\n    self.needed_space = None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequenceVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a Sequence track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a pdf object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a Sequence track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n    Returns:\n        None\n\n    \"\"\"\n    orf_height = self.parameters.arguments[\"orf_height\"] * cm\n    y_c = self.visualisation_data[\"y_top\"] - 0.5 * orf_height\n    x_offset = 0.5 * self.parameters.arguments[\"upstream_seq_line_width\"]\n    canvas.setStrokeColorRGB(*uorf4u.methods.get_color(\"upstream_seq_line_color\", self.parameters.arguments))\n    canvas.setLineCap(0)\n    canvas.setLineWidth(self.parameters.arguments[\"upstream_seq_line_width\"])\n    canvas.line(self.visualisation_data[\"upstream_sequence_line_start_x\"], y_c,\n                self.visualisation_data[\"upstream_sequence_line_stop_x\"] - x_offset, y_c)\n    # Cleaning the space:\n    canvas.setFillColorRGB\n    canvas.setStrokeColorRGB(1, 1, 1, 1)\n\n    for orf_dict in self.visualisation_data[\"orfs_coordinates_dict\"].values():\n\n        canvas.setLineWidth(self.parameters.arguments[\"upstream_seq_line_width\"]*1.5)\n        canvas.line(orf_dict[\"x_start\"], y_c, orf_dict[\"x_stop\"], y_c)\n        #canvas.rect(orf_dict[\"x_start\"], y_c - orf_height / 2, orf_dict[\"x_stop\"] - orf_dict[\"x_start\"], orf_height,\n        #            stroke=0, fill=1)\n    if self.parameters.arguments[\"check_assembly_annotation\"] and \\\n            \"fasta\" not in self.parameters.cmd_arguments.keys():\n        for protein_id, cds_dict in self.visualisation_data[\"CDSs_coordinates_dict\"].items():\n            canvas.line(cds_dict[\"x_start\"], y_c, cds_dict[\"x_stop\"], y_c)\n    canvas.setLineWidth(self.parameters.arguments[\"upstream_seq_line_width\"])\n\n    # Labels\n    canvas.setFillColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n    canvas.setFont(\"regular\", self.visualisation_data[\"label_font_size\"])\n    y_l = y_c - 0.5 * (self.parameters.arguments[\"label_height_to_orf_height\"] * orf_height)\n    canvas.drawRightString(self.visualisation_data[\"coordinate_system\"][\"x_labels_stop\"], y_l,\n                           self.visualisation_data[\"useq_label\"])\n\n    # main_CDS\n    canvas.setLineWidth(self.parameters.arguments[\"orf_line_width\"])\n    canvas.setStrokeColorRGB(*uorf4u.methods.get_color(\"cds_seq_stroke_color\", self.parameters.arguments))\n    canvas.setFillColorRGB(*uorf4u.methods.get_color(\"cds_seq_fill_color\", self.parameters.arguments))\n    p = canvas.beginPath()\n    p.moveTo(self.visualisation_data[\"main_CDS_stop_x\"], y_c - orf_height / 2)\n    p.lineTo(self.visualisation_data[\"main_CDS_start_x\"], y_c - orf_height / 2)\n    p.lineTo(self.visualisation_data[\"main_CDS_start_x\"], y_c + orf_height / 2)\n    p.lineTo(self.visualisation_data[\"main_CDS_stop_x\"], y_c + orf_height / 2)\n    canvas.drawPath(p, stroke=1, fill=1)\n    # Other ORFs:\n    for orf in self.visualisation_data[\"annotated_orfs\"]:\n        orf_dict = self.visualisation_data[\"orfs_coordinates_dict\"][orf]\n        if orf != self.visualisation_data[\"conserved_orf\"]:\n            fill_color = None\n            stroke_color = uorf4u.methods.get_color(\"other_uorfs_stroke_color\", self.parameters.arguments)\n\n        else:\n            fill_color = uorf4u.methods.get_color(\"conserved_uorfs_fill_color\", self.parameters.arguments)\n            stroke_color = uorf4u.methods.get_color(\"conserved_uorfs_stroke_color\", self.parameters.arguments)\n        self.orf_object(canvas, orf_dict[\"x_start\"], orf_dict[\"x_stop\"], y_c, orf_dict[\"strand\"], orf_height,\n                        orf_dict[\"left_out\"], orf_dict[\"right_out\"], fill_color, stroke_color)\n\n    # Annotated in RefSeq CDSs\n    if self.parameters.arguments[\"check_assembly_annotation\"] and \\\n            \"fasta\" not in self.parameters.cmd_arguments.keys():\n        fill_color = None\n        stroke_color = uorf4u.methods.get_color(\"annotated_orf_stroke_color\", self.parameters.arguments)\n        for protein_id, cds_dict in self.visualisation_data[\"CDSs_coordinates_dict\"].items():\n            self.orf_object(canvas, cds_dict[\"x_start\"], cds_dict[\"x_stop\"], y_c, cds_dict[\"strand\"], orf_height,\n                            cds_dict[\"left_out\"], cds_dict[\"right_out\"], fill_color, stroke_color)\n    return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequenceVis.needed_y_space","title":"<code>needed_y_space()</code>","text":"<p>Calculate needed vertical space for a SequenceVis track.</p> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>needed vertical space.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def needed_y_space(self) -&gt; float:\n    \"\"\"Calculate needed vertical space for a SequenceVis track.\n\n    Returns:\n        float: needed vertical space.\n\n    \"\"\"\n    self.needed_space = self.parameters.arguments[\"orf_height\"] * cm\n    return self.needed_space\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequenceVis.orf_object","title":"<code>orf_object(canvas, x_start, x_stop, y_c, strand, height, left_out, right_out, fill_color, stroke_color)</code>","text":"<p>Method for drawing an ORF's polygon.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a pdf object.</p> </li> <li> <code>x_start</code>             (<code>float</code>)         \u2013          <p>ORF's start coordinate (already transformed to pdf's)</p> </li> <li> <code>x_stop</code>             (<code>float</code>)         \u2013          <p>ORF's stop coordinate (already transformed to pdf's)</p> </li> <li> <code>y_c</code>             (<code>float</code>)         \u2013          <p>(float): centred y coordinate of a current track.</p> </li> <li> <code>strand</code>             (<code>str</code>)         \u2013          <p>strand of an ORF.</p> </li> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>height of a polygon.</p> </li> <li> <code>left_out</code>             (<code>bool</code>)         \u2013          <p>whether an ORF is out of range on the left.</p> </li> <li> <code>right_out</code>             (<code>bool</code>)         \u2013          <p>whether an ORF is out of range on the right.</p> </li> <li> <code>fill_color</code>             (<code>str</code>)         \u2013          <p>fill color of a polygon.</p> </li> <li> <code>stroke_color</code>             (<code>str</code>)         \u2013          <p>stroke color of a polygon.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def orf_object(self, canvas: reportlab.pdfgen.canvas.Canvas, x_start: float, x_stop: float, y_c: float, strand: str,\n               height: float, left_out: bool, right_out: bool, fill_color: str, stroke_color: str) -&gt; None:\n    \"\"\"Method for drawing an ORF's polygon.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n        x_start (float): ORF's start coordinate (already transformed to pdf's)\n        x_stop (float): ORF's stop coordinate (already transformed to pdf's)\n        y_c: (float): centred y coordinate of a current track.\n        strand (str): strand of an ORF.\n        height (float): height of a polygon.\n        left_out (bool): whether an ORF is out of range on the left.\n        right_out (bool): whether an ORF is out of range on the right.\n        fill_color (str): fill color of a polygon.\n        stroke_color (str): stroke color of a polygon.\n\n    Returns:\n        None\n    \"\"\"\n    fill, stroke = 0, 0\n    if stroke_color:\n        canvas.setStrokeColorRGB(*stroke_color)\n        stroke = 1\n    if fill_color:\n        canvas.setFillColorRGB(*fill_color)\n        fill = 1\n    arrow_length = min(height, (x_stop - x_start))\n    p = canvas.beginPath()\n    if strand == \"+\" and not left_out and not right_out:\n        p.moveTo(x_start, y_c)\n        p.lineTo(x_start, y_c + height / 2)\n        p.lineTo(x_stop - arrow_length, y_c + height / 2)\n        p.lineTo(x_stop, y_c)\n        p.lineTo(x_stop - arrow_length, y_c - height / 2)\n        p.lineTo(x_start, y_c - height / 2)\n        p.lineTo(x_start, y_c)\n    elif strand == \"+\" and left_out and not right_out:\n        p.moveTo(x_start, y_c + height / 2)\n        p.lineTo(x_stop - arrow_length, y_c + height / 2)\n        p.lineTo(x_stop, y_c)\n        p.lineTo(x_stop - arrow_length, y_c - height / 2)\n        p.lineTo(x_start, y_c - height / 2)\n    elif strand == \"+\" and right_out and not left_out:\n        p.moveTo(x_stop, y_c + height / 2)\n        p.lineTo(x_start, y_c + height / 2)\n        p.lineTo(x_start, y_c - height / 2)\n        p.lineTo(x_stop, y_c - height / 2)\n    elif strand == \"-\" and not left_out and not right_out:\n        p.moveTo(x_stop, y_c)\n        p.lineTo(x_stop, y_c + height / 2)\n        p.lineTo(x_start + arrow_length, y_c + height / 2)\n        p.lineTo(x_start, y_c)\n        p.lineTo(x_start + arrow_length, y_c - height / 2)\n        p.lineTo(x_stop, y_c - height / 2)\n        p.lineTo(x_stop, y_c)\n    elif strand == \"-\" and right_out and not left_out:\n        p.moveTo(x_stop, y_c + height / 2)\n        p.lineTo(x_start + arrow_length, y_c + height / 2)\n        p.lineTo(x_start, y_c)\n        p.lineTo(x_start + arrow_length, y_c - height / 2)\n        p.lineTo(x_stop, y_c - height / 2)\n    elif strand == \"-\" and left_out and not right_out:\n        p.moveTo(x_start, y_c + height / 2)\n        p.lineTo(x_stop, y_c + height / 2)\n        p.lineTo(x_stop, y_c - height / 2)\n        p.lineTo(x_start, y_c - height / 2)\n    canvas.drawPath(p, stroke=stroke, fill=fill)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequencesLoader","title":"<code>SequencesLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A SequencesLoader object prepares data for a Sequence track object.</p> <p>Attributes:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>prepared_data</code>             (<code>dict</code>)         \u2013          <p>dict with data needed for a visualisation track.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class SequencesLoader(Loader):\n    \"\"\"A SequencesLoader object prepares data for a Sequence track object.\n\n\n    Attributes:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        prepared_data (dict): dict with data needed for a visualisation track.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a SequenceLoader object.\n\n        Arguments:\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_data(self, upstream_sequence: Bio.SeqRecord.SeqRecord, conserved_orf, coordinate_system: dict,\n                     additional_data: dict) -&gt; dict:\n        \"\"\"Prepare data for a Title visualisation track.\n\n        Attributes:\n            upstream_sequence (dict): upstream sequence' data.\n            conserved_orf (uorf4u.data_processing.ORF): conserved ORF on the upstream sequence.\n            coordinate_system (dict): coordinate system of a figure page.\n            additional_data (dict): data needed for a track initialisation.\n\n        Returns:\n            dict: dictionary with prepared data for visualisation.\n\n        \"\"\"\n        prepared_data = dict()\n        max_upstream_sequence_length = additional_data[\"max_upstream_sequence_length\"]\n        prepared_data[\"coordinate_system\"] = coordinate_system\n        prepared_data[\"label_font_size\"] = additional_data[\"label_font_size\"]\n        prepared_data[\"label_right_border\"] = coordinate_system[\"x_labels_stop\"]\n        prepared_data[\"upstream_sequence_line_start_x\"] = coordinate_system[\"x_annotation_start\"] + \\\n                                                          ((max_upstream_sequence_length -\n                                                            upstream_sequence.annotations[\"upstream_region_length\"]) * \\\n                                                           coordinate_system[\"transformation_coef\"])\n        prepared_data[\"upstream_sequence_line_stop_x\"] = coordinate_system[\"x_annotation_start\"] + \\\n                                                         (max_upstream_sequence_length *\n                                                          coordinate_system[\"transformation_coef\"])\n        prepared_data[\"main_CDS_start_x\"] = coordinate_system[\"x_annotation_start\"] + \\\n                                            (max_upstream_sequence_length *\n                                             coordinate_system[\"transformation_coef\"])\n        prepared_data[\"main_CDS_stop_x\"] = coordinate_system[\"x_annotation_start\"] + \\\n                                           ((max_upstream_sequence_length +\n                                             upstream_sequence.annotations[\"downstream_region_length\"]) *\n                                            coordinate_system[\"transformation_coef\"])\n\n        prepared_data[\"orfs_coordinates_dict\"] = {k: v for k, v in\n                                                  zip(upstream_sequence.annotations[\"ORFs\"],\n                                                      [self.calculate_orf_position(i.start, i.stop, \"+\",\n                                                                                   upstream_sequence,\n                                                                                   max_upstream_sequence_length,\n                                                                                   coordinate_system) for i in\n                                                       upstream_sequence.annotations[\"ORFs\"]])}\n        prepared_data[\"useq_label\"] = upstream_sequence.annotations[\"label\"]\n        prepared_data[\"annotated_orfs\"] = [orf for orf in upstream_sequence.annotations[\"ORFs\"] if orf != conserved_orf]\n        prepared_data[\"annotated_orfs\"].append(conserved_orf)\n        prepared_data[\"conserved_orf\"] = conserved_orf\n        if self.parameters.arguments[\"check_assembly_annotation\"] and upstream_sequence.annotations[\"RefSeq\"]:\n            prepared_data[\"CDSs\"] = [i for i in upstream_sequence.annotations[\"locus_annotation\"].CDSs if\n                                     i[\"relative_start\"] != upstream_sequence.annotations[\"upstream_region_length\"]]\n            prepared_data[\"CDSs_coordinates_dict\"] = {k: v for k, v in\n                                                      zip([i[\"protein_id\"] for i in\n                                                           prepared_data[\"CDSs\"]],\n                                                          [self.calculate_orf_position(i[\"relative_start\"],\n                                                                                       i[\"relative_stop\"],\n                                                                                       i[\"relative_strand\"],\n                                                                                       upstream_sequence,\n                                                                                       max_upstream_sequence_length,\n                                                                                       coordinate_system) for i in\n                                                           prepared_data[\"CDSs\"]])}\n        else:\n            prepared_data[\"CDSs\"] = None\n        self.prepared_data = prepared_data\n\n        return prepared_data\n\n    def calculate_orf_position(self, start: int, stop: int, strand: str, useq: Bio.SeqRecord.SeqRecord,\n                               max_upstream_sequence_length: int, coordinate_system: dict) -&gt; dict:\n        \"\"\"Transform an ORF's nucleotide coordinates to pdf's coordinates.\n\n        Arguments:\n            start (int): start coordinate in nt.\n            stop (int): stop coordinate in nt.\n            strand (str): strand of an ORF.\n            useq (dict): current upstream sequence.\n            max_upstream_sequence_length (int): max length of upstream sequences for visualisation.\n            coordinate_system (dict): coordinate system of a figure.\n\n        Returns:\n            dict: transformed orf's coordinates.\n        \"\"\"\n        orf_coordinates = dict()\n        orf_coordinates[\"x_start\"] = coordinate_system[\"x_annotation_start\"] + (\n                max(0, start) + (max_upstream_sequence_length - useq.annotations[\"upstream_region_length\"])) * \\\n                                     coordinate_system[\"transformation_coef\"]\n        orf_coordinates[\"x_stop\"] = coordinate_system[\"x_annotation_start\"] + (\n                min(stop, useq.annotations[\"length\"]) + (\n                max_upstream_sequence_length - useq.annotations[\"upstream_region_length\"])) * \\\n                                    coordinate_system[\"transformation_coef\"]\n        orf_coordinates[\"strand\"] = strand\n        orf_coordinates[\"left_out\"] = start &lt; 0\n        orf_coordinates[\"right_out\"] = stop &gt; useq.annotations[\"length\"]\n        return orf_coordinates\n\n    def create_track(self) -&gt; SequenceVis:\n        \"\"\"Initialise a Sequence track object.\n\n        Returns:\n            SequenceVis: visualisation track.\n\n        \"\"\"\n        return SequenceVis(self.prepared_data, self.parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequencesLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a SequenceLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a SequenceLoader object.\n\n    Arguments:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequencesLoader.calculate_orf_position","title":"<code>calculate_orf_position(start, stop, strand, useq, max_upstream_sequence_length, coordinate_system)</code>","text":"<p>Transform an ORF's nucleotide coordinates to pdf's coordinates.</p> <p>Parameters:</p> <ul> <li> <code>start</code>             (<code>int</code>)         \u2013          <p>start coordinate in nt.</p> </li> <li> <code>stop</code>             (<code>int</code>)         \u2013          <p>stop coordinate in nt.</p> </li> <li> <code>strand</code>             (<code>str</code>)         \u2013          <p>strand of an ORF.</p> </li> <li> <code>useq</code>             (<code>dict</code>)         \u2013          <p>current upstream sequence.</p> </li> <li> <code>max_upstream_sequence_length</code>             (<code>int</code>)         \u2013          <p>max length of upstream sequences for visualisation.</p> </li> <li> <code>coordinate_system</code>             (<code>dict</code>)         \u2013          <p>coordinate system of a figure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>transformed orf's coordinates.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def calculate_orf_position(self, start: int, stop: int, strand: str, useq: Bio.SeqRecord.SeqRecord,\n                           max_upstream_sequence_length: int, coordinate_system: dict) -&gt; dict:\n    \"\"\"Transform an ORF's nucleotide coordinates to pdf's coordinates.\n\n    Arguments:\n        start (int): start coordinate in nt.\n        stop (int): stop coordinate in nt.\n        strand (str): strand of an ORF.\n        useq (dict): current upstream sequence.\n        max_upstream_sequence_length (int): max length of upstream sequences for visualisation.\n        coordinate_system (dict): coordinate system of a figure.\n\n    Returns:\n        dict: transformed orf's coordinates.\n    \"\"\"\n    orf_coordinates = dict()\n    orf_coordinates[\"x_start\"] = coordinate_system[\"x_annotation_start\"] + (\n            max(0, start) + (max_upstream_sequence_length - useq.annotations[\"upstream_region_length\"])) * \\\n                                 coordinate_system[\"transformation_coef\"]\n    orf_coordinates[\"x_stop\"] = coordinate_system[\"x_annotation_start\"] + (\n            min(stop, useq.annotations[\"length\"]) + (\n            max_upstream_sequence_length - useq.annotations[\"upstream_region_length\"])) * \\\n                                coordinate_system[\"transformation_coef\"]\n    orf_coordinates[\"strand\"] = strand\n    orf_coordinates[\"left_out\"] = start &lt; 0\n    orf_coordinates[\"right_out\"] = stop &gt; useq.annotations[\"length\"]\n    return orf_coordinates\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequencesLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a Sequence track object.</p> <p>Returns:</p> <ul> <li> <code>SequenceVis</code> (            <code>SequenceVis</code> )        \u2013          <p>visualisation track.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def create_track(self) -&gt; SequenceVis:\n    \"\"\"Initialise a Sequence track object.\n\n    Returns:\n        SequenceVis: visualisation track.\n\n    \"\"\"\n    return SequenceVis(self.prepared_data, self.parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.SequencesLoader.prepare_data","title":"<code>prepare_data(upstream_sequence, conserved_orf, coordinate_system, additional_data)</code>","text":"<p>Prepare data for a Title visualisation track.</p> <p>Attributes:</p> <ul> <li> <code>upstream_sequence</code>             (<code>dict</code>)         \u2013          <p>upstream sequence' data.</p> </li> <li> <code>conserved_orf</code>             (<code>ORF</code>)         \u2013          <p>conserved ORF on the upstream sequence.</p> </li> <li> <code>coordinate_system</code>             (<code>dict</code>)         \u2013          <p>coordinate system of a figure page.</p> </li> <li> <code>additional_data</code>             (<code>dict</code>)         \u2013          <p>data needed for a track initialisation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>dictionary with prepared data for visualisation.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def prepare_data(self, upstream_sequence: Bio.SeqRecord.SeqRecord, conserved_orf, coordinate_system: dict,\n                 additional_data: dict) -&gt; dict:\n    \"\"\"Prepare data for a Title visualisation track.\n\n    Attributes:\n        upstream_sequence (dict): upstream sequence' data.\n        conserved_orf (uorf4u.data_processing.ORF): conserved ORF on the upstream sequence.\n        coordinate_system (dict): coordinate system of a figure page.\n        additional_data (dict): data needed for a track initialisation.\n\n    Returns:\n        dict: dictionary with prepared data for visualisation.\n\n    \"\"\"\n    prepared_data = dict()\n    max_upstream_sequence_length = additional_data[\"max_upstream_sequence_length\"]\n    prepared_data[\"coordinate_system\"] = coordinate_system\n    prepared_data[\"label_font_size\"] = additional_data[\"label_font_size\"]\n    prepared_data[\"label_right_border\"] = coordinate_system[\"x_labels_stop\"]\n    prepared_data[\"upstream_sequence_line_start_x\"] = coordinate_system[\"x_annotation_start\"] + \\\n                                                      ((max_upstream_sequence_length -\n                                                        upstream_sequence.annotations[\"upstream_region_length\"]) * \\\n                                                       coordinate_system[\"transformation_coef\"])\n    prepared_data[\"upstream_sequence_line_stop_x\"] = coordinate_system[\"x_annotation_start\"] + \\\n                                                     (max_upstream_sequence_length *\n                                                      coordinate_system[\"transformation_coef\"])\n    prepared_data[\"main_CDS_start_x\"] = coordinate_system[\"x_annotation_start\"] + \\\n                                        (max_upstream_sequence_length *\n                                         coordinate_system[\"transformation_coef\"])\n    prepared_data[\"main_CDS_stop_x\"] = coordinate_system[\"x_annotation_start\"] + \\\n                                       ((max_upstream_sequence_length +\n                                         upstream_sequence.annotations[\"downstream_region_length\"]) *\n                                        coordinate_system[\"transformation_coef\"])\n\n    prepared_data[\"orfs_coordinates_dict\"] = {k: v for k, v in\n                                              zip(upstream_sequence.annotations[\"ORFs\"],\n                                                  [self.calculate_orf_position(i.start, i.stop, \"+\",\n                                                                               upstream_sequence,\n                                                                               max_upstream_sequence_length,\n                                                                               coordinate_system) for i in\n                                                   upstream_sequence.annotations[\"ORFs\"]])}\n    prepared_data[\"useq_label\"] = upstream_sequence.annotations[\"label\"]\n    prepared_data[\"annotated_orfs\"] = [orf for orf in upstream_sequence.annotations[\"ORFs\"] if orf != conserved_orf]\n    prepared_data[\"annotated_orfs\"].append(conserved_orf)\n    prepared_data[\"conserved_orf\"] = conserved_orf\n    if self.parameters.arguments[\"check_assembly_annotation\"] and upstream_sequence.annotations[\"RefSeq\"]:\n        prepared_data[\"CDSs\"] = [i for i in upstream_sequence.annotations[\"locus_annotation\"].CDSs if\n                                 i[\"relative_start\"] != upstream_sequence.annotations[\"upstream_region_length\"]]\n        prepared_data[\"CDSs_coordinates_dict\"] = {k: v for k, v in\n                                                  zip([i[\"protein_id\"] for i in\n                                                       prepared_data[\"CDSs\"]],\n                                                      [self.calculate_orf_position(i[\"relative_start\"],\n                                                                                   i[\"relative_stop\"],\n                                                                                   i[\"relative_strand\"],\n                                                                                   upstream_sequence,\n                                                                                   max_upstream_sequence_length,\n                                                                                   coordinate_system) for i in\n                                                       prepared_data[\"CDSs\"]])}\n    else:\n        prepared_data[\"CDSs\"] = None\n    self.prepared_data = prepared_data\n\n    return prepared_data\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TicsVis","title":"<code>TicsVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>TicsVis track draws axis tics.</p> <p>Attributes:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>needed_space</code>             (<code>float</code>)         \u2013          <p>needed vertical space for a track.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class TicsVis(Track):\n    \"\"\"TicsVis track draws axis tics.\n\n    Attributes:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        needed_space (float): needed vertical space for a track.\n\n    \"\"\"\n\n    def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n        \"\"\"Create a TicsVis object.\n\n        Arguments:\n            visualisation_data (dict): a dictionary with data needed for visualisation.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(visualisation_data, parameters)\n        self.needed_space = None\n\n    def needed_y_space(self) -&gt; float:\n        \"\"\"Calculate needed vertical space for a SequenceVis track.\n\n        Returns:\n            float: needed vertical space.\n\n        \"\"\"\n        font_type = \"regular\"\n        reportlab.pdfbase.pdfmetrics.registerFont(\n            reportlab.pdfbase.ttfonts.TTFont(font_type, self.parameters.arguments[f\"font_{font_type}\"]))\n        face = reportlab.pdfbase.pdfmetrics.getFont(\"regular\").face\n        if self.parameters.arguments[\"axis_tics_font_size\"] == \"auto\":\n            text_height = self.parameters.arguments[\"label_height_to_orf_height\"] * self.parameters.arguments[\n                \"orf_height\"] * cm\n            font_size = uorf4u.methods.string_height_to_font_size(text_height, \"regular\", self.parameters.arguments)\n            self.parameters.arguments[\"axis_tics_font_size\"] = font_size\n        else:\n            text_height = (self.parameters.arguments[\"axis_tics_font_size\"] * (face.ascent - face.descent)) / (\n                    1000 * 1.38)\n        self.visualisation_data[\"tics_height\"] = 0.7 * text_height\n        self.visualisation_data[\"text_space\"] = 1.2 * text_height\n        self.needed_space = self.visualisation_data[\"tics_height\"] + self.visualisation_data[\"text_space\"]\n        return self.needed_space\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw an AxisTics track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n        Returns:\n            None\n\n        \"\"\"\n        y_top = self.visualisation_data[\"y_top\"]\n        canvas.setLineCap(2)\n        canvas.setLineWidth(self.parameters.arguments[\"axis_tics_line_width\"])\n        canvas.setStrokeColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n        canvas.setFillColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n        canvas.setFont(\"regular\", self.parameters.arguments[\"axis_tics_font_size\"])\n        canvas.line(self.visualisation_data[\"coordinate_system\"][\"x_annotation_start\"], y_top,\n                    self.visualisation_data[\"coordinate_system\"][\"x_annotation_stop\"], y_top)\n        for tic_label, tic_position in self.visualisation_data[\"tics\"].items():\n            canvas.line(tic_position, y_top, tic_position, y_top - self.visualisation_data[\"tics_height\"])\n            if tic_label == -self.visualisation_data[\"max_upstream_sequence_length\"]:\n                canvas.drawString(tic_position,\n                                  y_top - (self.visualisation_data[\"tics_height\"] + self.visualisation_data[\n                                      \"text_space\"]), str(tic_label))\n            elif tic_label == self.visualisation_data[\"max_downstream_sequence_length\"]:\n                canvas.drawRightString(tic_position,\n                                       y_top - (self.visualisation_data[\"tics_height\"] + self.visualisation_data[\n                                           \"text_space\"]), str(tic_label))\n            else:\n                canvas.drawCentredString(tic_position,\n                                         y_top - (self.visualisation_data[\"tics_height\"] + self.visualisation_data[\n                                             \"text_space\"]), str(tic_label))\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TicsVis.__init__","title":"<code>__init__(visualisation_data, parameters)</code>","text":"<p>Create a TicsVis object.</p> <p>Parameters:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n    \"\"\"Create a TicsVis object.\n\n    Arguments:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(visualisation_data, parameters)\n    self.needed_space = None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TicsVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw an AxisTics track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a pdf object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw an AxisTics track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n    Returns:\n        None\n\n    \"\"\"\n    y_top = self.visualisation_data[\"y_top\"]\n    canvas.setLineCap(2)\n    canvas.setLineWidth(self.parameters.arguments[\"axis_tics_line_width\"])\n    canvas.setStrokeColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n    canvas.setFillColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n    canvas.setFont(\"regular\", self.parameters.arguments[\"axis_tics_font_size\"])\n    canvas.line(self.visualisation_data[\"coordinate_system\"][\"x_annotation_start\"], y_top,\n                self.visualisation_data[\"coordinate_system\"][\"x_annotation_stop\"], y_top)\n    for tic_label, tic_position in self.visualisation_data[\"tics\"].items():\n        canvas.line(tic_position, y_top, tic_position, y_top - self.visualisation_data[\"tics_height\"])\n        if tic_label == -self.visualisation_data[\"max_upstream_sequence_length\"]:\n            canvas.drawString(tic_position,\n                              y_top - (self.visualisation_data[\"tics_height\"] + self.visualisation_data[\n                                  \"text_space\"]), str(tic_label))\n        elif tic_label == self.visualisation_data[\"max_downstream_sequence_length\"]:\n            canvas.drawRightString(tic_position,\n                                   y_top - (self.visualisation_data[\"tics_height\"] + self.visualisation_data[\n                                       \"text_space\"]), str(tic_label))\n        else:\n            canvas.drawCentredString(tic_position,\n                                     y_top - (self.visualisation_data[\"tics_height\"] + self.visualisation_data[\n                                         \"text_space\"]), str(tic_label))\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TicsVis.needed_y_space","title":"<code>needed_y_space()</code>","text":"<p>Calculate needed vertical space for a SequenceVis track.</p> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>needed vertical space.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def needed_y_space(self) -&gt; float:\n    \"\"\"Calculate needed vertical space for a SequenceVis track.\n\n    Returns:\n        float: needed vertical space.\n\n    \"\"\"\n    font_type = \"regular\"\n    reportlab.pdfbase.pdfmetrics.registerFont(\n        reportlab.pdfbase.ttfonts.TTFont(font_type, self.parameters.arguments[f\"font_{font_type}\"]))\n    face = reportlab.pdfbase.pdfmetrics.getFont(\"regular\").face\n    if self.parameters.arguments[\"axis_tics_font_size\"] == \"auto\":\n        text_height = self.parameters.arguments[\"label_height_to_orf_height\"] * self.parameters.arguments[\n            \"orf_height\"] * cm\n        font_size = uorf4u.methods.string_height_to_font_size(text_height, \"regular\", self.parameters.arguments)\n        self.parameters.arguments[\"axis_tics_font_size\"] = font_size\n    else:\n        text_height = (self.parameters.arguments[\"axis_tics_font_size\"] * (face.ascent - face.descent)) / (\n                1000 * 1.38)\n    self.visualisation_data[\"tics_height\"] = 0.7 * text_height\n    self.visualisation_data[\"text_space\"] = 1.2 * text_height\n    self.needed_space = self.visualisation_data[\"tics_height\"] + self.visualisation_data[\"text_space\"]\n    return self.needed_space\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TitleLoader","title":"<code>TitleLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A TitleLoader object prepares data for a Title track object.</p> Note <p>Title track currently is not available.</p> <p>Attributes:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>prepared_data</code>             (<code>dict</code>)         \u2013          <p>dict with data needed for a visualisation track.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class TitleLoader(Loader):\n    \"\"\"A TitleLoader object prepares data for a Title track object.\n\n    Note:\n        Title track currently is not available.\n\n    Attributes:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        prepared_data (dict): dict with data needed for a visualisation track.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a TitleLoader object.\n\n        Arguments:\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_data(self, coordinate_system: dict, additional_data: dict) -&gt; dict:\n        \"\"\"Prepare data for Title visualisation track.\n\n        Attributes:\n            coordinate_system (dict): coordinate system of a figure page.\n            additional_data (dict): data needed for a track initialisation.\n\n        Returns:\n            dict: dictionary with prepared data for visualisation.\n\n        \"\"\"\n        prepared_data = dict()\n        prepared_data[\"title\"] = \"Title Testing\"\n        prepared_data[\"coordinate_system\"] = coordinate_system\n        self.prepared_data = prepared_data\n        return prepared_data\n\n    def create_track(self) -&gt; TitleVis:\n        \"\"\"Initialise a Title track object.\n\n        Returns:\n            TitleVis: visualisation track.\n\n        \"\"\"\n        return TitleVis(self.prepared_data, self.parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TitleLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a TitleLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a TitleLoader object.\n\n    Arguments:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TitleLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a Title track object.</p> <p>Returns:</p> <ul> <li> <code>TitleVis</code> (            <code>TitleVis</code> )        \u2013          <p>visualisation track.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def create_track(self) -&gt; TitleVis:\n    \"\"\"Initialise a Title track object.\n\n    Returns:\n        TitleVis: visualisation track.\n\n    \"\"\"\n    return TitleVis(self.prepared_data, self.parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TitleLoader.prepare_data","title":"<code>prepare_data(coordinate_system, additional_data)</code>","text":"<p>Prepare data for Title visualisation track.</p> <p>Attributes:</p> <ul> <li> <code>coordinate_system</code>             (<code>dict</code>)         \u2013          <p>coordinate system of a figure page.</p> </li> <li> <code>additional_data</code>             (<code>dict</code>)         \u2013          <p>data needed for a track initialisation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>dictionary with prepared data for visualisation.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def prepare_data(self, coordinate_system: dict, additional_data: dict) -&gt; dict:\n    \"\"\"Prepare data for Title visualisation track.\n\n    Attributes:\n        coordinate_system (dict): coordinate system of a figure page.\n        additional_data (dict): data needed for a track initialisation.\n\n    Returns:\n        dict: dictionary with prepared data for visualisation.\n\n    \"\"\"\n    prepared_data = dict()\n    prepared_data[\"title\"] = \"Title Testing\"\n    prepared_data[\"coordinate_system\"] = coordinate_system\n    self.prepared_data = prepared_data\n    return prepared_data\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TitleVis","title":"<code>TitleVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>Title visualisation track object draws figure's title.</p> Note <p>This track currently is not supported.</p> <p>Attributes:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class TitleVis(Track):\n    \"\"\"Title visualisation track object draws figure's title.\n\n    Note:\n        This track currently is not supported.\n\n    Attributes:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n        \"\"\"Create TitleVis object.\n\n        Arguments:\n            visualisation_data (dict): a dictionary with data needed for visualisation.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.visualisation_data = visualisation_data\n        self.parameters = parameters\n\n    def needed_y_space(self) -&gt; float:\n        \"\"\"Calculate needed vertical space for a Title track.\n\n        Returns:\n            float: needed vertical space.\n\n        \"\"\"\n        font_type = self.parameters.arguments[\"title_font_type\"]\n        reportlab.pdfbase.pdfmetrics.registerFont(\n            reportlab.pdfbase.ttfonts.TTFont(font_type, self.parameters.arguments[f\"font_{font_type}\"]))\n        face = reportlab.pdfbase.pdfmetrics.getFont(font_type).face\n        if self.parameters.arguments[\"title_font_size\"] == \"auto\":\n            text_height = self.parameters.arguments[\"orf_height\"] * cm\n            font_size = uorf4u.methods.string_height_to_font_size(text_height, font_type, self.parameters.arguments)\n            self.parameters.arguments[\"title_font_size\"] = font_size\n        else:\n            text_height = (self.parameters.arguments[\"title_font_size\"] * (face.ascent - face.descent)) / (\n                    1000 * 1.38)\n        self.visualisation_data[\"text_height\"] = text_height\n        self.needed_space = text_height * 1.2\n        return self.needed_space\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a Title track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n        Returns:\n            None\n\n        \"\"\"\n        x_left_border = self.visualisation_data[\"coordinate_system\"][\"x_labels_start\"]\n        # x_left_border = self.visualisation_data[\"coordinate_system\"][\"x_annotation_start\"]\n        canvas.setFillColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n        canvas.setFont(self.parameters.arguments[\"title_font_type\"], self.parameters.arguments[\"title_font_size\"])\n        canvas.drawString(x_left_border, self.visualisation_data[\"y_top\"] - self.visualisation_data[\"text_height\"],\n                          self.visualisation_data[\"title\"])\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TitleVis.__init__","title":"<code>__init__(visualisation_data, parameters)</code>","text":"<p>Create TitleVis object.</p> <p>Parameters:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n    \"\"\"Create TitleVis object.\n\n    Arguments:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.visualisation_data = visualisation_data\n    self.parameters = parameters\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TitleVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a Title track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a pdf object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a Title track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n    Returns:\n        None\n\n    \"\"\"\n    x_left_border = self.visualisation_data[\"coordinate_system\"][\"x_labels_start\"]\n    # x_left_border = self.visualisation_data[\"coordinate_system\"][\"x_annotation_start\"]\n    canvas.setFillColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n    canvas.setFont(self.parameters.arguments[\"title_font_type\"], self.parameters.arguments[\"title_font_size\"])\n    canvas.drawString(x_left_border, self.visualisation_data[\"y_top\"] - self.visualisation_data[\"text_height\"],\n                      self.visualisation_data[\"title\"])\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.TitleVis.needed_y_space","title":"<code>needed_y_space()</code>","text":"<p>Calculate needed vertical space for a Title track.</p> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>needed vertical space.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def needed_y_space(self) -&gt; float:\n    \"\"\"Calculate needed vertical space for a Title track.\n\n    Returns:\n        float: needed vertical space.\n\n    \"\"\"\n    font_type = self.parameters.arguments[\"title_font_type\"]\n    reportlab.pdfbase.pdfmetrics.registerFont(\n        reportlab.pdfbase.ttfonts.TTFont(font_type, self.parameters.arguments[f\"font_{font_type}\"]))\n    face = reportlab.pdfbase.pdfmetrics.getFont(font_type).face\n    if self.parameters.arguments[\"title_font_size\"] == \"auto\":\n        text_height = self.parameters.arguments[\"orf_height\"] * cm\n        font_size = uorf4u.methods.string_height_to_font_size(text_height, font_type, self.parameters.arguments)\n        self.parameters.arguments[\"title_font_size\"] = font_size\n    else:\n        text_height = (self.parameters.arguments[\"title_font_size\"] * (face.ascent - face.descent)) / (\n                1000 * 1.38)\n    self.visualisation_data[\"text_height\"] = text_height\n    self.needed_space = text_height * 1.2\n    return self.needed_space\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Track","title":"<code>Track</code>","text":"<p>Parent clas for visualisation Tracks.</p> <p>Attributes:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>class Track:\n    \"\"\"Parent clas for visualisation Tracks.\n\n    Attributes:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n        \"\"\"Parent's constructor for creating a Track object.\n\n        Arguments:\n            visualisation_data (dict): a dictionary with data needed for visualisation.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.visualisation_data = visualisation_data\n        self.parameters = parameters\n\n    def needed_y_space(self) -&gt; None:\n        \"\"\"Empy parent's method for calculation needed vertical space for a track.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Empy parent's method for track visualisation.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Track.__init__","title":"<code>__init__(visualisation_data, parameters)</code>","text":"<p>Parent's constructor for creating a Track object.</p> <p>Parameters:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n    \"\"\"Parent's constructor for creating a Track object.\n\n    Arguments:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.visualisation_data = visualisation_data\n    self.parameters = parameters\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Track.draw","title":"<code>draw(canvas)</code>","text":"<p>Empy parent's method for track visualisation.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a pdf object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Empy parent's method for track visualisation.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_annotation.Track.needed_y_space","title":"<code>needed_y_space()</code>","text":"<p>Empy parent's method for calculation needed vertical space for a track.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_annotation.py</code> <pre><code>def needed_y_space(self) -&gt; None:\n    \"\"\"Empy parent's method for calculation needed vertical space for a track.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Image","title":"<code>Image</code>","text":"<p>An Image object holds pdf.</p> <p>Attributes:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>pdf object of the reportlab library.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>class Image:\n    \"\"\"An Image object holds pdf.\n\n    Attributes:\n        canvas (reportlab.pdfgen.canvas.Canvas): pdf object of the reportlab library.\n\n    \"\"\"\n\n    def __init__(self, filename: str, width: float, height: float):\n        \"\"\"Create an Image object.\n\n        Arguments:\n            filename (str): path and name of a pdf.\n            width (float): width of a pdf.\n            height (float): height of a pdf.\n\n        \"\"\"\n        self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n\n    def save(self) -&gt; None:\n        \"\"\"Save a pdf file.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.canvas.save()\n        return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Image.__init__","title":"<code>__init__(filename, width, height)</code>","text":"<p>Create an Image object.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>             (<code>str</code>)         \u2013          <p>path and name of a pdf.</p> </li> <li> <code>width</code>             (<code>float</code>)         \u2013          <p>width of a pdf.</p> </li> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>height of a pdf.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def __init__(self, filename: str, width: float, height: float):\n    \"\"\"Create an Image object.\n\n    Arguments:\n        filename (str): path and name of a pdf.\n        width (float): width of a pdf.\n        height (float): height of a pdf.\n\n    \"\"\"\n    self.canvas = reportlab.pdfgen.canvas.Canvas(filename, pagesize=(width, height))\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Image.save","title":"<code>save()</code>","text":"<p>Save a pdf file.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Save a pdf file.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.canvas.save()\n    return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Loader","title":"<code>Loader</code>","text":"<p>Parent class for tracks loaders.</p> <p>Attributes:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>prepared_data</code>             (<code>dict</code>)         \u2013          <p>dict with data needed for visualisation tracks.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>class Loader:\n    \"\"\"Parent class for tracks loaders.\n\n    Attributes:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        prepared_data (dict): dict with data needed for visualisation tracks.\n\n    \"\"\"\n\n    def __init__(self, parameters: uorf4u.manager.Parameters):\n        \"\"\"Parent's constructor for creating a Loader class object.\n\n        Arguments:\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n        \"\"\"\n        self.parameters = parameters\n        self.prepared_data = None\n\n    def prepare_data(self) -&gt; None:\n        \"\"\"Empty parent's method for data preparation.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def create_track(self) -&gt; None:\n        \"\"\"Empty parent's method for initialisation of a track.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Loader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Parent's constructor for creating a Loader class object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def __init__(self, parameters: uorf4u.manager.Parameters):\n    \"\"\"Parent's constructor for creating a Loader class object.\n\n    Arguments:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n    \"\"\"\n    self.parameters = parameters\n    self.prepared_data = None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Loader.create_track","title":"<code>create_track()</code>","text":"<p>Empty parent's method for initialisation of a track.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def create_track(self) -&gt; None:\n    \"\"\"Empty parent's method for initialisation of a track.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Loader.prepare_data","title":"<code>prepare_data()</code>","text":"<p>Empty parent's method for data preparation.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def prepare_data(self) -&gt; None:\n    \"\"\"Empty parent's method for data preparation.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.MSAPlotManager","title":"<code>MSAPlotManager</code>","text":"<p>AnnotationPlotManager object holds needed information for annotation visualisation and controls it.</p> Note <p>It's supposed that the AnnotationPlotManager' objects will not be used directly by API users since     visualisation can be controlled by 'plot_annotation' method.</p> <p>Attributes:</p> <ul> <li> <code>msa</code>             (<code>FILL IN</code>)         \u2013          <p>Path class' multiple sequence alignment.</p> </li> <li> <code>upstream_sequences</code>             (<code>list</code>)         \u2013          <p>list of dicts with information about upstream sequences.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>coordinate_system</code>             (<code>dict</code>)         \u2013          <p>coordinate system of figure.</p> </li> <li> <code>additional_data</code>             (<code>dict</code>)         \u2013          <p>dict with data for visualisation tracks.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>class MSAPlotManager:\n    \"\"\"\n    AnnotationPlotManager object holds needed information for annotation visualisation and controls it.\n\n    Note:\n        It's supposed that the AnnotationPlotManager' objects will not be used directly by API users since\n            visualisation can be controlled by 'plot_annotation' method.\n\n    Attributes:\n        msa (FILL IN): Path class' multiple sequence alignment.\n        upstream_sequences (list): list of dicts with information about upstream sequences.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        coordinate_system (dict): coordinate system of figure.\n        additional_data (dict): dict with data for visualisation tracks.\n\n    \"\"\"\n\n    def __init__(self, msa, parameters: uorf4u.manager.Parameters, type: str):\n        \"\"\"Create a AnnotationPlotManager object.\n\n        Arguments:\n            path (uorf4u.data_processing.Path): Path class' objects that holds list of conserved ORFs.\n            upstream_sequences (list): list of dicts with information about upstream sequences.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n            type (str): type of sequences (sd, nt, aa)\n\n        \"\"\"\n        self.msa = msa\n        self.parameters = parameters\n        self.coordinate_system = dict()\n        self.additional_data = dict()\n        self.type = type\n\n    def define_x_axis_coordinate_system(self) -&gt; None:\n        \"\"\"Define coordinate system.\n\n        Returns:\n            None\n\n        \"\"\"\n\n        label_height = self.parameters.arguments[\"label_size\"] * self.parameters.arguments[\"tile_size\"] * cm\n        label_font_size = uorf4u.methods.string_height_to_font_size(label_height, \"regular\", self.parameters.arguments)\n        self.additional_data[\"label_font_size\"] = label_font_size\n        msa_length = self.msa.get_alignment_length()\n        max_label_width = max([reportlab.pdfbase.pdfmetrics.stringWidth(i.description, \"regular\",\n                                                                        label_font_size) for i in self.msa])\n\n        char_height = self.parameters.arguments[\"char_size\"] * self.parameters.arguments[\"tile_size\"] * cm\n        char_font_size = uorf4u.methods.string_height_to_font_size(char_height, \"mono\", self.parameters.arguments)\n        self.additional_data[\"char_font_size\"] = char_font_size\n\n        self.additional_data[\"number_of_sequences\"] = len(self.msa)\n        self.coordinate_system[\"x_labels_start\"] = self.parameters.arguments[\"margin\"] * cm\n        self.coordinate_system[\"x_labels_stop\"] = self.coordinate_system[\"x_labels_start\"] + max_label_width\n        self.coordinate_system[\"x_msa_start\"] = self.coordinate_system[\"x_labels_stop\"] + \\\n                                                self.parameters.arguments[\"label_gap\"] * cm\n        msa_width = self.parameters.arguments[\"tile_size\"] * msa_length * cm\n        self.coordinate_system[\"x_msa_stop\"] = self.coordinate_system[\"x_msa_start\"] + msa_width\n        self.coordinate_system[\"figure_width\"] = 2 * self.parameters.arguments[\"margin\"] * cm + msa_width + \\\n                                                 max_label_width + self.parameters.arguments[\"label_gap\"] * cm\n        self.coordinate_system[\"figure_height\"] = self.parameters.arguments[\"margin\"] * cm\n        self.additional_data[\"palette\"] = self.parameters.arguments[f\"colors_{self.type}\"]\n        self.additional_data[\"palette\"] = {k: uorf4u.methods.color_name_to_hex(v, self.parameters.arguments) for k, v in\n                                           self.additional_data[\"palette\"].items()}\n\n        return None\n\n    def create_tracks(self) -&gt; None:\n        \"\"\"Create visualisation tracks.\n\n        Returns:\n            None\n\n        \"\"\"\n        self.tracks = []\n        \"\"\"\n        title_loader = TitleLoader(self.parameters)\n        title_loader.prepare_data(self.coordinate_system, self.additional_data)\n        title_track = title_loader.create_track()\n        self.tracks.append(title_track)\n        self.coordinate_system[\"figure_height\"] += title_track.needed_y_space()\n        \"\"\"\n        for record in self.msa:\n            sequence_loader = SequencesLoader(self.parameters)\n            sequence_loader.prepare_data(record, self.coordinate_system, self.additional_data)\n            track = sequence_loader.create_track()\n            self.tracks.append(track)\n            self.coordinate_system[\"figure_height\"] += track.needed_y_space()\n            # self.coordinate_system[\"figure_height\"] += self.parameters.arguments[\"gap\"] * cm\n            # if index &lt; self.additional_data[\"number_of_sequences\"] - 1:\n        self.coordinate_system[\"figure_height\"] += self.parameters.arguments[\"margin\"] * cm\n\n    def plot(self, filename):\n        image = Image(filename, self.coordinate_system[\"figure_width\"], self.coordinate_system[\"figure_height\"])\n        current_y_top = self.coordinate_system[\"figure_height\"] - self.parameters.arguments[\"margin\"] * cm\n        for track in self.tracks:\n            track.visualisation_data[\"y_top\"] = current_y_top\n            track.draw(image.canvas)\n            current_y_top -= (track.needed_space)\n        image.save()\n        return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.MSAPlotManager.__init__","title":"<code>__init__(msa, parameters, type)</code>","text":"<p>Create a AnnotationPlotManager object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>Path</code>)         \u2013          <p>Path class' objects that holds list of conserved ORFs.</p> </li> <li> <code>upstream_sequences</code>             (<code>list</code>)         \u2013          <p>list of dicts with information about upstream sequences.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>type</code>             (<code>str</code>)         \u2013          <p>type of sequences (sd, nt, aa)</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def __init__(self, msa, parameters: uorf4u.manager.Parameters, type: str):\n    \"\"\"Create a AnnotationPlotManager object.\n\n    Arguments:\n        path (uorf4u.data_processing.Path): Path class' objects that holds list of conserved ORFs.\n        upstream_sequences (list): list of dicts with information about upstream sequences.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        type (str): type of sequences (sd, nt, aa)\n\n    \"\"\"\n    self.msa = msa\n    self.parameters = parameters\n    self.coordinate_system = dict()\n    self.additional_data = dict()\n    self.type = type\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.MSAPlotManager.create_tracks","title":"<code>create_tracks()</code>","text":"<p>Create visualisation tracks.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def create_tracks(self) -&gt; None:\n    \"\"\"Create visualisation tracks.\n\n    Returns:\n        None\n\n    \"\"\"\n    self.tracks = []\n    \"\"\"\n    title_loader = TitleLoader(self.parameters)\n    title_loader.prepare_data(self.coordinate_system, self.additional_data)\n    title_track = title_loader.create_track()\n    self.tracks.append(title_track)\n    self.coordinate_system[\"figure_height\"] += title_track.needed_y_space()\n    \"\"\"\n    for record in self.msa:\n        sequence_loader = SequencesLoader(self.parameters)\n        sequence_loader.prepare_data(record, self.coordinate_system, self.additional_data)\n        track = sequence_loader.create_track()\n        self.tracks.append(track)\n        self.coordinate_system[\"figure_height\"] += track.needed_y_space()\n        # self.coordinate_system[\"figure_height\"] += self.parameters.arguments[\"gap\"] * cm\n        # if index &lt; self.additional_data[\"number_of_sequences\"] - 1:\n    self.coordinate_system[\"figure_height\"] += self.parameters.arguments[\"margin\"] * cm\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.MSAPlotManager.define_x_axis_coordinate_system","title":"<code>define_x_axis_coordinate_system()</code>","text":"<p>Define coordinate system.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def define_x_axis_coordinate_system(self) -&gt; None:\n    \"\"\"Define coordinate system.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    label_height = self.parameters.arguments[\"label_size\"] * self.parameters.arguments[\"tile_size\"] * cm\n    label_font_size = uorf4u.methods.string_height_to_font_size(label_height, \"regular\", self.parameters.arguments)\n    self.additional_data[\"label_font_size\"] = label_font_size\n    msa_length = self.msa.get_alignment_length()\n    max_label_width = max([reportlab.pdfbase.pdfmetrics.stringWidth(i.description, \"regular\",\n                                                                    label_font_size) for i in self.msa])\n\n    char_height = self.parameters.arguments[\"char_size\"] * self.parameters.arguments[\"tile_size\"] * cm\n    char_font_size = uorf4u.methods.string_height_to_font_size(char_height, \"mono\", self.parameters.arguments)\n    self.additional_data[\"char_font_size\"] = char_font_size\n\n    self.additional_data[\"number_of_sequences\"] = len(self.msa)\n    self.coordinate_system[\"x_labels_start\"] = self.parameters.arguments[\"margin\"] * cm\n    self.coordinate_system[\"x_labels_stop\"] = self.coordinate_system[\"x_labels_start\"] + max_label_width\n    self.coordinate_system[\"x_msa_start\"] = self.coordinate_system[\"x_labels_stop\"] + \\\n                                            self.parameters.arguments[\"label_gap\"] * cm\n    msa_width = self.parameters.arguments[\"tile_size\"] * msa_length * cm\n    self.coordinate_system[\"x_msa_stop\"] = self.coordinate_system[\"x_msa_start\"] + msa_width\n    self.coordinate_system[\"figure_width\"] = 2 * self.parameters.arguments[\"margin\"] * cm + msa_width + \\\n                                             max_label_width + self.parameters.arguments[\"label_gap\"] * cm\n    self.coordinate_system[\"figure_height\"] = self.parameters.arguments[\"margin\"] * cm\n    self.additional_data[\"palette\"] = self.parameters.arguments[f\"colors_{self.type}\"]\n    self.additional_data[\"palette\"] = {k: uorf4u.methods.color_name_to_hex(v, self.parameters.arguments) for k, v in\n                                       self.additional_data[\"palette\"].items()}\n\n    return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.SequenceVis","title":"<code>SequenceVis</code>","text":"<p>             Bases: <code>Track</code></p> <p>SequenceVis track draws sequences and annotation.</p> <p>Attributes:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>needed_space</code>             (<code>float</code>)         \u2013          <p>needed vertical space for a track.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>class SequenceVis(Track):\n    \"\"\"SequenceVis track draws sequences and annotation.\n\n    Attributes:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        needed_space (float): needed vertical space for a track.\n\n    \"\"\"\n\n    def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n        \"\"\"Create a SequenceVis object.\n\n        Arguments:\n            visualisation_data (dict): a dictionary with data needed for visualisation.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(visualisation_data, parameters)\n        self.needed_space = None\n\n    def needed_y_space(self) -&gt; float:\n        \"\"\"Calculate needed vertical space for a SequenceVis track.\n\n        Returns:\n            float: needed vertical space.\n\n        \"\"\"\n        self.needed_space = self.parameters.arguments[\"tile_size\"] * cm\n        return self.needed_space\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Draw a Sequence track.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n        Returns:\n            None\n\n        \"\"\"\n        tile_size = self.parameters.arguments[\"tile_size\"] * cm\n        y_c = self.visualisation_data[\"y_top\"] - (tile_size * 0.5)\n        y_l = self.visualisation_data[\"y_top\"] - tile_size\n\n        y_gap_label = tile_size * (1 - self.parameters.arguments[\"label_size\"]) * 0.5\n        y_gap_char = tile_size * (1 - self.parameters.arguments[\"char_size\"]) * 0.5\n        # Labels\n        canvas.setFillColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n        canvas.setFont(\"regular\", self.visualisation_data[\"label_font_size\"])\n        canvas.drawRightString(self.visualisation_data[\"coordinate_system\"][\"x_labels_stop\"], y_l + y_gap_label,\n                               self.visualisation_data[\"label\"])\n\n        canvas.setLineWidth(0.05 * tile_size)\n        canvas.setStrokeColorRGB(1, 1, 1)\n        canvas.setFont(\"mono\", self.visualisation_data[\"char_font_size\"])\n        x = self.visualisation_data['msa_left_border']\n        for symbol in self.visualisation_data[\"sequence\"]:\n            x_c = x + tile_size * 0.5\n            symbol = symbol.upper()\n            try:\n                color = self.visualisation_data[\"palette\"][symbol]\n            except:\n                color = \"#FFFFFF\"\n            canvas.setFillColorRGB(*uorf4u.methods.hex_to_rgb(color), self.parameters.arguments[\"tile_alpha\"])\n            canvas.rect(x, y_l, tile_size, tile_size, fill=1)\n            canvas.setFillColorRGB(0, 0, 0, 0.8)  # to change\n            canvas.drawCentredString(x_c, y_l + y_gap_char, symbol)\n            x += tile_size\n\n        return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.SequenceVis.__init__","title":"<code>__init__(visualisation_data, parameters)</code>","text":"<p>Create a SequenceVis object.</p> <p>Parameters:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n    \"\"\"Create a SequenceVis object.\n\n    Arguments:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(visualisation_data, parameters)\n    self.needed_space = None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.SequenceVis.draw","title":"<code>draw(canvas)</code>","text":"<p>Draw a Sequence track.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a pdf object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Draw a Sequence track.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n    Returns:\n        None\n\n    \"\"\"\n    tile_size = self.parameters.arguments[\"tile_size\"] * cm\n    y_c = self.visualisation_data[\"y_top\"] - (tile_size * 0.5)\n    y_l = self.visualisation_data[\"y_top\"] - tile_size\n\n    y_gap_label = tile_size * (1 - self.parameters.arguments[\"label_size\"]) * 0.5\n    y_gap_char = tile_size * (1 - self.parameters.arguments[\"char_size\"]) * 0.5\n    # Labels\n    canvas.setFillColorRGB(*uorf4u.methods.get_color(\"label_color\", self.parameters.arguments))\n    canvas.setFont(\"regular\", self.visualisation_data[\"label_font_size\"])\n    canvas.drawRightString(self.visualisation_data[\"coordinate_system\"][\"x_labels_stop\"], y_l + y_gap_label,\n                           self.visualisation_data[\"label\"])\n\n    canvas.setLineWidth(0.05 * tile_size)\n    canvas.setStrokeColorRGB(1, 1, 1)\n    canvas.setFont(\"mono\", self.visualisation_data[\"char_font_size\"])\n    x = self.visualisation_data['msa_left_border']\n    for symbol in self.visualisation_data[\"sequence\"]:\n        x_c = x + tile_size * 0.5\n        symbol = symbol.upper()\n        try:\n            color = self.visualisation_data[\"palette\"][symbol]\n        except:\n            color = \"#FFFFFF\"\n        canvas.setFillColorRGB(*uorf4u.methods.hex_to_rgb(color), self.parameters.arguments[\"tile_alpha\"])\n        canvas.rect(x, y_l, tile_size, tile_size, fill=1)\n        canvas.setFillColorRGB(0, 0, 0, 0.8)  # to change\n        canvas.drawCentredString(x_c, y_l + y_gap_char, symbol)\n        x += tile_size\n\n    return None\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.SequenceVis.needed_y_space","title":"<code>needed_y_space()</code>","text":"<p>Calculate needed vertical space for a SequenceVis track.</p> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>needed vertical space.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def needed_y_space(self) -&gt; float:\n    \"\"\"Calculate needed vertical space for a SequenceVis track.\n\n    Returns:\n        float: needed vertical space.\n\n    \"\"\"\n    self.needed_space = self.parameters.arguments[\"tile_size\"] * cm\n    return self.needed_space\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.SequencesLoader","title":"<code>SequencesLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A SequencesLoader object prepares data for a Sequence track object.</p> <p>Attributes:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> <li> <code>prepared_data</code>             (<code>dict</code>)         \u2013          <p>dict with data needed for a visualisation track.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>class SequencesLoader(Loader):\n    \"\"\"A SequencesLoader object prepares data for a Sequence track object.\n\n\n    Attributes:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n        prepared_data (dict): dict with data needed for a visualisation track.\n\n    \"\"\"\n\n    def __init__(self, parameters):\n        \"\"\"Create a SequenceLoader object.\n\n        Arguments:\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        super().__init__(parameters)\n\n    def prepare_data(self, record, coordinate_system: dict, additional_data: dict) -&gt; dict:\n        \"\"\"Prepare data for a Title visualisation track.\n\n        Attributes:\n            record (FILL in): record of blablabla\n            coordinate_system (dict): coordinate system of a figure page.\n            additional_data (dict): data needed for a track initialisation.\n\n        Returns:\n            dict: dictionary with prepared data for visualisation.\n\n        \"\"\"\n        prepared_data = dict()\n        prepared_data[\"coordinate_system\"] = coordinate_system\n        prepared_data[\"label_font_size\"] = additional_data[\"label_font_size\"]\n        prepared_data[\"char_font_size\"] = additional_data[\"char_font_size\"]\n        prepared_data[\"label_right_border\"] = coordinate_system[\"x_labels_stop\"]\n        prepared_data[\"msa_left_border\"] = coordinate_system[\"x_msa_start\"]\n        prepared_data[\"sequence\"] = record.seq\n        prepared_data[\"label\"] = record.description\n        prepared_data[\"palette\"] = additional_data[\"palette\"]\n        self.prepared_data = prepared_data\n\n        return prepared_data\n\n    def create_track(self) -&gt; SequenceVis:\n        \"\"\"Initialise a Sequence track object.\n\n        Returns:\n            SequenceVis: visualisation track.\n\n        \"\"\"\n        return SequenceVis(self.prepared_data, self.parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.SequencesLoader.__init__","title":"<code>__init__(parameters)</code>","text":"<p>Create a SequenceLoader object.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def __init__(self, parameters):\n    \"\"\"Create a SequenceLoader object.\n\n    Arguments:\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    super().__init__(parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.SequencesLoader.create_track","title":"<code>create_track()</code>","text":"<p>Initialise a Sequence track object.</p> <p>Returns:</p> <ul> <li> <code>SequenceVis</code> (            <code>SequenceVis</code> )        \u2013          <p>visualisation track.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def create_track(self) -&gt; SequenceVis:\n    \"\"\"Initialise a Sequence track object.\n\n    Returns:\n        SequenceVis: visualisation track.\n\n    \"\"\"\n    return SequenceVis(self.prepared_data, self.parameters)\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.SequencesLoader.prepare_data","title":"<code>prepare_data(record, coordinate_system, additional_data)</code>","text":"<p>Prepare data for a Title visualisation track.</p> <p>Attributes:</p> <ul> <li> <code>record</code>             (<code>FILL in</code>)         \u2013          <p>record of blablabla</p> </li> <li> <code>coordinate_system</code>             (<code>dict</code>)         \u2013          <p>coordinate system of a figure page.</p> </li> <li> <code>additional_data</code>             (<code>dict</code>)         \u2013          <p>data needed for a track initialisation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (            <code>dict</code> )        \u2013          <p>dictionary with prepared data for visualisation.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def prepare_data(self, record, coordinate_system: dict, additional_data: dict) -&gt; dict:\n    \"\"\"Prepare data for a Title visualisation track.\n\n    Attributes:\n        record (FILL in): record of blablabla\n        coordinate_system (dict): coordinate system of a figure page.\n        additional_data (dict): data needed for a track initialisation.\n\n    Returns:\n        dict: dictionary with prepared data for visualisation.\n\n    \"\"\"\n    prepared_data = dict()\n    prepared_data[\"coordinate_system\"] = coordinate_system\n    prepared_data[\"label_font_size\"] = additional_data[\"label_font_size\"]\n    prepared_data[\"char_font_size\"] = additional_data[\"char_font_size\"]\n    prepared_data[\"label_right_border\"] = coordinate_system[\"x_labels_stop\"]\n    prepared_data[\"msa_left_border\"] = coordinate_system[\"x_msa_start\"]\n    prepared_data[\"sequence\"] = record.seq\n    prepared_data[\"label\"] = record.description\n    prepared_data[\"palette\"] = additional_data[\"palette\"]\n    self.prepared_data = prepared_data\n\n    return prepared_data\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Track","title":"<code>Track</code>","text":"<p>Parent clas for visualisation Tracks.</p> <p>Attributes:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>class Track:\n    \"\"\"Parent clas for visualisation Tracks.\n\n    Attributes:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n\n    def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n        \"\"\"Parent's constructor for creating a Track object.\n\n        Arguments:\n            visualisation_data (dict): a dictionary with data needed for visualisation.\n            parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n        \"\"\"\n        self.visualisation_data = visualisation_data\n        self.parameters = parameters\n\n    def needed_y_space(self) -&gt; None:\n        \"\"\"Empy parent's method for calculation needed vertical space for a track.\n\n        Returns:\n            None\n\n        \"\"\"\n        pass\n\n    def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n        \"\"\"Empy parent's method for track visualisation.\n\n        Arguments:\n            canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Track.__init__","title":"<code>__init__(visualisation_data, parameters)</code>","text":"<p>Parent's constructor for creating a Track object.</p> <p>Parameters:</p> <ul> <li> <code>visualisation_data</code>             (<code>dict</code>)         \u2013          <p>a dictionary with data needed for visualisation.</p> </li> <li> <code>parameters</code>             (<code>Parameters</code>)         \u2013          <p>Parameters' class object.</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def __init__(self, visualisation_data: dict, parameters: uorf4u.manager.Parameters):\n    \"\"\"Parent's constructor for creating a Track object.\n\n    Arguments:\n        visualisation_data (dict): a dictionary with data needed for visualisation.\n        parameters (uorf4u.manager.Parameters): Parameters' class object.\n\n    \"\"\"\n    self.visualisation_data = visualisation_data\n    self.parameters = parameters\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Track.draw","title":"<code>draw(canvas)</code>","text":"<p>Empy parent's method for track visualisation.</p> <p>Parameters:</p> <ul> <li> <code>canvas</code>             (<code>Canvas</code>)         \u2013          <p>a pdf object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def draw(self, canvas: reportlab.pdfgen.canvas.Canvas) -&gt; None:\n    \"\"\"Empy parent's method for track visualisation.\n\n    Arguments:\n        canvas (reportlab.pdfgen.canvas.Canvas): a pdf object.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_drawing/#uorf4u.drawing_msa.Track.needed_y_space","title":"<code>needed_y_space()</code>","text":"<p>Empy parent's method for calculation needed vertical space for a track.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/drawing_msa.py</code> <pre><code>def needed_y_space(self) -&gt; None:\n    \"\"\"Empy parent's method for calculation needed vertical space for a track.\n\n    Returns:\n        None\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_manager/","title":"uorf4u.manager","text":"<p>This module provides managing classes and methods for the tool.</p>"},{"location":"API/package_manager/#uorf4u.manager.Parameters","title":"<code>Parameters</code>","text":"<p>A Parameters object holds and parse cmd's and config's arguments for the tool.</p> Note <p>A Parameters object have to be created in each script since it's used by each     class of the tool as a mandatory argument.</p> Source code in <code>uorf4u/manager.py</code> <pre><code>class Parameters:\n    \"\"\"A Parameters object holds and parse cmd's and config's arguments for the tool.\n\n    Note:\n        A Parameters object have to be created in each script since it's used by each\n            class of the tool as a mandatory argument.\n\n    \"\"\"\n\n    def __init__(self):\n        self.arguments = dict(assemblies_list=\"NA\", debug=False, verbose=False)\n        self.cmd_arguments = {\"assemblies_list\": \"NA\", \"verbose\": True}\n\n    def parse_cmd_arguments(self) -&gt; None:\n        parser = argparse.ArgumentParser(prog=\"uorf4u\", add_help=False,\n                                         usage=\"uorf4u [-an accession_number | -hl [ac1, ac2..] | -hlf path | -fa path]\"\n                                               \"[optional arguments]\")\n        mutually_exclusive_group = parser.add_mutually_exclusive_group()\n        mutually_exclusive_group.add_argument(\"-an\", dest=\"accession_number\", type=str, default=None)\n        mutually_exclusive_group.add_argument(\"-hl\", dest=\"homologues_list\", nargs=\"*\", default=None)\n        mutually_exclusive_group.add_argument(\"-hlf\", dest=\"homologues_list_file\", type=str, default=None)\n        mutually_exclusive_group.add_argument(\"-fa\", dest=\"fasta\", type=str, default=None)\n        parser.add_argument(\"-data\", \"--data\", dest=\"uorf4u_data\", action=\"store_true\")\n        parser.add_argument(\"-linux\", \"--linux\", dest=\"linux\", action=\"store_true\", default=None)\n        parser.add_argument(\"-blastp_path\", \"--blastp_path\", dest=\"blastp_path\", type=str, default=None)\n        parser.add_argument(\"-bdb\", dest=\"blastp_database\", choices=[\"refseq_protein\", \"refseq_select\", None], type=str,\n                            default=None)\n        parser.add_argument(\"-lbdb\", dest=\"local_blastp_database\", type=str, default=None)\n        parser.add_argument(\"-bh\", dest=\"blastp_hit_list_size\", type=int, default=None)\n        parser.add_argument(\"-bid\", dest=\"blastp_pident_to_query_length_cutoff\", type=float, default=None)\n        parser.add_argument(\"-mna\", dest=\"max_number_of_assemblies\", type=int, default=None)\n        parser.add_argument(\"-al\", dest=\"assemblies_list\", type=str, default=\"NA\")\n        parser.add_argument(\"-annot\", dest=\"check_assembly_annotation\", action=\"store_true\", default=None)\n        parser.add_argument(\"-ul\", dest=\"upstream_region_length\", type=int, default=None)\n        parser.add_argument(\"-dl\", dest=\"downstream_region_length\", type=int, default=None)\n        parser.add_argument(\"-asc\", dest=\"alternative_start_codons\", action=\"store_true\", default=None)\n        parser.add_argument(\"-nsd\", dest=\"filter_by_sd\", action=\"store_false\", default=None)\n        parser.add_argument(\"-at\", dest=\"alignment_type\", choices=[\"nt\", \"aa\", None], type=str, default=None)\n        parser.add_argument(\"-pc\", dest=\"orfs_presence_cutoff\", type=float, default=None)\n        parser.add_argument(\"-fast\", dest=\"fast_searching\", action=\"store_true\", default=None)\n        parser.add_argument(\"-o\", dest=\"output_dir\", type=str, default=None)\n        parser.add_argument(\"-c\", dest=\"config_file\", type=str, default=\"Not selected\")\n        parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s 0.9.6\")\n        parser.add_argument(\"-q\", \"--quiet\", dest=\"verbose\", default=True, action=\"store_false\")\n        parser.add_argument(\"--debug\", \"-debug\", dest=\"debug\", action=\"store_true\")\n        parser.add_argument(\"-h\", \"--help\", dest=\"help\", action=\"store_true\")\n        args = parser.parse_args()\n        args = vars(args)\n\n        if len(sys.argv[1:]) == 0:\n            args[\"help\"] = True\n\n        if args[\"help\"]:\n            help_message_path = os.path.join(os.path.dirname(__file__), \"uorf4u_data\", \"help.txt\")\n            with open(help_message_path, \"r\") as help_message:\n                print(help_message.read(), file=sys.stdout)\n                sys.exit()\n\n        if args[\"uorf4u_data\"]:\n            uorf4u.methods.copy_package_data()\n            sys.exit()\n\n        if args[\"linux\"]:\n            uorf4u.methods.adjust_paths_for_linux()\n            sys.exit()\n\n        if args[\"blastp_path\"]:\n            uorf4u.methods.set_blastp_path(args[\"blastp_path\"])\n            sys.exit()\n\n        filtered_args = {k: v for k, v in args.items() if v is not None}\n        self.cmd_arguments = filtered_args\n\n    def load_config(self, path_c):\n        if path_c == \"Not selected\":\n            raise uORF4uError(\"Please, specify -c argument &lt;bacteria|eukaryotes|&lt;file.cfg&gt;. \"\n                              \"It can be either a path to a configuration file or name of a premade config file \"\n                              \"(bacteria or eukaryotes)\")\n        try:\n            if path_c == \"bacteria\" or path_c == \"eukaryotes\":\n                path_c = os.path.join(os.path.dirname(__file__), \"uorf4u_data\", f\"uorf4u_{path_c}.cfg\")\n            config = configs.load(path_c)\n            config = config.get_config()\n            internal_dir = os.path.dirname(__file__)\n            config[\"root\"][\"output_dir\"] = config[\"root\"][\"output_dir\"].replace(\"{current_date}\",\n                                                                                time.strftime(\"%Y_%m_%d-%H_%M\"))\n            for key in config[\"root\"].keys():\n                if type(config[\"root\"][key]) is str and \"{config_path}\" in config[\"root\"][key]:\n                    config[\"root\"][key] = config[\"root\"][key].replace(\"{config_path}\", os.path.dirname(path_c))\n            if config[\"root\"][\"blastp_database\"] not in [\"refseq_select\", \"refseq_protein\"]:\n                raise uORF4uError(\"Config's parameter 'blastp_database' should be either refseq_select or \"\n                                  \"refseq_protein. \")\n\n            self.arguments.update(config[\"root\"])\n            self.arguments.update(self.cmd_arguments)\n            self.load_palette()\n            self.load_color_config()\n            Bio.Entrez.tool = \"uorf4u\"\n            Bio.Entrez.email = self.arguments[\"ncbi_entrez_email\"]\n            if \"ncbi_entrez_api_key\" in self.arguments.keys():\n                Bio.Entrez.api_key = self.arguments[\"ncbi_entrez_api_key\"]\n        except Exception as error:\n            raise uORF4uError(\n                \"Unable to parse the specified config file. Please check your config file or written name.\") from error\n\n    def load_palette(self) -&gt; None:\n        palette_path = self.arguments[f\"palette\"]\n        self.arguments[f\"palette\"] = configs.load(palette_path).get_config()[\"root\"]\n\n    def load_color_config(self) -&gt; None:\n        for seq_type in [\"nt\", \"aa\"]:\n            path = self.arguments[f\"colors_{seq_type}\"]\n            colors_pre_dict = configs.load(path).get_config()[\"root\"]\n            colors_dict = dict()\n            for elements, color in colors_pre_dict.items():\n                for element in elements:\n                    colors_dict[element] = color\n            self.arguments[f\"colors_{seq_type}\"] = colors_dict\n\n    def update(self, parameters):\n        self.arguments.update(parameters)\n</code></pre>"},{"location":"API/package_manager/#uorf4u.manager.uORF4uError","title":"<code>uORF4uError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A helper for exceptions parsing inherited from the Exception class.</p> Source code in <code>uorf4u/manager.py</code> <pre><code>class uORF4uError(Exception):\n    \"\"\"A helper for exceptions parsing inherited from the Exception class.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/package_methods/","title":"uorf4u.methods","text":"<p>This module provides some methods (e.g. colors tranformation, data copying) used by the tool.</p>"},{"location":"API/package_methods/#uorf4u.methods.adjust_paths_for_linux","title":"<code>adjust_paths_for_linux()</code>","text":"<p>Change paths in the internal config files for linux.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/methods.py</code> <pre><code>def adjust_paths_for_linux() -&gt; None:\n    \"\"\"Change paths in the internal config files for linux.\n\n    Returns:\n        None\n\n    \"\"\"\n    internal_dir = os.path.join(os.path.dirname(__file__), \"uorf4u_data\")\n    config_files = [\"uorf4u_eukaryotes.cfg\", \"uorf4u_bacteria.cfg\"]\n    for config_file in config_files:\n        config_file_path = os.path.join(internal_dir, config_file)\n        with open(config_file_path, \"r+\") as config:\n            config_txt = re.sub(r\"/muscle5\\.1\\.macos_arm64\", \"/muscle5.1.linux_intel64\", config.read())\n            config_txt = re.sub(r\"/mafft-mac/mafft\\.bat\", \"/mafft-linux64/mafft.bat\", config_txt)\n            config.seek(0)\n            config.truncate()\n            config.write(config_txt)\n    return None\n</code></pre>"},{"location":"API/package_methods/#uorf4u.methods.copy_package_data","title":"<code>copy_package_data()</code>","text":"<p>Copy the uorf4u package data folder to your current dir.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/methods.py</code> <pre><code>def copy_package_data() -&gt; None:\n    \"\"\"Copy the uorf4u package data folder to your current dir.\n\n    Returns:\n        None\n\n    \"\"\"\n    try:\n        users_dir = os.path.join(os.getcwd(), \"uorf4u_data\")\n        internal_dir = os.path.join(os.path.dirname(__file__), \"uorf4u_data\")\n        shutil.copytree(internal_dir, users_dir, ignore=shutil.ignore_patterns(\"help*\", \".*\", \"msa_plot_dir.R\"))\n        return None\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(f\"Unable to copy uorf4u_data folder in your working dir.\") from error\n</code></pre>"},{"location":"API/package_methods/#uorf4u.methods.get_color","title":"<code>get_color(name, parameters)</code>","text":"<p>Get color code by a name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>name of a color.</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (            <code>tuple</code> )        \u2013          <p>RGB color.</p> </li> </ul> Source code in <code>uorf4u/methods.py</code> <pre><code>def get_color(name: str, parameters: dict) -&gt; tuple:\n    \"\"\"Get color code by a name.\n\n    Arguments:\n        name (str): name of a color.\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        tuple: RGB color.\n\n    \"\"\"\n    rgb_color = *hex_to_rgb(parameters['palette'][parameters[name]]), parameters[f\"{name}_alpha\"]\n    return rgb_color\n</code></pre>"},{"location":"API/package_methods/#uorf4u.methods.hex_to_rgb","title":"<code>hex_to_rgb(value)</code>","text":"<p>Convert HEX color to RGB format.</p> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>str</code>)         \u2013          <p>color in HEX format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>RGB color.</p> </li> </ul> Source code in <code>uorf4u/methods.py</code> <pre><code>def hex_to_rgb(value: str) -&gt; list:\n    \"\"\"Convert HEX color to RGB format.\n\n    Arguments:\n        value (str): color in HEX format.\n\n    Returns:\n        list: RGB color.\n\n    \"\"\"\n    try:\n        value = value.lstrip(\"#\")\n        lv = len(value)\n        rgb = [i / 255 for i in tuple(int(value[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))]\n        return rgb\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(\n            f\"Unable to convert color definition from HEX to RGB. Please check the palette config file.\") from error\n</code></pre>"},{"location":"API/package_methods/#uorf4u.methods.parse_fasta_file","title":"<code>parse_fasta_file(path, parameters)</code>","text":"<p>Parse fasta file with sequences.</p> <p>Arguments     path: path to a fasta file.</p> <p>Returns:</p> <ul> <li> <code>list</code> (            <code>list</code> )        \u2013          <p>list of processed Bio.SeqRecord.SeqRecord objects.</p> </li> </ul> Source code in <code>uorf4u/methods.py</code> <pre><code>def parse_fasta_file(path: str, parameters) -&gt; list:\n    \"\"\"Parse fasta file with sequences.\n\n    Arguments\n        path: path to a fasta file.\n\n    Returns:\n        list: list of processed Bio.SeqRecord.SeqRecord objects.\n\n    \"\"\"\n    try:\n        processed_records = []\n        record_ids = []\n        with open(path) as handle:\n            for record in Bio.SeqIO.parse(handle, \"fasta\"):\n                label = record.description\n                record.description = record.description.replace(record.id, \"\")\n                length = len(record.seq)\n                record_annotation = dict(RefSeq=False, length=length,\n                                         upstream_region_length=length - parameters.arguments[\n                                             \"downstream_region_length\"],\n                                         downstream_region_length=parameters.arguments[\"downstream_region_length\"],\n                                         label=label, start=0, stop=length, strand=\"+\")\n                record.annotations = record_annotation\n                processed_records.append(record)\n        return processed_records\n    except Exception as error:\n        raise uorf4u.manager.uORF4uError(f\"Unable to process the fasta file with sequences.\") from error\n</code></pre>"},{"location":"API/package_methods/#uorf4u.methods.set_blastp_path","title":"<code>set_blastp_path(blastp_path)</code>","text":"<p>Set a path to blastp.</p> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>uorf4u/methods.py</code> <pre><code>def set_blastp_path(blastp_path) -&gt; None:\n    \"\"\"Set a path to blastp.\n\n    Returns:\n        None\n\n    \"\"\"\n    if blastp_path[0] != \"/\":\n        raise uorf4u.manager.uORF4uError(f\"You have to specify the absolute path (starts with /) to blastp.\")\n    if not os.path.exists(blastp_path):\n        raise uorf4u.manager.uORF4uError(f\"A file with path you provided does not exist.\")\n    internal_dir = os.path.join(os.path.dirname(__file__), \"uorf4u_data\")\n    config_files = [\"uorf4u_eukaryotes.cfg\", \"uorf4u_bacteria.cfg\"]\n    for config_file in config_files:\n        config_file_path = os.path.join(internal_dir, config_file)\n        with open(config_file_path, \"r+\") as config:\n            config_txt = re.sub(r\"(blastp\\s*=\\s*).*\", r\"\\1{}\".format(blastp_path), config.read())\n            config.seek(0)\n            config.truncate()\n            config.write(config_txt)\n    print(\"\u2728 blastp path was successfuly updated.\")\n    return None\n</code></pre>"},{"location":"API/package_methods/#uorf4u.methods.string_height_to_font_size","title":"<code>string_height_to_font_size(height, font_type, parameters)</code>","text":"<p>Transform string height to the font size.</p> <p>Parameters:</p> <ul> <li> <code>height</code>             (<code>float</code>)         \u2013          <p>available height of the string.</p> </li> <li> <code>font_type</code>             (<code>str</code>)         \u2013          <p>font type (see config file; at this moment only regular is available).</p> </li> <li> <code>parameters</code>             (<code>dict</code>)         \u2013          <p>Parameters' object dict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>font size defined by height.</p> </li> </ul> Source code in <code>uorf4u/methods.py</code> <pre><code>def string_height_to_font_size(height: float, font_type: str, parameters: dict) -&gt; float:\n    \"\"\"Transform string height to the font size.\n\n    Arguments:\n        height (float): available height of the string.\n        font_type (str): font type (see config file; at this moment only regular is available).\n        parameters (dict): Parameters' object dict.\n\n    Returns:\n        float: font size defined by height.\n\n    \"\"\"\n    pdfmetrics.registerFont(TTFont(font_type, parameters[f\"font_{font_type}\"]))\n    face = pdfmetrics.getFont('regular').face\n    font_size = (1000 * 1.38 * height) / (face.ascent - face.descent)\n    return font_size\n</code></pre>"},{"location":"API/usage_examples/","title":"Short example-drived guide to uorf4u API.","text":"<p>uorf4u has a simple API allowing it programmatic usage from within a python program. Below we descrive several Python snippets that mimic results of command-line calls.</p> <p>Using a single RefSeq protein accession number as input in bacteria mode <pre><code>import uorf4u\n\nparameters = uorf4u.manager.Parameters()\nparameters.load_config(\"bacteria\")  # Load config (bacteria, eukaryotes or path)\nparameters.arguments[\"output_dir\"] = \"ErmCL\"  # to change parameters\n\nprotein = uorf4u.data_processing.RefSeqProtein(accession_number=\"WP_001003263.1\",\n                                               parameters=parameters)\nhomologues_list = protein.blastp_searching_for_homologues()\nhomologues = uorf4u.data_processing.Homologues(homologues_list, parameters)\nupstream_sequences_records = homologues.get_upstream_sequences()\n\nupstream_seqs = uorf4u.data_processing.UpstreamSequences(upstream_sequences_records, parameters)\nupstream_seqs.annotate_orfs()\nupstream_seqs.filter_orfs_by_sd_annotation()\nupstream_seqs.save_annotated_orfs()\nupstream_seqs.conserved_orf_searching()\nupstream_seqs.filter_out_similar_paths()\nupstream_seqs.run_msa()\nupstream_seqs.save_orfs_sequences()\nupstream_seqs.save_msa()\nupstream_seqs.save_results_summary_table()\nupstream_seqs.plot_annotation()\nupstream_seqs.plot_logo_figs()\nupstream_seqs.plot_msa_figs()\n</code></pre></p> <p>Will be updated with more examples...</p>"},{"location":"ExampleDrivenGuide/cmd_guide/","title":"Example-driven guide","text":"<p>Here we show several usage examples of the uorf4u command-line interface for two well-known uORFs: ermCL (bacteria) and ATF4 (eukaryotes). (See review articles about uORFs in prokaryotes and eukaryotes: Ito et.al. 2013 and Dever et.al. 2020.</p> <p>Before start: The necessary sample data as well as adjustable tool' configuration files are provided by uorf4u at the post-install step:   <code>uorf4u --data</code> If you work on a Linux machine after installation you should run: <code>uorf4u --linux</code> This command replaces the tools paths (maft) in the pre-made config files from the MacOS' version (default) to the Linux'. </p>"},{"location":"ExampleDrivenGuide/cmd_guide/#output-folder-structure","title":"Output folder structure","text":""},{"location":"ExampleDrivenGuide/cmd_guide/#bacteria-ermcl","title":"Bacteria: ermCL","text":"<p>Expression of 23S rRNA methyltransferase ermC is regulated by translational attenuation: ribosome stalling on the ermC uORF (named ermCL) is inducible by erythromycin. The arresst alters the regional mRNA structure, exposing the ermC SD sequence and allowing translation of the ermC ORF. </p> <p></p> <p>Using a single RefSeq protein accession number as input </p> <p>To test whether uORF4u will find the ermCL we can use only the RefSeq accession number of ermC protein as input which is WP_001003263.1. <code>uorf4u -an WP_001003263.1 -ul 400 -o ErmC -c bacteria</code>, All arguments, except <code>-an</code>, were optional. <code>-ul</code> was used to overrides the upstream region length to retrieve (default: 500). Output folder name can be set with <code>-o</code> parameter (default: uorf4u_{current_date}). We also used bacteria mode by specifying the premade configuration file with <code>-c</code> parameter.  </p> <p>uORF4u finds the expected ermCL and returns one set of conserved uORFs. Output contains MSA plot, annotation plot, and sequence logo: </p> <p>Using a list of homologues as input</p> <p>Alternatively, a list of homologues can be used as input. This is important for allowing a user to decide the breadth and depth of the search. In addition, it can be useful for creating compact output figures that can be used in articles. For such demonstration, we have chosen several ermC proteins from the previous run and used them as input: <pre><code>uorf4u -hl WP_202338192.1 WP_102227852.1 WP_034984371.1 WP_159316313.1 WP_095341278.1 WP_150861853.1 WP_011382144.1 WP_081624258.1 -c bacteria -annot -ul 400\n</code></pre> where <code>-annot</code> parameter was used to show on annotation plot known ORFs annotated in the NCBI (shown with blue outlines).  Note: List of homologues can be also written in a txt file (one accession per line) and used as input with <code>-hlf</code> parameter.</p> <p>Results with annotation plot, MSA visualisation and sequence logos:  </p> <p></p>"},{"location":"ExampleDrivenGuide/cmd_guide/#eukaryotes-atf4","title":"Eukaryotes: ATF4","text":"<p>The expression of ATF4 (activating transcription factor) is regulated by two uORFs. After translation of the first uORF1, ribosomes are normally able to reinitiate translation at a downstream uORF2 after rebinding the initiating ternary complex (eIF2-GTP-Met-tRNA). Reduced levels of the ternary complex during stress conditions leads to the ribosome scanning through the uORF2 start codon and instead reinitiating at the ATF4 uORF.</p> <p></p> <p>uORF4u has two modes: bacteria (set as default) and eukaryotes that defined by pre-made configuration files. Archaea mode (no SD sequence annotation + retrieving DNA sequences as well due the absence of mRNAs data) will be presented soon or can be set manually within config files.   The main differences between two modes: 1. For eukaryotes there is no SD sequence annotation step and corresponding uORF filtering. 2. While sequences retrieving for found homologues we take only mRNAs (the tool uses regex to perform that which is set by refseq_sequences_regex in the config files. For eukaryotes it's set as '^[NX]M_.*' that means that only sequences with ids that start with NM_ or XM_ (mRNAs) will be taken in the analysis).</p> <p>Using a single RefSeq protein accession number as input </p> <p>Similarly to the bacteria' example, firstly we can use a single protein accession number as input: <code>uorf4u -an NP_877962.1 -c eukaryotes -o ATF4</code> We used eukaryotes mode by specifying the premade configuration file with <code>-c</code> parameter.  </p> <p>uORF4u finds both uORFs and returns (as always) MSA plots (uORF1 nt, uORF2 nt), annotation plots (uORF1, uORF2) and sequence logos. A nucleotide sequence logo for uORF1: </p> <p>Using a list of homologues as input</p> <p>Let's use again a subset of the found homologues to get a compact output.  <pre><code>uorf4u -hl NP_001666.2 XP_036720744.1 XP_024434925.1 XP_034632036.1 XP_008703764.1 XP_034983127.1 XP_019400505.1 XP_003989324.2 XP_003419800.1 XP_019302483.1 XP_047407736.1 XP_032062344.1 -c eukaryotes\n</code></pre></p> <p></p> <p>Note: unfortunately, animal's emojis were added manually. </p> <p>Using a fasta file with sequences as input</p> <p>You can use a fasta file with sequences as input as well. Command example with a fasta file obtained from previous run as input: <code>uorf4u -fa ATF4/upstream_sequences.fa -c eukaryotes</code> </p> <p>It is useful to note that when using nucleotide sequences as input, uORF4u can be used as a general conserved ORF search tool, that is, not necessarily upstream of any particular mORF. But be carefull with this mode, recommended range of sequences' length ~100-1000nt and number of sequences: 10-1000. uORF4u was not designed to perform conservation analysis on chromosome' size set of sequences.</p>"},{"location":"Parameters/cmd_parameters/","title":"\u0421ommand-line parameters","text":"<p>POST-INSTALL DATA AND CONFIGURATION</p> <ul> <li> <p><code>--data</code> Creates the uorf4u_data folder in the current working directory. The folder will contain the adjustable configuration file templates, palettes, tables as well as the necessary sample.</p> </li> <li> <p><code>--linux</code> All Linux user should run it only once after installation. Replaces the tools paths in the premade config files from the MacOS' version [default] to the Linux'.</p> </li> <li> <p><code>--blastp_path</code> Update the blastp path in the pre-made config files. Required for using local blastp databases with <code>-lbdb</code> parameter. </p> </li> </ul> <p>MANDATORY ARGUMENTS</p> <ul> <li> <p><code>-an</code> accession_number Protein's RefSeq accession number.</p> <p>OR</p> </li> <li> <p><code>-hl</code> accession_number1 [accession_number2, ...] Space separated list of proteins accession numbers which will be used as list of homologous.</p> <p>OR</p> </li> <li> <p><code>-hlf</code> file.txt Path to a file with list of accession numbers. File format: one accession number per line, no header.</p> <p>OR</p> </li> <li> <p><code>-fa</code> file.fa     Path to a fasta file with upstream sequences.</p> </li> <li> <p><code>-c</code> bacteria|eukaryotes|file.cfg Path to a configuration file [default: internal].</p> </li> </ul> <p>OPTIONAL ARGUMENTS</p> <ul> <li> <p><code>-bdb</code> &lt;efseq_select|refseq_protein Online blastp database to perform blastp searching for homologues. [default: from config; refseq_select for bacteria, refseq_protein for eukaryotes]</p> </li> <li> <p><code>-lbdb</code> path to a database Local blastp database to perform blastp searching for homologues. Note: You have to specify path to a blastp with --blastp_path command before using this argument.</p> </li> <li> <p><code>-bh</code> number_of_hits Max number of blastp hits in homologous searching.</p> </li> <li> <p><code>-bid</code> identity_cutoff [0-1] BlastP searching cutoff for hit's identity to your query protein.</p> </li> <li> <p><code>-mna</code> number_f_assemblies Max number of assemblies to take into analysis for each protein. If there are more sequences in the identical protein database then random sampling will be used.</p> </li> <li> <p><code>-al</code> path_to/assemblies_list.tsv Path to an assemblies list file. During each run of uorf4u, a tsv table with information about assemblies (from identical protein database, ncbi) for each protein is saved to your output folder (output_dir_name/assemblies_list.tsv). There are cases with multiple assemblies for one protein accession numbers (up to thousands). In case to control assemblies included in the analysis this table can be filtered (simply by removing rows) and then used with this parameter as part of input to the next run. In addition, config file (see config parameters section) has max_number_of_assemblies parameter. It can be used to limit max number of assemblies included in the analysis. In case number of assemblies is more than the cutoff, random sampling will be used to take only subset of them.</p> </li> <li> <p><code>-annot</code> Retrieve sequences annotation (to be sure that annotated uORFs is not overlapped with a known CDS. </p> </li> <li> <p><code>-ul</code> length  Length of upstream sequences to retrieve.</p> </li> <li> <p><code>-dl</code> length  Length of downstream sequences to retrieve.</p> </li> <li> <p><code>-asc</code>  Include alternative start codons in uORF annotation step. List of alternative start codons are taken from the ncbi genetic code.</p> </li> <li> <p><code>-nsd</code> Deactivate filtering ORFs by SD sequence presence. [default: True for 'prokaryotes' config and False for 'eukaryotes' config].</p> </li> <li> <p><code>-at</code> aa|nt Alignment type used by uorf4u for conserved ORFs searching [default: aa]. </p> </li> <li> <p><code>-pc</code> cutoff [0-1] A cutoff of presence (number of ORFs in a list/number of sequences) for an ORFs set to be called conserved and returned [default: 0.4, set in the config].</p> </li> <li> <p><code>-fast</code> Fast searching mode with less accuracy (&gt;~300 sequences or &gt;~2000 ORFs).</p> </li> <li> <p><code>-o</code> dirname Output dirname. It will be created if it's not exist. All output dirs will be then created in this folder [default: uorf4u_{current_date}; e.g. uorf4u_2022_07_25-20_41].</p> </li> </ul> <p>MISCELLANEOUS ARGUMENTS</p> <ul> <li> <p><code>-h</code>, <code>--help</code> Show help message and exit.</p> </li> <li> <p><code>-v</code>, <code>--version</code> Show program version.</p> </li> <li> <p><code>--debug</code> Provide detailed stack trace for debugging purposes.</p> </li> <li> <p><code>--quiet</code> Don't show progress messages.</p> </li> </ul>"},{"location":"Parameters/config_parameters/","title":"Configuration file parameters","text":"<p>uorf4u configuration file allows detailed customization of the tool's parameters.</p> <p>Note:  uorf4u has two pre-made configuration files: uorf4u_eukaryotes.cfg and uorf4u_bacteria located in: ./uorftu/uorf4u_data/ folder (internal). By default, 'bacteria' config file is used if no path or name of premade file is specified by a cmd parameter: <code>-c  bacteria|eukaryotes|&lt;file.cfg&gt;</code>.  </p> <p>You can copy the uorf4u_data folder that contains the config files to your wiking directory with <code>uorf4u --data</code> command and safely edit and use them without affecting 'internal' set of configs. If you want to use a copied config file, use <code>-c path_to_config</code>.</p> <p>;[General] ncbi_genetic_code_name = Bacterial; the ncbi genetic code name ('Standard' for eukaryotes' config) ncbi_entrez_email = uorf4u@gmail.com; e-mail for the NCBI API. upstream_region_length = 500; [int or 'all'] Length of upstream region to retrieve. 'all' value is set for eukaryotes config file since by default it uses only mRNAs sequences. (can be overriden by <code>-ul</code> cmd parameter). minimal_upstream_region_length = 300; [int] minimal upstream region length for sequences to retrieve. If available sequence length to retrieve is shorter then this record won't be taken in the analysis.   downstream_region_length = 100; [int] downstream region (overlapped with CDS) length to retrieve. (can be overriden by <code>-dl</code> cmd parameter). filter_refseq_sequences_by_regex = True; [bool] use or not regex parameter (below) for filtering the NCBI RefSeq sequences to retrieve. refseq_sequences_regex = ^N_.; [regex] that will be used to filter the NCBI RefSeq sequnces. For eukaryotes set as '^[NX]M_.' that means that only sequences that start with NM_ or XM_ (mRNAs) will be taken in the analysis. max_number_of_assemblies = 1; [int] max number of assemblies to take into analysis for each protein. If there are more sequences in the identical protein database then random sampling will be used. (can be overriden by <code>-mna</code> cmd parameter).</p> <p>;[blastp homologous searching] blastp_database = refseq_select; [refseq_select or refseq_protein] Online blastp database to perform blastp searching for homologues. (can be overriden by <code>-bdb</code> cmd parameter). blastp_evalue_cutoff = 1e-5; [float] blastp e-value cutoff during the searching for homologs against the RefSeq database. blastp_hit_list_size = 200; [int] max number of blastp hits to take in the analysis. blastp_max_number_of_alignments = 1000; [int] max number of alignments during the searching (there could be several alignments for 1 hit, see blastp documentation) blastp_pident_to_query_length_cutoff = 0.5; [float: 0-1] cutoff for hit's identity to your query protein. </p> <p>;[ORF annotation] alternative_start_codons = False; [bool] use or not set of alternative start codons. main_start_codon = ATG;  [str] min_orf_length = 9; [int] cutoff for ORFs length during annotation filter_by_sd = True; [bool] filter annotated ORFs by Shine-Dalgarno sequence prersence. Filtering based on calculation of binding energy between aSD sequence (UCCUCC) and putative SD sequence in an upstream to uAUG window. Energy calculation performed as described here: Yang et.al, 2016 sd_energy_cutoff = -3; [float] cutoff for aSD-SD binding energy. sd_window_length = 20; [int] length of a region for SD sequence search. check_assembly_annotation = False; [bool] retrieve or not the NCBI sequences annotation to be sure that annotated uORFs are not overlapped with known CDSs (can be overriden by <code>-annot</code> cmd parameter).</p> <p>;[conserved ORFs searching] fast_searching = auto; [bool(true or false) or 'auto'] use or not fast searching mode with less accuracy (needed for &gt;~200 sequences or &gt;~2000 ORFs). Can be also set as auto [default]. (can be overriden by <code>-fast</code> cmd parameter). fast_searching_fraction_of_initial_genomes = 0.3; [bool] fraction of input sequences that will be used as initial step in algorithm searching. Applied only if the fast_searching parameter is True. orf_length_group_range = 0.25; [float or int] orf's lengths window within conserved uORFs set can be annotated. If it's a float value [0-1] then the radius of window is a set percentage of the claster's length, while if it's int then the window radius is fixed. orfs_presence_cutoff = 0.5; [float] a set of ORFs will be returned only if they were found in a fraction of input sequences larger than this cutoff. paths_identity_cutoff = 0.5; [float] if two sets of found ORFs are ovelapped more than this cutoff, then only a set with a higher. score will be returned. (Helps to remove duplicates). max_num_of_initial_genome_iteration = 100; [int] similar to the fast_searching_fraction_of_initial_genomes parametr, but used with a normal mode for optimisation. </p> <p>;[Pairwise alignment] alignment_type = aa; [nt or aa] alignment type of uORFs during conservation analysis.  ; Below listed global alignments parametersduring conservation analysis. uorf4u uses Bio.Align. package to perfome pairwise alignment of uORFs. global_match_score = 1; [float] global_mismatch_score = -1; [float] global_open_gap_score = -1; [float] global_extend_gap_score = -1; [float] global_target_end_gap_score = -1; [float] global_query_end_gap_score = -1; [float] alignment_score_cutoff = 0; [float] if a pairwise alignment score is larger than this cutoff then two uORFs are considered as aligned. </p> <p>;[Multiple Sequence Alignment] consensus_threshold = 0.7;  [float] treshold for MSA position to consider a nucleotide/amino acid as conserved in consensus sequence building. </p> <p>;[Paths]  ;Pathes to scripts and files used by the tool. {internal} means a folder uorf4u/uorf4u_data in the tool location. ref_energies = {config_path}/energyRef-CCTCCT.json; aSD-SD energy table downloaded from: Yang et.al, 2016 maft_binary = {config_path}/bin/mafft-mac/mafft.bat palette = {config_path}/palette.txt colors_nt = {config_path}/colors_nt.txt colors_aa = {config_path}/colors_aa.txt </p> <p>;[Output] sequences_to_write = nt, aa, sd; [list] type of sequences results for that (logos, MSAs, fasta files) will writetn. nt - nucleotide seqs of uORFs, aa - amino acid seqs, sd - SD seqs (sd is not available for 'eukaryotes' mode) logo_type = both; [probability, information or both] type of logo, see logomaker package documentation. output_dir = uorf4u_{current_date}; [str] default name of the output dir. default: uorf4u_{current_date}; e.g. uorf4u_2022_07_25-20_41. (can be overriden by <code>-o</code> cmd parameter). </p> <p>;------------------------ ;Annotation visualisation ;------------------------ ;[General figure parameters] margin = 0.1 gap = 0.03 label_gap = 0.07 orf_height = 0.15 annotation_width = auto mm_per_nt = 0.04 font_regular = {config_path}/fonts/Lato-Regular.ttf font_bold = {config_path}/fonts/Lato-Bold.ttf font_mono = {config_path}/fonts/RobotoMono-Regular.ttf  </p> <p>;[Sequence labels] label_color = #3D3D3D label_color_alpha = 1 label_height_to_orf_height = 0.65  </p> <p>;[Axis tics] axis_tics_font_size = auto axis_tics_line_width = 0.3  </p> <p>;[Loci annotations] upstream_seq_line_color = #CECECE upstream_seq_line_color_alpha = 1 upstream_seq_line_width = 0.5 cds_seq_stroke_color = #489143 cds_seq_stroke_color_alpha = 0.8 cds_seq_fill_color = #9ee19b cds_seq_fill_color_alpha = 0.03 orf_line_width = 0.5 conserved_uorfs_stroke_color = #4e4e4e conserved_uorfs_stroke_color_alpha = 1 conserved_uorfs_fill_color = #ee8fb1 conserved_uorfs_fill_color_alpha = 0.6 other_uorfs_stroke_color = #CECECE other_uorfs_stroke_color_alpha = 1 annotated_orf_stroke_color = #3d6f8e annotated_orf_stroke_color_alpha = 1  </p> <p>;------------------------ ;MSA plot ;------------------------ tile_size = 0.1 tile_stroke = 0.05 char_size = 0.7 label_size = 0.6 tile_alpha = 0.8 logo_alpha = 0.8  </p>"},{"location":"VersionLog/versions/","title":"Version log","text":"<ul> <li>Ver 0.9.6 - 21 Jan 2025<ul> <li>Bug fixes due to the update of packages.</li> </ul> </li> <li>Ver 0.9.5 - 4 May 2023<ul> <li>Local blastp searching function now also returns the query accession number.</li> </ul> </li> <li>Ver 0.9.4 - 19 April 2023<ul> <li>A minor bug with <code>-al</code> parameter is fixed.</li> </ul> </li> <li>Ver 0.9.3 - 18 April 2023<ul> <li>New cmd parameter <code>-pdb</code> for choosing an online blastp database.</li> <li>New cmd parameter <code>-lpdb</code> for using local blastp database.</li> </ul> </li> <li>Ver 0.9.2 - 19 February 2023<ul> <li>Blastp searching is now available for protein sequences. </li> </ul> </li> <li>Ver 0.9.1 - 19 February 2023<ul> <li>A major bug of 0.9.0 version in conservation analysis was fixed.</li> </ul> </li> <li>Ver 0.9.0 - 17 February 2023<ul> <li>Conservation analysis algorithm was updated.</li> <li>-c parameter is now always required.</li> <li>Logs messages were updated.</li> </ul> </li> <li>Ver 0.8.7 - 20 January 2023<ul> <li>Logs messages were updated.</li> </ul> </li> <li>Ver 0.8.6 - 18 January 2023<ul> <li>Sequences in MSA plot now are ordered according to their similarity. (--reorder MAFFT parameter)</li> </ul> </li> <li>Ver 0.8.5 - 17 January 2023<ul> <li>Update for web version</li> </ul> </li> <li>Ver 0.8.4 - 30 November 2022<ul> <li>Report files were updated.</li> </ul> </li> <li>Ver 0.8.3 - 30 November 2022<ul> <li>Minor bugs were fixed.</li> <li>Warning messages were updated.</li> <li>NCBI database parsing was optimised.</li> </ul> </li> <li>Ver 0.8.2 - 7 November 2022<ul> <li>xml files and assemblies annotation bugs were fixed.</li> <li>Annotation parsing was optimised.</li> </ul> </li> <li>Ver 0.8.1 - 4 November 2022<ul> <li>Large assemblies annotation bug was fixed.</li> </ul> </li> <li>Ver 0.8.0 - 2 November 2022<ul> <li>New exceptions control.</li> <li>New cmd parameter (-pc).</li> </ul> </li> <li>Ver 0.7.0 - 1 November 2022<ul> <li>NCBI database parsing was optimised and became ~10 times faster.</li> </ul> </li> <li>Ver 0.6.4 - 31 October 2022<ul> <li>MAFFT version 7.505 was replaced with v. 7.490 since it's more stable. </li> </ul> </li> <li>Ver 0.6.3 - 29 October 2022<ul> <li>Entrez.email for the NCBI requests was set. </li> </ul> </li> <li>Ver 0.6.2 - 26 October 2022  <ul> <li>A problem with xml file writing was fixed.</li> </ul> </li> <li>Ver 0.6.1 - 25 October 2022<ul> <li>! After the NCBI API update all previous version have a bug with identical protein database parsing. The bug was fixed in this version. </li> </ul> </li> <li>Ver 0.6.0 - 23 October 2022<ul> <li>New implementation of MSA visualisation</li> </ul> </li> <li>Ver 0.5.4 - 13 October 2022<ul> <li>Annotation visualisation' bug was fixed </li> </ul> </li> <li>Ver 0.5.3 - 12 October 2022<ul> <li>Minor bugs with pathes were fixed  </li> </ul> </li> <li>Ver 0.5.2 - 7 October 2022<ul> <li>MSA tool's path bug was fixed.</li> <li>Fast searching now is set as 'auto'.</li> </ul> </li> <li>Ver 0.5.1 - 6 October 2022<ul> <li>Now compatible with python3.7 (previous versions were compatible only with python3.8+).</li> </ul> </li> <li>Ver 0.5.0 - 4 October 2022<ul> <li>'Eukaryotes' and 'Prokaryotes' mode were introduced.</li> <li>MSA now perfomed with MAFT.</li> <li>New cmd and configs parameters were added.</li> <li>Minor bugs were fixed.</li> </ul> </li> <li>Ver 0.4.0 - 30 August 2022<ul> <li>Visualisation of loci annotation was added.</li> <li>Minor bugs were fixed.</li> </ul> </li> <li>Ver 0.3.1 - 17 August 2022<ul> <li>New cmd and configs parameters were added.</li> <li>Annotation of uORFs overlapped with the main CDSs was added.</li> </ul> </li> <li>Ver 0.3.0 - 7 August 2022<ul> <li>Algorithm of conserved ORFs searching was updated.</li> <li>New configs parameteres were added.</li> </ul> </li> <li>Ver 0.2.1 - 5 August 2022<ul> <li>Annotation parsing bug was fixed.</li> </ul> </li> <li>Ver 0.2.0 - 5 August 2022  <ul> <li>New cmd and configs parameters were added.</li> <li>New classes and methods were developed.</li> </ul> </li> <li>Ver 0.1.5 - 31 July 2022<ul> <li>MSA visualisation functions updated.</li> <li>Bugs were fixed. </li> <li>New cmd and configs parameters were added.</li> </ul> </li> <li>Ver 0.1 - 27 July 2022 - Initial release. </li> </ul>"}]}